package il.ac.technion.cs.fling.grammars.api;
import java.util.Arrays;
import java.util.List;
import il.ac.technion.cs.fling.FancyEBNF;
import il.ac.technion.cs.fling.internal.grammar.rules.TempComponent;
import il.ac.technion.cs.fling.internal.grammar.rules.Variable;
/** {@link FancyEBNF} AST types. Initially generated by Fling.
 *
 * @author Ori Roth */
@SuppressWarnings("all") public interface BNFAPIAST {
  class PlainBNF {
    @Override public String toString() {
      return "<" + start + "," + rules + ">";
    }
    public final Variable start;
    public final List<Rule> rules;
    public PlainBNF(final Variable start, final List<Rule> rules) {
      this.start = start;
      this.rules = rules;
    }
  }
  interface Rule {
  }
  interface RuleBody {
  }
  interface RuleTail {
  }
  class Derivation implements Rule {
    @Override public String toString() {
      return variable + "->" + ruleBody;
    }
    public final Variable variable;
    public final RuleBody ruleBody;
    public Derivation(final Variable derive, final RuleBody ruleBody) {
      this.variable = derive;
      this.ruleBody = ruleBody;
    }
  }
  class Specialization implements Rule {
    public final Variable specialize;
    public final Variable[] into;
    public Specialization(final Variable specialize, final Variable[] into) {
      this.specialize = specialize;
      this.into = into;
    }
  }
  class ConcreteDerivation implements RuleBody {
    @Override public String toString() {
      return Arrays.toString(to) + "," + ruleTail;
    }
    public final TempComponent[] to;
    public final List<RuleTail> ruleTail;
    public ConcreteDerivation(final TempComponent[] to, final List<RuleTail> ruleTail) {
      this.to = to;
      this.ruleTail = ruleTail;
    }
  }
  class EpsilonDerivation implements RuleBody {
    @Override public String toString() {
      return "Îµ";
    }
  }
  class ConcreteDerivationTail implements RuleTail {
    public final TempComponent[] or;
    public ConcreteDerivationTail(final TempComponent[] or) {
      this.or = or;
    }
  }
  class EpsilonDerivationTail implements RuleTail {
    public EpsilonDerivationTail() {
    }
  }
  public static class Visitor {
    public final void visit(final PlainBNF plainBNF) {
      try {
        this.whileVisiting(plainBNF);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
      plainBNF.rules.stream().forEach(_x_ -> visit(_x_));
    }
    public final void visit(final Rule rule) {
      if (rule instanceof Derivation)
        visit((Derivation) rule);
      else if (rule instanceof Specialization)
        visit((Specialization) rule);
    }
    public final void visit(final RuleBody ruleBody) {
      if (ruleBody instanceof ConcreteDerivation)
        visit((ConcreteDerivation) ruleBody);
      else if (ruleBody instanceof EpsilonDerivation)
        visit((EpsilonDerivation) ruleBody);
    }
    public final void visit(final RuleTail ruleTail) {
      if (ruleTail instanceof ConcreteDerivationTail)
        visit((ConcreteDerivationTail) ruleTail);
      else if (ruleTail instanceof EpsilonDerivationTail)
        visit((EpsilonDerivationTail) ruleTail);
    }
    public final void visit(final Derivation rule1) {
      try {
        this.whileVisiting(rule1);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
      visit(rule1.ruleBody);
    }
    public final void visit(final Specialization rule2) {
      try {
        this.whileVisiting(rule2);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
    }
    public final void visit(final ConcreteDerivation ruleBody1) {
      try {
        this.whileVisiting(ruleBody1);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
      ruleBody1.ruleTail.stream().forEach(_x_ -> visit(_x_));
    }
    public final void visit(final EpsilonDerivation ruleBody2) {
      try {
        this.whileVisiting(ruleBody2);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
    }
    public final void visit(final ConcreteDerivationTail ruleTail1) {
      try {
        this.whileVisiting(ruleTail1);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
    }
    public final void visit(final EpsilonDerivationTail ruleTail2) {
      try {
        this.whileVisiting(ruleTail2);
      } catch (final java.lang.Exception __) {
        __.printStackTrace();
      }
    }
    public void whileVisiting(final PlainBNF plainBNF) throws java.lang.Exception {
    }
    public void whileVisiting(final Derivation rule1) throws java.lang.Exception {
    }
    public void whileVisiting(final Specialization rule2) throws java.lang.Exception {
    }
    public void whileVisiting(final ConcreteDerivation ruleBody1) throws java.lang.Exception {
    }
    public void whileVisiting(final EpsilonDerivation ruleBody2) throws java.lang.Exception {
    }
    public void whileVisiting(final ConcreteDerivationTail ruleTail1) throws java.lang.Exception {
    }
    public void whileVisiting(final EpsilonDerivationTail ruleTail2) throws java.lang.Exception {
    }
  }
}
