package org.spartan.fajita.api.generators;

import static org.spartan.fajita.api.generators.GeneratorsUtils.generateBaseState;
import static org.spartan.fajita.api.generators.GeneratorsUtils.generateEmptyStack;
import static org.spartan.fajita.api.generators.GeneratorsUtils.generateErrorState;
import static org.spartan.fajita.api.generators.GeneratorsUtils.generateIStack;
import static org.spartan.fajita.api.generators.GeneratorsUtils.generateParseErrorException;
import static org.spartan.fajita.api.generators.GeneratorsUtils.type;

import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import org.spartan.fajita.api.bnf.BNF;
import org.spartan.fajita.api.bnf.symbols.SpecialSymbols;
import org.spartan.fajita.api.bnf.symbols.Symbol;
import org.spartan.fajita.api.bnf.symbols.Terminal;
import org.spartan.fajita.api.generators.GeneratorsUtils.Classname;
import org.spartan.fajita.api.generators.typeArguments.TypeArgumentManager;
import org.spartan.fajita.api.parser.Item;
import org.spartan.fajita.api.parser.LRParser;
import org.spartan.fajita.api.parser.State;

import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

public class ApiGenerator {
  private final LRParser parser;
  private final TypeArgumentManager tam;
  private BNF bnf;

  private ApiGenerator(BNF bnf) {
    this.bnf = bnf;
    parser = new LRParser(bnf);
    tam = new TypeArgumentManager(parser);
  }
  private TypeSpec generate() {
    Builder states = TypeSpec.classBuilder("AutoGenerated" + bnf.getApiName() + "States");
    states.addModifiers(Modifier.PUBLIC);
    states.addType(generateIStack());
    states.addType(generateEmptyStack());
    states.addType(generateErrorState(tam));
    states.addType(generateParseErrorException());
    states.addType(generateBaseState(tam));
    final List<TypeSpec> types = new ArrayList<>();
    parser.getStates().forEach(s -> {
      types.add(generateClass(tam, s, s.name));
    });
    states.addTypes(types);
    return states.build();
  }
  private static TypeSpec generateClass(final TypeArgumentManager tam, final State s, final String name) {
    Builder $ = TypeSpec.classBuilder(name) //
        .addModifiers(Modifier.STATIC, Modifier.PUBLIC) //
        .addTypeVariables(tam.getFormalParameters(s)) //
        .superclass(tam.getInstantiatedBaseState(s));
    // adds constructor
    if (s.index == 0)
      $.addMethod(MethodSpec.constructorBuilder().addStatement("super(new EmptyStack())").addModifiers(Modifier.PUBLIC).build());
    else
      $.addMethod(MethodSpec.constructorBuilder().addParameter(type(GeneratorsUtils.STACK_TYPE_PARAMETER), "stack")
          .addStatement("super(stack)").build());
    // adds methods
    ParameterizedTypeName baseState = tam.getInstantiatedBaseState(s);
    for (int i = 0; i < tam.symbols.size(); i++) {
      Symbol symb = tam.symbols.get(i);
      TypeName type = baseState.typeArguments.get(i + 1);
      if (type.toString().equals(Classname.ERROR_STATE.typename))
        continue;
      $.addMethod(getMethodSpec(symb, type, s));
    }
    if (s.getItems().stream().anyMatch(i -> i.readyToReduce() && i.lookahead.equals(SpecialSymbols.$)))
      $.addMethod(getMethodSpec(SpecialSymbols.$, TypeName.get(Object.class), s));
    return $.build();
  }
  private static MethodSpec getMethodSpec(Symbol symb, TypeName type, State s) {
    final boolean is$ = symb.equals(SpecialSymbols.$);
    com.squareup.javapoet.MethodSpec.Builder $ = MethodSpec.methodBuilder(symb.name()).addAnnotation(Override.class)
        .addModifiers(symb.isTerminal() || is$ ? Modifier.PUBLIC : Modifier.PROTECTED).returns(type);
    String body;
    if (s.isLegalTransition(symb)) {
      if (is$)
        body = "return new Object()";
      else
        body = "return new " + (type.getClass().equals(ParameterizedTypeName.class) ? ((ParameterizedTypeName) type).rawType + "<>"
            : type.toString()) + "(this)";
      $.addStatement(body);
    } else { // reduce
      Item reduce = s.getItems().stream().filter(item -> item.readyToReduce() && item.isLegalReduce((Terminal) symb)).findAny()
          .get();
      String pops = "pop()";
      for (int i = 1; i < reduce.dotIndex; i++)
        pops += ".pop()";
      String cast = is$ ? "" : "(" + type + ")";
      body = "return " + cast + pops + ".";
      if (!is$) {
        body += reduce.rule.lhs.name() + "().";
        $.addAnnotation(GeneratorsUtils.suppressWarningAnnot("unchecked"));
      }
      body += "$N" + "()";
      $.addStatement(body, symb.name());
    }
    return $.build();
  }
  public static TypeSpec generate(BNF bnf) {
    return new ApiGenerator(bnf).generate();
  }
}
