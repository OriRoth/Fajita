%! TEX root = 00.tex
What can be computed, and what can not be computed by coercing the type system
and the type checker of a certain programming language to do abstract
computations it was never meant to carry out? And, why should we care?

One concrete reason is fluent
APIs~\cite{VanDeursen:Klint:2000,Hudak:1997,Fowler:2010}.  There is joy, and in
many cases boost to productivity in elegant, neat code snippets such as
\begin{quote}
  \label{figure:DSL}
  \parbox[c]{44ex}{\javaInput[]{../Fragments/camel-apache.java.fragment}}
\end{quote}
(a use case of Apache Camel~\cite{Ibsen:Anstey:10}, open-source integration
framework), and,
\begin{quote}
  \javaInput[minipage,width=54ex,left=-2ex]{../Fragments/jOOQ.java.fragment}
\end{quote}
(a use case of jOOQ\urlref{http://www.jooq.org}, a framework for writing
SQL like code in \Java, much like LINQ project~\cite{Meijer:Beckman:Bierman:06}
in the context of \CSharp).

We argue that
the actual implementation of the many fluent API systems
jMock~\cite{Freeman:Pryce:06},
Hamcrest\urlref{http://hamcrest.org/JavaHamcrest/},
EasyMock\urlref{http://easymock.org/},
jOOR\urlref{https://github.com/jOOQ/jOOR},
jRTF\urlref{https://github.com/ullenboom/jrtf},
etc., is traditionally not carried out
in the neat manner it could possibly take.
Our reason for saying this is that the fundamental problem in
fluent API design is the decision on the ‟language”.
This language is the precise definition of which sequences of method
applications are legal and which are not.

As it turns out, the question of whether a BNF definition of such a language
can be ‟compiled” automatically into a fluent API implementation is, a
question of the computational power of the underlying language. In \Java, the problem
is particularly interesting since in \Java (unlike e.g., \CC~\cite{Gutterman:2003}),
the type system is not Turing complete.

It was shown recently that for any reasonable fluent API language definition
(specifically, one which can be recognized by an LR($k$) grammar for some~$k
≥0$), there exists some \Java implementation that realizes this
language~\cite{Gil:Levy:2016}.

The theoretical result takes a toll of exponential blowup. Specifically, the
construction first builds a deterministic pushdown automaton whose size
parameters, $g$ (number of stack symbols), and,~$q$ (number of internal
states), are polynomial in the size of the input grammar. This automaton is then
emulated by a weaker automaton, with as many as
\[
  O\left(g^{O(1)}\left(q²g^{O(1)}\right)^{qg^{O(1)}}\right)
\] 
stack symbols.
This weaker automaton is then ``compiled'' into a  collection of generic \Java types,
where there is at least one type for each of these symbols.

Here we present an algorithm to compile an LL(1) grammar of a fluent API
language into a \Java implementation whose size is linear in the grammar's
size. \Fajita is a \Java tool that implements this algorithm.

\Cref{figure:sql-bnf} is a BNF specification of a fluent API for a certain
fragment of SQL.

\begin{figure}[H]
  \caption{\label{figure:sql-bnf}
    A BNF for a fragment of SQL select queries.
  }
  \begin{Grammar}
    \begin{aligned}
      \<Query>    & \Derives \cc{select()} \<Quant>\~\cc{from(Table.\kk{class})} \<Where> \hfill⏎
      \<Quant>    & \Derives \cc{all()} \hfill⏎
                  & \| \cc{columns(Column[].\kk{class})} \hfill⏎
      \<Where>    & \Derives \cc{where()} \cc{column(Column.\kk{class})} \<Operator> \hfill⏎
                  & \|ε \hfill⏎
      \<Operator> & \Derives \cc{equals(Expr.\kk{class})}\hfill⏎
                  & \| \cc{greaterThan(Expr.\kk{class})} \hfill⏎
                  & \|\cc{lowerThan(Expr.\kk{class})} \hfill
    \end{aligned}
  \end{Grammar}
\end{figure}

To create a \Java implementation that realizes this fluent API,
  the designer feeds the grammar to \Fajita, as in  
  \cref{figure:sql-bnf-java}.

\begin{figure}[H]
  \caption{\label{figure:sql-bnf-java}
    A \Java code excerpt defining the BNF specification of the fragment SQL
    language defined in \cref{figure:sql-bnf}.}
  \javaInput[minipage,width=\linewidth,left=-6ex]{sql.bnf.listing}
\end{figure}

We see that \Fajita's API is fluent in itself, and the 
  call chain in \cref{figure:sql-bnf-java}, is structured almost
  exactly as in derivation rules in \cref{figure:sql-bnf}.
In particular, the code in \cref{figure:sql-bnf-java} shows how fluent API specification in \Fajita
  may include parameterless methods (\cc{select()}, \cc{all()} and \cc{where}) as well as methods which 
  take parameters, e.g., method \cc{column} taking parameter of type \cc{Column} and 
    method \cc{from} taking a \cc{Table} parameter.

Other than the derivation rules, \Fajita  needs to be told the start rule
  and the sets of terminals and nonterminals.
These are specified in the first method call in the chain where, 
  the enumerate types \cc{SQLTerminals} and \cc{SQLNonTerminals} are:

\begin{quote}
  \parbox[c]{43ex}{\javaInput[minipage,width=\linewidth,left=-4ex]{sql.enums.listing}}
\end{quote}

\Fajita then generates types and methods realizing the fluent API
 in such a way, that code snippet such as 
\begin{quote}
  \parbox[c]{43ex}{\javaInput[minipage,width=\linewidth,left=-4ex]{sql.usage.listing}}
\end{quote}

A problem related to that of recognizing a formal language,
is that of parsing, i.e., creating, for input which is within the language,
a parse tree according to the language's grammar.
In the domain of fluent APIs, the distinction between recognition and parsing
is in fact the distinction between compile time and runtime.
Before a program is run, the compiler checks whether the fluent API call is
legal, and code completion tools will only suggest legal extensions of a
current call chain.

In contrast, a parse tree can only be created at runtime.
Some fluent API definitions create the parse-tree
iteratively, where each method invocations in the call chain adding
more components to this tree.
However, it is always possible to generate this tree in ‟batch” mode:
This is done by maintaining a \emph{fluent-call-list} which
starts empty and grows at runtime by having each method invoked add to it
a record storing the method's name and values of its parameters.
The list is completed at the end of the fluent-call-list, at which point it is
fed to an appropriate parser that converts it into a parse tree (or even an
AST).

\subsection{Related Work}
The challenges of \Java generic programming were highlighted by Garcia et
al.~\cite{Garcia:Jarvi:Lumsdaine:Siek:Willcock:03} research on the expressive
power of generics in half a dozen major programming languages, 
Indeed, unlike \CC~\cite{Austern:1998,Musser:Stepanov:1989,
Backhouse:Jansson:1999, Dehnert:Stepanov:2000,Gil:Gutterman:98,Abrahams:Gurtovoy:04}, the literature on meta-programming with \Java
generics is minimal. 

Suggestions for semi-automatic generation of fluent APIs in \Java can be found
e.g., in the work of Bodden~\cite{Bodden:14} and on numerous locations in the
web. However, none of these matured into an actual general purpose
implementation.  

Fluflu\urlref{https://github.com/verhas/fluflu} is a software artifact similar
to in principle~\Fajita, which uses \Java annotations to define deterministic finite
automaton (DFA), to be compiled into a fluent API based on this automaton. 

Compare \Fajita use case (\cref{figure:sql-bnf-java}) with \cref{figure:fluflu} in
which fluflu is used to define a DFS with a single, both initial- and
accepting- and  state, and accepting, with a single self transition, labeled
with terminal~$a$, whereby realizing the regular language~$L=a^*$.

\begin{figure}[H]
  \caption{\label{figure:fluflu}
    A fluflu specification of the DFA recognizing the regular language~$a^*$}
  \javaInput[minipage,left=-4ex]{fluflu.example.listing}
\end{figure}
