Automatically generated by Mendeley Desktop 1.15.2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@book{Autebert1997,
author = {Autebert, Jean-Michel and Berstel, Jean and Boasson, Luc},
file = {:home/tomerlevi/Downloads/chp{\%}3A10.1007{\%}2F978-3-642-59136-5{\_}3.pdf:pdf},
pages = {111--174},
publisher = {Springer Berlin Heidelberg},
title = {{Context-Free Languages and Pushdown Automata}},
year = {1997}
}
@book{Aho1986,
abstract = {This book is a descendant of Principles of Compiler Design by Alfred V. Aho and Jeffrey D. Ullman. Like its ancestor, it is intended as a text for a first course in compiler design. The emphasis is on solving problems universally encountered in designing a language translator, regardless of the source or tar- get machine.},
author = {Aho, Alfred V and Sethi, Ravi and Ullman, Jeffrey D},
file = {:home/tomerlevi/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Aho, Sethi, Ullman - 1986 - Compilers Principles.pdf:pdf},
isbn = {0201100886},
number = {0011},
pages = {0},
pmid = {2859937},
publisher = {Addison-Wesley},
title = {{Compilers: Principles Techniques, and Tools}},
volume = {11},
year = {1986}
}
@phdthesis{Larsen2012,
author = {Larsen, Robert},
file = {:home/tomerlevi/Downloads/RobertLarsen.pdf:pdf},
school = {University of Oslo},
title = {{Fluenty: A type safe query API}},
type = {Master},
year = {2012}
}
@book{Bison:manual,
author = {{Charles Donnelly} and Stallman, Richard},
title = {{Bison}},
year = {2015}
}
@article{Freeman2006,
abstract = {This paper describes the experience of evolving a domain-specific language embedded in Java over several generations of a test framework. We describe how the framework changed from a library of classes to an embedded language. We describe the lessons we have learned from this experience for framework developers and language designers.},
annote = {JMock reference},
author = {Freeman, Steve and Pryce, Nat},
doi = {10.1145/1176617.1176735},
file = {:home/tomerlevi/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Freeman, Pryce - 2006 - Evolving an embedded domain-specific language in Java.pdf:pdf},
isbn = {159593491X},
journal = {Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications},
keywords = {embedded domain-specific language,java,mock},
title = {{Evolving an embedded domain-specific language in Java}},
year = {2006}
}
@article{Parr1995,
abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC, programmers often choose to write recursive-descent parsers by hand to obtain increased flexibility, better error handling, and ease of debugging. We introduce ANTLR, a public-domain parser generator that combines the flexibility of hand-coded parsing with the convenience of a parser generator, which is a component of PCCTS. ANTLR has many features that make it easier to use than other language tools. Most important, ANTLR provides predicates which let the programmer systematically direct the parse via arbitrary expressions using semantic and syntactic context; in practice, the use of predicates eliminates the need to hand-tweak the ANTLR output, even for difficult parsing problems. ANTLR also integrates the description of lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with extended BNF notation, and can automatically generate abstract syntax trees.ANTLR is widely used, with over 1000 registered industrial and academic users in 37 countries. It has been ported to many popular systems such as the PC, Macintosh, and a variety of UNIX platforms; a commercial C++ front-end has been developed as a result of one of our industrial collaborations.},
author = {Parr, T J and Quong, R W},
doi = {10.1002/spe.4380250705},
file = {:home/tomerlevi/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Parr, Quong - 1995 - ANTLR A predicated-LL(k) parser generator.pdf:pdf},
isbn = {0038-0644},
issn = {1097-024X},
journal = {Software: Practice and Experience},
keywords = {LL(k) parser,compiler,parser generator,parsing,predicates},
number = {7},
pages = {789--810},
title = {{ANTLR: A predicated-LL(k) parser generator}},
volume = {25},
year = {1995}
}
@phdthesis{Bekkerman:04,
author = {Bekkerman, Anna},
file = {:home/tomerlevi/Downloads/anna bekk.pdf:pdf},
school = {Technion-–-Israel Institute of Technology},
title = {{Conflict Resolution and Operator Priorities in Extended BNF}},
year = {2004}
}
@article{Knuth1965,
abstract = {There has been much recent interest in languages whose grammar is sufficiently simple that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, and they provide the basis for understanding all of the special tricks which have been used in the construction of parsing algorithms for languages with simple structure, e.g. algebraic languages. We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, and also give methods for generating recognizes for LR(k) grammars. It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.},
annote = {Page 31, at the bottom:
{\&}quot;
There are also implications for automata theory. We have shown that a deterministic push-down automaton accepts precisely those languages that. can be given an LR(k) grammar. 
{\&}quot;},
author = {Knuth, Donald E.},
doi = {10.1016/S0019-9958(65)90426-2},
file = {:home/tomerlevi/Downloads/knuth65.pdf:pdf},
issn = {00199958},
journal = {Information and Control},
number = {6},
pages = {607--639},
title = {{On the translation of languages from left to right}},
volume = {8},
year = {1965}
}
@article{Deursen2000,
abstract = {We survey the literature available on the topic of domain-specific languages as used for the construction and maintenance of software systems. We list a selection of 75 key publications in the area, and provide a summary for each of the papers. Moreover, we discuss terminology, risks and benefits, example domain-specific languages, design methodologies, and implementation techniques.},
author = {Deursen, Arie Van and Klint, Paul and Visser, Joost},
doi = {10.1145/352029.352035},
file = {:home/tomerlevi/Downloads/download.pdf:pdf},
isbn = {0362-1340},
issn = {03621340},
journal = {ACM Sigplan Notices},
number = {6},
pages = {26--36},
title = {{Domain-specific languages: an annotated bibliography}},
url = {http://portal.acm.org/citation.cfm?doid=352029.352035},
volume = {35},
year = {2000}
}
@book{Cocke:1969,
abstract = {@book{\{}:PLC:1097042, author = {\{}{\}}, title = {\{}Prog{\}}, year = {\{}1969{\}}, isbn = {\{}B0007F4UOA{\}}, publisher = {\{}{\}}, {\}}},
author = {Cocke, John},
publisher = {Courant Institute of Mathematical Sciences, New York University},
title = {{Programming Languages and Their Compilers: Preliminary Notes}},
year = {1969}
}
@article{Younger:1967,
abstract = {A recognition algorithm is exhibited whereby an arbitrary string over a given vocabulary can be tested for containment in a given context-free language. A special merit of this algorithm is that it is completed in a number of steps proportional to the “cube” of the number of symbols in the tested string. As a byproduct of the grammatical analysis, required by the recognition algorithm, one can obtain, by some additional processing not exceeding the “cube” factor of computational complexity, a parsing matrix—a complete summary of the grammatical structure of the sentence. It is also shown how, by means of a minor modification of the recognition algorithm, one can obtain an integer representing the ambiguity of the sentence, i.e., the number of distinct ways in which that sentence can be generated by the grammar. The recognition algorithm is then simulated on a Turing Machine. It is shown that this simulation likewise requires a number of steps proportional to only the “cube” of the test string length.},
author = {Younger, Daniel H.},
doi = {10.1016/S0019-9958(67)80007-X},
file = {:home/tomerlevi/Downloads/1-s2.0-S001999586780007X-main.pdf:pdf},
issn = {00199958},
journal = {Information and Control},
number = {2},
pages = {189--208},
title = {{Recognition and parsing of context-free languages in time n3}},
url = {http://www.sciencedirect.com/science/article/pii/S001999586780007X},
volume = {10},
year = {1967}
}
@book{Bauer:2005,
abstract = {Hibernate practically exploded on the Java scene. Why is this open-source tool so popular? Because it automates a tedious task: persisting your Java objects to a relational database. The inevitable mismatch between your object-oriented code and the relational database requires you to write code that maps one to the other. This code is often complex, tedious and costly to develop. Hibernate does the mapping for you. Not only that, Hibernate makes it easy. Positioned as a layer between your application and your database, Hibernate takes care of loading and saving of objects. Hibernate applications are cheaper, more portable, and more resilient to change. And they perform better than anything you are likely to develop yourself. "Hibernate in Action" carefully explains the concepts you need, then gets you going. It builds on a single example to show you how to use Hibernate in practice, how to deal with concurrency and transactions, how to efficiently retrieve objects and use caching. The authors created Hibernate and they field questions from the Hibernate community every day-they know how to make Hibernate sing. Knowledge and insight seep out of every pore of this book. "What's Inside" - ORM concepts - Getting started - Many real-world tasks - The Hibernate application development process},
author = {Bauer, Christian and King, Gavin},
isbn = {193239415X},
publisher = {Manning Publications Co},
title = {{Hibernate in Action}},
year = {2005}
}
@article{Kabanov2008,
abstract = {Projects like jMock and Hibernate Criteria Query introduced embedded DSLs into Java. We describe two case studies in which we develop embedded typesafe DSLs for building SQL queries and engineering Java bytecode. We proceed to extract several patterns useful for developing typesafe DSLs for arbitrary domains. Unlike most previous Java DSLs we find that mixing the Fluent Interface idiom with static functions, metadata and closures provides for a better user experience than pure method chaining. We also make very liberal use of the Java 5 Generics to improve the type safety properties of the DSLs.},
author = {Kabanov, Jevgeni and Raudj{\"{a}}rv, Rein},
doi = {10.1145/1411732.1411758},
file = {:home/tomerlevi/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kabanov, Raudj{\"{a}}rv - 2008 - Embedded typesafe domain specific languages for Java.pdf:pdf},
isbn = {9781605582238},
journal = {Proceedings of the 6th international symposium on Principles and practice of programming in Java - PPPJ '08},
keywords = {domain-specific,dsl,java,typesafe},
title = {{Embedded typesafe domain specific languages for Java}},
year = {2008}
}
@misc{Fowler2005,
author = {Fowler, Martin and Evans, Eric},
keywords = {DSL,Fluent Interface},
mendeley-tags = {DSL,Fluent Interface},
title = {{FluentInterface}},
url = {http://martinfowler.com/bliki/FluentInterface.html},
urldate = {2015-11-29},
year = {2005}
}
@book{Linz:2001,
abstract = {Written to address the fundamentals of formal languages, automata, and computabilty, An Introduction to Formal Languages and Automata provides an accessible, student-friendly presentation of all material essential to an introductory Theory of Computation course. It is designed to familiarize students with the foundations and principles of computer science and to strengthen the students' ability to carry out formal and rigorous mathematical arguments. In the new Fifth Edition, Peter Linz continues to offer a straightforward, uncomplicated treatment of formal languages and automata and avoids excessive mathematical detail so that students may focus on and understand the underlying principles. In an effort to further the accessibility and comprehension of the text, the author has added new illustrative examples and exercises throughout. There is a substantial amount of new material in the form of two new appendices, and a CD-ROM of JFLAP exercises authored by Susan Rodger of Duke University. The first appendix is an entire chapter on finite-state transducers. This optional chapter can be used to prepare students for further related study. The second appendix offers a brief introduction to JFLAP; an interactive software tool that is of great help in both learning the material and in teaching the course. Many of the exercises in the text require creating structures that are complicated and that have to be tested for correctness. JFLAP can greatly reduce students’ time spent on testing as well as help them visualize abstract concepts. The CD-ROM that accompanies this fifth edition expands this and offers exercises specific for JFLAP.},
author = {Linz, Peter},
isbn = {0763714224},
publisher = {Jones {\&} Bartlett Learning},
title = {{An Introduction to Formal Languages and Automata}},
year = {2011}
}
@article{Hudak1996,
abstract = {Note: OCR errors may be found in this Reference List extracted from the full text article. ACM has opted to expose the complete List rather than only correct and linked references.},
author = {Hudak, Paul},
doi = {10.1145/242224.242477},
issn = {03600300},
journal = {ACM Comput. Surv.},
number = {4es},
pages = {1--6},
title = {{Building Domain-Specifc Embedded Languages}},
url = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.6020{\&}rep=rep1{\&}type=pdf},
volume = {28},
year = {1996}
}
@book{Hopcroft2001,
author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
edition = {2nd editio},
pages = {249},
publisher = {Addison-Wesley},
title = {{Introduction to automata theory, languages, and computation}},
year = {2001}
}
@book{Gosling2005,
abstract = {Written by the inventors of the technology, The Java Language Specification, Third Edition, is the definitive technical reference for the Java programming language. If you want to know the precise meaning of the language's constructs, this is the source for you.The book provides complete, accurate, and detailed coverage of the Java programming language. It provides full coverage of all new features added since the previous edition, including generics, annotations, asserts, autoboxing, enums, for-each loops, variable arity methods, and static import clauses.},
author = {Gosling, James and Joy, Bill and Steele, Guy and Bracha, Gilad},
booktitle = {Addison-Wesley},
file = {:home/tomerlevi/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Gosling et al. - 2005 - The Java Language Specification(2).pdf:pdf},
title = {{The Java Language Specification}},
year = {2005}
}
@book{Fowler2010,
abstract = {When carefully selected and used, Domain-Specific Languages (DSLs) may simplify complex code, promote effective communication with customers, improve productivity, and unclog development bottlenecks. In Domain-Specific Languages, noted software development expert Martin Fowler first provides the information software professionals need to decide if and when to utilize DSLs. Then, where DSLs prove suitable, Fowler presents effective techniques for building them, and guides software engineers in choosing the right approaches for their applications. This book's techniques may be utilized with most modern object-oriented languages; the author provides numerous examples in Java and C, as well as selected examples in Ruby. Wherever possible, chapters are organized to be self-standing, and most reference topics are presented in a familiar patterns format. Armed with this wide-ranging book, developers will have the knowledge they need to make important decisions about DSLs-and, where appropriate, gain the significant technical and business benefits they offer. The topics covered include: How DSLs compare to frameworks and libraries, and when those alternatives are sufficient Using parsers and parser generators, and parsing external DSLs Understanding, comparing, and choosing DSL language constructs Determining whether to use code generation, and comparing code generation strategies Previewing new language workbench tools for creating DSLs},
author = {Fowler, Martin},
booktitle = {IFIP TC 2 Working Converence},
doi = {10.1007/978-3-642-03034-5},
isbn = {9780321712943},
issn = {1557170X},
pages = {640},
pmid = {17270914},
title = {{Domain-Specific Languages}},
url = {http://www.amazon.com/Domain-Specific-Languages-Addison-Wesley-Signature-Fowler/dp/0321712943},
volume = {5658},
year = {2010}
}
@article{Turing1937,
author = {Turing, Alan M.},
journal = {The Journal of Symbolic Logic},
pages = {153----163},
title = {{Computability and $\lambda$-definability}},
volume = {2},
year = {1937}
}
@article{Earley:1970,
abstract = {A parsing algorithm which seems to be the most efficient general context-free algorithm known is described. It is similar to both Knuth's LR(k) algorithm and the familiar top-down algorithm. It has a time bound proportional to n3 (where n is the length of the string being parsed) in general; it has an n2 bound for unambiguous grammars; and it runs in linear time on a large class of grammars, which seems to include most practical context-free programming language grammars. In an empirical comparison it appears to be superior to the top-down and bottom-up algorithms studied by Griffiths and Petrick.},
author = {Earley, Jay},
doi = {10.1145/362007.362035},
file = {:home/tomerlevi/Downloads/p94-earley.pdf:pdf},
isbn = {0001-0782},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {12,22,23,4,5,and phrases,compilers,computational complexity,context-free grammar,cr categories,in the sense that,parsing,some are general,syntax analysis,they can handle all},
number = {2},
pages = {94--102},
title = {{An efficient context-free parsing algorithm}},
volume = {13},
year = {1970}
}
@article{Aho1968,
abstract = {This paper is concerned with the recognition of words which are contained in languages defined by pushdown store machines. Such languages exhibit many of the syntactic properties of algorithmic programming languages. Thus the recognition problem for languages generated by pushdown store machines is related to compilation of programming languages.},
author = {a.V. Aho and Hopcroft, J.E. and Ullman, J.D.},
doi = {10.1016/S0019-9958(68)91087-5},
file = {:home/tomerlevi/Downloads/1-s2.0-S0019995868910875-main.pdf:pdf},
issn = {00199958},
journal = {Information and Control},
number = {3},
pages = {186--206},
title = {{Time and tape complexity of pushdown automaton languages}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0019995868910875},
volume = {13},
year = {1968}
}
@article{Parr2011,
abstract = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k>=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
author = {Parr, Terence and Fisher, Kathleen},
doi = {http://doi.acm.org/10.1145/1993498.1993548},
file = {:home/tomerlevi/Downloads/p425-parr.pdf:pdf},
isbn = {978-1-4503-0663-8},
issn = {03621340},
journal = {Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation},
keywords = {augmented transition networks,backtracking,context-sensitive parsing,deterministic finite automata,glr,memoization,nondeterministic parsing,peg,semantic predicates,subset construction,syntactic predicates},
pages = {425--436},
title = {{LL(*): the foundation of the ANTLR parser generator}},
url = {http://doi.acm.org/10.1145/1993498.1993548},
year = {2011}
}
