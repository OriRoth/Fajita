%! TEX root = 00.tex

There were a total of six methods that might be invoked in the example of the
previous section:
\begin{quote}
  \begin{tabular}{lll}
    \cc{male()}   & \cc{raise()} & \cc{urinate()}⏎
    \cc{female()} & \cc{lower()} & \cc{defecate()}⏎
  \end{tabular}
\end{quote}
\cref{figure:BNF} is a BNF specification of the order in which they might be
invoked.

\begin{figure}
  \begin{Grammar}
    \begin{aligned}
      \<Visitors>         & \Derives \<Down-Visitors> \hfill⏎
      \<Down-Visitors>    & \Derives \<Down-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| \<Raising-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitors>      & \Derives \<Up-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| \<Lowering-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitor>       & \Derives \cc{male()} \~\cc{urinate()} \hfill⏎
      \<Down-Visitor>     & \Derives \cc{female()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \cc{defecate()} \hfill⏎
      \<Raising-Visitor>  & \Derives \cc{male()} \~\cc{raise()} \~\cc{urinate()} \hfill⏎
      \<Lowering-Visitor> & \Derives \cc{female()} \~\cc{lower()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \~\cc{lower()} \cc{defecate()} \hfill⏎
      \<Activity>         & \Derives \cc{urinate()} \hfill⏎
                          & \| \cc{defecate()} \hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for the toilette seat problem}
  \label{figure:BNF}
\end{figure}

\Fajita takes this grammar specification as input, and in response
generates the corresponding \Java type hierarchy. 
(Our proof-of-concept
implementation does not yet deal with the construction of an AST from a concrete
method call chain.) 

The \Fajita specification is made with a \Java fluent API
  in the form of context-free grammar.
The grammar for out toillete example is depicted in \cref{figure:BNF}.

To define grammars, one must first define the set of \emph{grammar
terminals}
\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{43ex}{\linewidth},left=-2ex]{../Fragments/toilette-terminals.fragment}
\end{quote}

We are also required to define the set of \emph{grammar variables}
\begin{quote}
  \javaInput[minipage,width=\ReplaceInThesis{43ex}{\linewidth},left=-2ex]{../Fragments/toilette-variables.fragment}
\end{quote}

Once the set of terminals and nonterminals are fixed, the grammar can be
defined, in a fluent API generated by \Fajita itself as shown in
\cref{figure:fluent}.

\begin{figure}
  \javaInput[minipage,width=\linewidth,left=-2ex]{../Fragments/toilette-generation.fragment}
  \caption{A BNF grammar for the types state example}
  \label{figure:fluent}
\end{figure}

The call to function \cc{go()} (last line in \cref{figure:fluent}) instructs
\Fajita to generate the code for the fluent API specified by the
subsequent part of the expression.

Nonterminals are translated to classes while terminals are translated to methods which
take no parameters.  

Library classes such as \cc{String} and \cc{Integer}, just as user-defined
classes such as \cc{Invoice} may be used as well.  \Fajita generates class
definitions only for classes whose name is declared in an \kk{enum} which is
passed to the \cc{with} function in the BNF declaration.  Recall also that methods that
take a parameters (\cref{figure:sql-bnf-java}) can be used as tokens as well.

Even though \Fajita is not at production level, we plan on submitting it to 
artifact evaluation. The current BNF specification of the tool is given in
\cref{figure:BNF:BNF} (which incidentally can be written in \Fajita fluent 
API iteself)

\begin{figure}[ht]
  \begin{Grammar}
    \begin{aligned}
      \<BNF>                & \Derives \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header>             & \Derives \<Variables> \~\<Terminals> \hfill⏎
      {}                    & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables>          & \Derives \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals>          & \Derives \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body>               & \Derives \<Start> \~\<Rule> \~ \<Rules> \hfill⏎
      \<Start>              & \Derives \cc{start(\<Variable>)} \hfill⏎
      \<Rules>              & \Derives \<Rule> \~\<Rules>\hfill⏎
      {}                    & \| ε\hfill⏎
      \<Rule>               & \Derives \cc{derives(\<Variable>)} \<Conjunctions>\hfill⏎
      \<Conjunctions>       & \Derives \<First-Conjunction>\~\<Conjunctions>\hfill⏎
      \<First-Conjunction>  & \Derives \cc{to(\<Symbol>)}\~\<Symbols>\hfill⏎
      {}                    & \| \cc{toNone()}\hfill⏎
      \<Conjunctions> & \Derives \<Conjunction>\~\<Conjunctions>\hfill⏎
      {}                    & \| ε\hfill⏎
      \<Conjunction>  & \Derives \cc{or(\<Symbol>)}\~\<Symbols>\hfill⏎
      {}                    & \| \cc{orNone()} \hfill⏎
      \<Symbols>    & \Derives ε \hfill⏎
      {}                    & \| \cc{and(\<Symbol>)}\~\<Symbols> \hfill⏎
      \<Symbol>             & \Derives \cc{Variable} \hfill⏎
      {}                    & \| \cc{Terminal} \hfill⏎
      {}                    & \| \cc{Terminal} \~ \<Parameters> \hfill⏎
      \<Parameters>         & \Derives \cc{,} \<Existing-Class> \~ \<Parameters>\hfill⏎
      {}                    & \| ε \hfill⏎
      \<Footer>             & \Derives \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{figure:BNF:BNF}
\end{figure}
