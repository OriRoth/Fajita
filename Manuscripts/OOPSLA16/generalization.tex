%! TEX root = 00.tex
Section: generalization:
how to generate toilette with DFA\@.% already written in intuition
Generalization to pushdown.
Examples were pushdown automata become essential are: probably stack, scoping
in html, in hint only: nested SQL queries.

In the example of the previous section,
there were a total of six methods that might be invoked.
\begin{quote}
  \begin{tabular}{lll}
    \cc{male()}   & \cc{raise()} & \cc{urinate()}⏎
    \cc{female()} & \cc{lower()} & \cc{defecate()}⏎
  \end{tabular}
\end{quote}

\Cref{figure:BNF} is such a specification for the toilette seat problem.

\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<Visitors>         & ::= \<Down-Visitors> \hfill⏎
      \<Down-Visitors>    & ::= \<Down-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| \<Raising-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitors>      & ::= \<Up-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| \<Lowering-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitor>       & ::= \cc{male()} \~\cc{urinate()} \hfill⏎
      \<Down-Visitor>     & ::= \cc{female()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \cc{defecate()} \hfill⏎
      \<Raising-Visitor>  & ::= \cc{male()} \~\cc{raise()} \~\cc{urinate()} \hfill⏎
      \<Lowering-Visitor> & ::= \cc{female()} \~\cc{lower()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \~\cc{lower()} \cc{defecate()} \hfill⏎
      \<Activity>         & ::= \cc{urinate()} \hfill⏎
                          & \| \cc{defecate()} \hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for the toilette seat problem}
  \label{figure:BNF}
\end{figure}

\Self takes this grammar specification as input, and in response
generates the corresponding
\Java type hierarchy.

\subsection{Verbs and Nouns}
A second novelty of \Self is that the specification of a BNF such as in
\cref{figure:BNF} can be also made with a \Java fluent API\@.
To do so, it is first necessary to
define the set of \emph{grammar terminals}
\begin{code}{JAVA}
enum ToiletteTerminals implements Terminal {¢¢
  male, female,
  urinate, defecate,
  lower, raise;
}
\end{code}
As common in fluent APIs we shall refer to these
as \emph{verbs}†{Admittedly, the words ‟male” and ‟female” are nouns.
An excuse might be that the words are used as nouns to mean ‟male-visit” and ‟female-visit”.}.
Verbs are translated by \Self into methods.

We are also required to define the set of \emph{grammar variables}
\begin{code}{Java}
enum ToiletteVariables implements Variable {¢¢
  Visitors, Down_Visitors, Up_Visitors,
  Up_Visitor, Down_Visitor,
  Lowering_Visitor, Raising_Visitor,
  Activity
};
\end{code}
We shall use the term ‟\emph{noun}” as synonymous to ‟variable”.

\subsection{Words and Grammar}
The terms ‟symbol” and ‟word” refer to an entity which is either
a verb or a noun.

Once the verbs and the nouns are set, the grammar can be defined,
using a fluent API generated by \Self itself as shown
in \cref{figure:fluent}.

\begin{figure}[H]
  \begin{JAVA}[style=numbered]
new BNF()
  ¢¢.with(ToiletteTerminals.class)
  ¢¢.with(ToiletteSymbols.class)
  ¢¢.start(Visitors)
  ¢¢.derive(Visitors).to(Down_Visitors)
  ¢¢.derive(Down_Visitors)
    ¢¢.to(Down_Visitor).and(Down_Visitors)
    ¢¢.or(Raising_Visitor).and(Up_Visitors)
    ¢¢.orNone()
  ¢¢.derive(Up_Visitors)
    ¢¢.to(Up_Visitor).and(Up_Visitors)
    ¢¢.or(Lowering_Visitor).and(Down_Visitors)
    ¢¢.orNone()
  ¢¢.derive(Up_Visitor).to(male).and(urinate)
  ¢¢.derive(Down_Visitor)
    ¢¢.to(female).and(Action)
    ¢¢.or(male).and(defecate)
  ¢¢.derive(Raising_Visitor).to(male).and(raise).and(urinate)
  ¢¢.derive(Lowering_Visitor)
    ¢¢.to(female).and(lower).and(Action)
    ¢¢.or(male).and(lower).and(defecate)
  ¢¢.derive(Activity)
    ¢¢.to(urinate)
    ¢¢.or(defecate)
  ¢¢.go();
  \end{JAVA}
  \caption{A BNF grammar for the toilette seat problem}
  \label{figure:fluent}
\end{figure}

The call to function \cc{go()} (last line in \cref{figure:fluent}) instructs
\Self to generate the code for the fluent API specified by the
subsequent part of the expression.
Roughly speaking, nouns are translated to classes while verbs are translated to methods which
take no parameters.
Two exceptions apply:
\begin{enumerate}
  \item
        Library classes such as \cc{String} and \cc{Integer}, just as user-defined
        classes such as \cc{Invoice} may be used as nouns.
        \Self generate class definitions only for classes whose name is declared
        in an \kk{enum} which is passed to \cc{with} verb in the BNF declaration.
  \item Verbs may take noun parameters, as explained below.
\end{enumerate}

As should be obvious from \cref{figure:fluent}, \Self will be implemented
in a bootstrapping fashion.
The specification of a BNF, is made itself using a fluent API.

This section describes how this is achieved.

\subsection{Reflective BNF}
\cref{figure:BNF:BNF} is a \emph{reflective BNF}:
It uses the notation introduced in \cref{figure:BNF}
to specify this same notation.

\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<BNF>                & ::= \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header>             & ::= \<Variables> \~\<Terminals> \hfill⏎
      {}                    & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables>          & ::= \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals>          & ::= \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body>               & ::= \<Start> \~\<Rules> \hfill⏎
      \<Start>              & ::= \cc{start(\<Variable>)} \hfill⏎
      \<Rules>              & ::= \<Rule> \~\<Rules>\hfill⏎
      {}                    & \| \<Rule> \hfill⏎
      \<Rule>               & ::= \cc{derives(\<Variable>)} \<Conjunctions>\hfill⏎
      \<Conjunctions>       & ::= \<First-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      \<First-Conjunction>  & ::= \cc{to(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                    & \| \cc{toNone()}\hfill⏎
      \<Extra-Conjunctions> & ::= \<Extra-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      {}                    & \| ε\hfill⏎
      \<Extra-Conjunction>  & ::= \cc{or(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                    & \| \cc{orNone()} \hfill⏎
      \<Symbol-Sequence>    & ::= ε \hfill⏎
      {}                    & \| \cc{and(\<Symbol>)}\~\<Symbol-Sequence> \hfill⏎
      \<Symbol>             & ::= \cc{Variable} \hfill⏎
      {}                    & \| \<Verb>\hfill⏎
      {}                    & \| \<Verb>~\cc{,} \<Noun> \hfill⏎
      \<Noun>               & ::= \<Variable> \hfill⏎
      {}                    & \| \<Existing-Class> \hfill⏎
      \<Variable>           & ::= \cc{Variable} \hfill⏎
      \<Footer>             & ::= \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{figure:BNF:BNF}
\end{figure}
% this is not a formal BNF because <Symbol> and <Variable> are not defined in the Symbols set.
\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
Note that this specification can only be approximate;
the figure uses verbs as replacement to indentation,
and special symbols such as~$|$,~$::-$ and~$ε$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{comment}

From \cref{figure:BNF:BNF} we learn
that a BNF has three components: header, body and footer.
\begin{enumerate}
  \item The sets of terminals and variables are defined in the header part.
  \item The body starts with a definition of the start symbol, followed by a list of derivation
        rules.
  \item The footer is simply the verb \cc{go()} which instructs \Self
        to generate the code that realizes the fluent API specified by the grammar.
\end{enumerate}

A derivation rule starts with a variable, and is then followed by disjunctive alternatives.

The choice of verbs that may occur in, and between, these alternatives not incidental;
fluency was in mind:
\begin{description}
  \item[\cc{to}] to introduce the first symbol in the first conjunction.
  \item[\cc{or}] to introduce the first symbol in each subsequent conjunction.
  \item[\cc{and}] to introduce all but the first symbol in each such conjunction.
  \item[\cc{toNone}] to declare that the first conjunction is empty.
  \item[\cc{orNone}] to declare any subsequent conjunction is empty.
\end{description}

\subsection{Reflective BNF of fluent API}

To translate \cref{figure:BNF:BNF} into a fluent
API chain, the verbs and nouns must be defined.

Verb definitions are made in the code excerpt in
\cref{figure:Verbs}.

\begin{figure}[htb]
  \begin{JAVA}[style=code]
enum BNFTerminals implements Terminal {¢¢
  toNone,orNone,go,// No parameters
  start,derive // One parameter
  with, // One parameter, overloaded
  or,and,to, // One parameter (or more), overloaded, variadic
  ;
}\end{JAVA}
  \caption{The verbs of \Self}
  \label{figure:Verbs}
\end{figure}
Each of the enumerands in the figure is destined to be a
  name of a method in a class to be generated by \Self.

Noun definitions are made in the code excerpt in \cref{figure:Nouns}.

\begin{figure}[htb]
  \begin{JAVA}[style=code]
enum BNFVariables implements Variable {¢¢
  BNF, Header, Body, Footer,
  Terminals, Variables, Start,
  Rules,Rule,Conjunctions, Extra_Conjunctions,
  First_Conjunction, Extra_Conjunction, Symbol_Sequence,
  Symbol, Variable, Noun;
}\end{JAVA}
  \caption{The nouns of \Self}
  \label{figure:Nouns}
\end{figure}
  \Self will eventually generate a code with
  a class named after each the enumerands in the figure.

The
enumerations \cc{BNFTerminals} and
  \cc{BNFVariables}
  are now employed in \cref{figure:BNF:fluent}.

\begin{figure}[htb]
  \begin{JAVA}[style=numbered]
new BNF()
  ¢¢.with(BNFTerminals.class)
  ¢¢.with(BNFSymbols.class)
  ¢¢.start(BNF)
  ¢¢.derive(BNF)
    ¢¢.to(Header).and(Body).and(Footer)
  ¢¢.derive(Header)
    ¢¢.to(Variables).and(Terminals)
    ¢¢.or(Terminals).and(Variables)
  ¢¢.derive(Variables)
    ¢¢.to(with, Variable.class)
  ¢¢.derive(Terminals)
    ¢¢.to(with, Terminal.class)
  ¢¢.derive(Body)
    ¢¢.to(Start).and(Rules)
  ¢¢.derive(Start)
    ¢¢.to(start, Variable)
  ¢¢.derive(Rules)
    ¢¢.to(Rule).and(Rules)
    ¢¢.or(Rule)
  ¢¢.derive(Conjunctions)
    ¢¢.to(First_Conjunction).and(Extra_Conjunctions)
  ¢¢.derive(First_Conjunction)
    ¢¢.to(to,Symbol).and(Symbol_Sequence)
    ¢¢.or(toNone)
  ¢¢.derive(Extra_Conjunctions)
    ¢¢.to(Extra_Conjunction).and(Extra_Conjunctions)
    ¢¢.orNone()
  ¢¢.derive(Extra_Conjunction)
    ¢¢.to(or,Symbol).and(Symbol_Sequence)
    ¢¢.orNone()
  ¢¢.derive(Symbol_Sequence)
    ¢¢.toNone()
    ¢¢.or(and, Symbol).and(Symbol_Sequence)
  ¢¢.derive(Symbol)
    ¢¢.to(Verb)
    ¢¢.or(Verb,Noun)
    ¢¢.or(Variable)
  ¢¢.derive(Footer)
    ¢¢.to(go)
¢¢.go();
  \end{JAVA}
  \caption{A BNF grammar for \Self API}
  \label{figure:BNF:fluent}
\end{figure}

The code excerpt in the figure is a rather long
sequence of method calls.
This fluent API sequence is a reflective BNF
of the \Self API;
indeed, we may check that \cref{figure:BNF:fluent} reiterates \cref{figure:BNF:BNF}
(with notational changes as appropriate).

\subsection{Parametrized Verbs}
The granularity of grammars of programming languages typically goes down to the \emph{lexical token} level,
but no deeper.
Such tokens, the building blocks of grammars, come in two flavors:
\begin{itemize}
  \item \emph{Monomorphic tokens} are tokens such as punctuation marks and
        certain keywords such as ‟\kk{if}”, ‟\cc{static}” and ‟\cc{class}”.
        Such tokens carry no information other than their mere presence.
  \item \emph{Polymorphic tokens} are tokens which carry content beyond
        presence (or absence). The prime example of these are identifiers.
\end{itemize}

This distinction applies also to fluent APIs:
Methods, or verbs, are the tokens, and a fluent APIs sequence consists of
method calls that come in two kinds: those that do not take parameters (such as \cc{toNone()} in \cref{figure:BNF:fluent}),
and those that do (such as the call \cc{derives($·$)} in the figure).

\Self supports verbs with, and without, noun parameters.
The following examples,`drawn from \cref{figure:fluent} and \cref{figure:BNF:fluent},
demonstrate,
\begin{JAVA}
  ¢¢.to(male)
  ¢¢.to(with, Terminal.class)
  ¢¢.to(with, Variable.class)
  ¢¢.to(start, Variable)\end{JAVA}
(The above is made possible with minor \Java language trickery,
  involving overloading and use of variadic signatures,
  with respect to function name \cc{to}.
Same trickery was applied to verbs \cc{or}, and \cc{and}.)
