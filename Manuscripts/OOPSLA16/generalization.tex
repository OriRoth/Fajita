%! TEX root = 00.tex
Section: generalization:
    how to generate toilette with DFA\@.
  Generalization to pushdown.
Examples were pushdown automata become essential are: probably stack, scoping
in html, in hint only: nested SQL queries.

  \item
        Library classes such as \cc{String} and \cc{Integer}, just as user-defined
        classes such as \cc{Invoice} may be used as nouns.
        \Fajita generate class definitions only for classes whose name is declared
        in an \kk{enum} which is passed to \cc{with} verb in the BNF declaration.
  \item Verbs may take noun parameters, as explained below.
\end{enumerate}

As should be obvious from \cref{figure:fluent}, \Fajita will be implemented
in a bootstrapping fashion.
The specification of a BNF, is made itself using a fluent API.

This section describes how this is achieved.

\subsection{Reflective BNF}
\cref{figure:BNF:BNF} is a \emph{reflective BNF}:
It uses the notation introduced in \cref{figure:BNF}
to specify this same notation.

\begin{figure}
  \begin{Grammar}
    \begin{aligned}
      \<BNF>                & \Derives \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header>             & \Derives \<Variables> \~\<Terminals> \hfill⏎
      {}                    & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables>          & \Derives \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals>          & \Derives \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body>               & \Derives \<Start> \~\<Rules> \hfill⏎
      \<Start>              & \Derives \cc{start(\<Variable>)} \hfill⏎
      \<Rules>              & \Derives \<Rule> \~\<Rules>\hfill⏎
      {}                    & \| \<Rule> \hfill⏎
      \<Rule>               & \Derives \cc{derives(\<Variable>)} \<Conjunctions>\hfill⏎
      \<Conjunctions>       & \Derives \<First-Conjunction>\~\<Conjunctions>\hfill⏎
      \<First-Conjunction>  & \Derives \cc{to(\<Symbol>)}\~\<Symbols>\hfill⏎
      {}                    & \| \cc{toNone()}\hfill⏎
      \<Conjunctions> & \Derives \<Conjunction>\~\<Conjunctions>\hfill⏎
      {}                    & \| ε\hfill⏎
      \<Conjunction>  & \Derives \cc{or(\<Symbol>)}\~\<Symbols>\hfill⏎
      {}                    & \| \cc{orNone()} \hfill⏎
      \<Symbols>    & \Derives ε \hfill⏎
      {}                    & \| \cc{and(\<Symbol>)}\~\<Symbols> \hfill⏎
      \<Symbol>             & \Derives \cc{Variable} \hfill⏎
      {}                    & \| \<Verb>\hfill⏎
      {}                    & \| \<Verb>\~\cc{,} \<Noun> \hfill⏎
      \<Noun>               & \Derives \<Variable> \hfill⏎
      {}                    & \| \<Existing-Class> \hfill⏎
      \<Variable>           & \Derives \cc{Variable} \hfill⏎
      \<Footer>             & \Derives \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{figure:BNF:BNF}
\end{figure}
% this is not a formal BNF because <Symbol> and <Variable> are not defined in the Symbols set.
\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
Note that this specification can only be approximate;
the figure uses verbs as replacement to indentation,
and special symbols such as~$|$,~$::-$ and~$ε$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{comment}

From \cref{figure:BNF:BNF} we learn
that a BNF has three components: header, body and footer.
\begin{enumerate}
  \item The sets of terminals and variables are defined in the header part.
  \item The body starts with a definition of the start symbol, followed by a list of derivation
        rules.
  \item The footer is simply the verb \cc{go()} which instructs \Fajita
        to generate the code that realizes the fluent API specified by the grammar.
\end{enumerate}

A derivation rule starts with a variable, and is then followed by disjunctive alternatives.

The choice of verbs that may occur in, and between, these alternatives not incidental;
fluency was in mind:
\begin{description}
  \item[\cc{to}] to introduce the first symbol in the first conjunction.
  \item[\cc{or}] to introduce the first symbol in each subsequent conjunction.
  \item[\cc{and}] to introduce all but the first symbol in each such conjunction.
  \item[\cc{toNone}] to declare that the first conjunction is empty.
  \item[\cc{orNone}] to declare any subsequent conjunction is empty.
\end{description}

\subsection{Reflective BNF of fluent API}

To translate \cref{figure:BNF:BNF} into a fluent
API chain, the verbs and nouns must be defined.

Verb definitions are made in the code excerpt in
\cref{figure:Verbs}.

\begin{figure}[htb]
  \javaInput[minipage,width=\linewidth,left=-2ex]{../Fragments/fajita-verbs.fragment}
  \caption{The verbs of \Fajita}
  \label{figure:Verbs}
\end{figure}
Each of the enumerands in the figure is destined to be a
  name of a method in a class to be generated by \Fajita.

Noun definitions are made in the code excerpt in \cref{figure:Nouns}.

\begin{figure}[htb]
  \javaInput[minipage,width=\linewidth,left=-2ex]{../Fragments/fajita-nouns.fragment}
  \caption{The nouns of \Fajita}
  \label{figure:Nouns}
\end{figure}
  \Fajita will eventually generate a code with
  a class named after each the enumerands in the figure.

The enumerations \cc{BNFTerminals} and \cc{BNFVariables}
  are now employed in \cref{figure:BNF:fluent}.

\begin{figure}[htb]
  \javaInput[minipage,width=\linewidth,left=-2ex]{../Fragments/fajita-bootstrap.fragment}
  \caption{A BNF grammar for \Fajita API}
  \label{figure:BNF:fluent}
\end{figure}

The code excerpt in the figure is a rather long
sequence of method calls.
This fluent API sequence is a reflective BNF
of the \Fajita API;
indeed, we may check that \cref{figure:BNF:fluent} reiterates \cref{figure:BNF:BNF}
(with notational changes as appropriate).

\subsection{Parametrized Verbs}
The granularity of grammars of programming languages typically goes down to the \emph{lexical token} level,
but no deeper.
Such tokens, the building blocks of grammars, come in two flavors:
\begin{itemize}
  \item \emph{Monomorphic tokens} are tokens such as punctuation marks and
        certain keywords such as ‟\kk{if}”, ‟\cc{static}” and ‟\cc{class}”.
        Such tokens carry no information other than their mere presence.
  \item \emph{Polymorphic tokens} are tokens which carry content beyond
        presence (or absence). The prime example of these are identifiers.
\end{itemize}

This distinction applies also to fluent APIs:
Methods, or verbs, are the tokens, and a fluent APIs sequence consists of
method calls that come in two kinds: those that do not take parameters (such as \cc{toNone()} in \cref{figure:BNF:fluent}),
and those that do (such as the call \cc{derives($·$)} in the figure).

\Fajita supports verbs with, and without, noun parameters.
The following examples, drawn from \cref{figure:fluent} and \cref{figure:BNF:fluent},
demonstrate,
\begin{quote}
  \parbox[c]{30ex}{\javaInput{../Fragments/fajita-verbs-nouns.fragment}}
\end{quote}
(The above is made possible with minor \Java language trickery,
  involving overloading and use of variadic signatures,
  with respect to function name \cc{to}.
Same trickery was applied to verbs \cc{or}, and \cc{and}.)
