@book{Bauer:2005,
  abstract = {Hibernate practically exploded on the \Java scene. Why is this
    open-source tool so popular? Because it automates a tedious task: persisting
    your \Java objects to a relational database. The inevitable mismatch
    between your object-oriented code and the relational database requires you
    to write code that maps one to the other. This code is often complex,
    tedious and costly to develop. Hibernate does the mapping for you. Not only
    that, Hibernate makes it easy. Positioned as a layer between your
    application and your database, Hibernate takes care of loading and saving
    of objects. Hibernate applications are cheaper, more portable, and more
    resilient to change. And they perform better than anything you are likely
    to develop yourself. "Hibernate in Action" carefully explains the concepts
    you need, then gets you going. It builds on a single example to show you
    how to use Hibernate in practice, how to deal with concurrency and
    transactions, how to efficiently retrieve objects and use caching. The
    authors created Hibernate and they field questions from the Hibernate
    community every day-they know how to make Hibernate sing. Knowledge and
    insight seep out of every pore of this book. "What's Inside" - ORM concepts
    - Getting started - Many real-world tasks - The Hibernate application
  development process},
  author = {Bauer, Christian and King, Gavin},
  isbn = {193239415X},
  publisher = {Manning Publications Co.},
  title = {Hibernate in action},
  year = 2005
}

@misc{Gil:Levy:2016,
  author = {Gil, Josef (Yossi) and Levy, Tomer},
  title = {Formal Language Recognition witw the Java Type Checker},
  howpublished = {\url{http://stlevy.cswp.cs.technion.ac.il/wp-content/uploads/sites/50/2015/12/00.pdf}},
  note = {Accessed on Mar, 2016},
}
@misc{Fowler:2005,
  author = {Fowler, Martin},
  title = {Language Workbenches: The Killer-App for Domain Specific Languages?},
  howpublished = {\url{http://www.martinfowler.com/articles/languageWorkbench.html＃InternalDsl}},
  note = {Accessed on Mar, 2016},
}

@article{Deursen:2000,
  abstract = {We survey the literature available on the topic of domain-specific
    languages as used for the construction and maintenance of software systems.
    We list a selection of 75 key publications in the area, and provide a
    summary for each of the papers. Moreover, we discuss terminology, risks and
    benefits, example domain-specific languages, design methodologies, and
  implementation techniques.},
  author = {Deursen, Arie Van and Klint, Paul and Visser, Joost},
  doi = {10.1145/352029.352035},
  isbn = {0362-1340},
  issn = {03621340},
  journal = {ACM Sigplan Notices},
  number = 6,
  pages = {26--36},
  title = {Domain-specific languages: an annotated bibliography},
  url = {http://portal.acm.org/citation.cfm?doid=352029.352035},
  volume = 35,
  year = 2000
}

@Article{Harter:05,
  author = {Richard Harter},
  title = {A Game Theoretic Approach to the Toilette Seat Problem},
  journal = {The Science Creative Quarterly},
  year = 2005,
  number = 1,
  volume = 1,
  month = May,
}

@article{VanDeursen:Klint:2000,
  author = {Van Deursen, Arie and Klint, Paul and Visser, Joost},
  title = {Domain-specific languages},
  journal = {Centrum voor Wiskunde en Informatika},
  volume = 5,
  pages = 12,
  year = 2000,
  publisher = {Citeseer}
}

@article{Hudak:1997,
  author = {Hudak, Paul},
  title = {Domain-specific languages},
  journal = {Handbook of Programming Languages},
  volume = 3,
  pages = {39--60},
  year = 1997
}

@mastersthesis{Gutterman:2003,
  title={Turing Templates---On \CC Compile Time Power},
  author={Gutterman, Zvi},
  school={Technion---Israel Institute of Technology},
  year=2003
}

@article{Turing:1936,
  title={On computable numbers, with an application to the Entscheidungsproblem},
  author={Turing, Alan Mathison},
  journal={J. of Math},
  volume=58,
  number={345-363},
  pages=5,
  year=1936
}

@incollection{Musser:Stepanov:1989,
  title={Generic programming},
  author={Musser, David R. and Stepanov, Alexander A.},
  booktitle={Symbolic and Algebraic Computation},
  pages={13--25},
  year=1989,
  publisher=SV
}

@incollection{Dehnert:Stepanov:2000,
  title={Fundamentals of generic programming},
  author={Dehnert, James C. and Stepanov, Alexander},
  booktitle={Generic Programming},
  pages={1--11},
  year=2000,
  publisher=SV
}

@incollection{Backhouse:Jansson:1999,
  title={Generic Programming},
  author={Backhouse, Roland and Jansson, Patrik and Jeuring, Johan and Meertens, Lambert},
  booktitle={Advanced Functional Programming},
  pages={28--115},
  year=1999,
  publisher=SV
}

@mastersthesis{Larsen:2012,
  author = {Larsen, Robert},
  school = {University of Oslo},
  title = {Fluenty: A type safe query {API}},
  year = 2012
}

@article{Kabanov:2008,
  abstract = {Projects like jMock and Hibernate Criteria Query introduced
    embedded DSLs into \Java. We describe two case studies in which we develop
    embedded typesafe DSLs for building SQL queries and engineering \Java
    bytecode. We proceed to extract several patterns useful for developing
    typesafe DSLs for arbitrary domains. Unlike most previous \Java DSLs we
    find that mixing the Fluent Interface idiom with static functions, metadata
    and closures provides for a better user experience than pure method
    chaining. We also make very liberal use of the \Java 5 Generics to improve
  the type safety properties of the DSLs.},
  author = {Kabanov, Jevgeni and
    Raudj{\"{a}}rv, Rein},
  doi = {10.1145/1411732.1411758},
  publisher = AW,
  isbn = 9781605582238,
  journal = {Proceedings of the \nth{6} international symposium on Principles and practice of programming in \Java - PPPJ '08},
  keywords = {domain-specific,dsl,java,typesafe},
  title = {Embedded typesafe domain specific languages for {\Java}},
  year = 2008
}

@book{Cocke:1969,
  author = {Cocke, John},
  publisher = {Courant Institute of Mathematical Sciences, New York University},
  title = {Programming Languages and Their Compilers: Preliminary Notes},
  year = 1969
}

@article{Earley:1970,
  abstract = {A parsing algorithm which seems to be the most efficient general
    context-free algorithm known is described. It is similar to both Knuth's
    LR(k) algorithm and the familiar top-down algorithm. It has a time bound
    proportional to n3 (where n is the length of the string being parsed) in
    general; it has an n2 bound for unambiguous grammars; and it runs in
    linear time on a large class of grammars, which seems to include most
    practical context-free programming language grammars. In an empirical
    comparison it appears to be superior to the top-down and bottom-up
  algorithms studied by Griffiths and Petrick.},
  author = {Earley, Jay},
  doi = {10.1145/362007.362035},
  isbn = {0001-0782},
  issn = {00010782},
  journal = jCommunications,
  number = 2,
  pages = {94--102},
  title = {An efficient context-free parsing algorithm},
  volume = 13,
  year = 1970
}

@article{Younger:1967,
  abstract = {A recognition algorithm is exhibited whereby an arbitrary string
    over a given vocabulary can be tested for containment in a given
    context-free language. A special merit of this algorithm is that it is
    completed in a number of steps proportional to the “cube” of the number
    of symbols in the tested string. As a byproduct of the grammatical
    analysis, required by the recognition algorithm, one can obtain, by some
    additional processing not exceeding the “cube” factor of computational
    complexity, a parsing matrix—a complete summary of the grammatical
    structure of the sentence. It is also shown how, by means of a minor
    modification of the recognition algorithm, one can obtain an integer
    representing the ambiguity of the sentence, i.e., the number of distinct
    ways in which that sentence can be generated by the grammar. The
    recognition algorithm is then simulated on a Turing Machine. It is shown
    that this simulation likewise requires a number of steps proportional to
  only the “cube” of the test string length.},
  author = {Younger, Daniel H.},
  doi = {10.1016/S0019-9958(67)80007-X},
  issn = {00199958},
  journal = inf&ctrl,
  number = 2,
  pages = {189--208},
  title = {Recognition and parsing of context-free languages in time {$n^3$}},
  url = {http://www.sciencedirect.com/science/article/pii/S001999586780007X},
  volume = 10,
  year = 1967
}

@article{Courcelle:77,
  author = {Courcelle, Bruno},
  isbn = {90-71301-40-0},
  journal = MST,
  pages = {87--109},
  title = {On Jump-Deterministic Pushdown Automata},
  volume = 11,
  year = 1977
}
@mastersthesis{Papi:08,
  abstract = {This paper introduces the Checker Framework, which supports adding pluggable type systems to the \Java language in a backward-compatible way. A type system designer defines type qualifiers and their semantics, and a compiler plug-in enforces the semantics. Programmers can write the type qualifiers in their programs and use the plug-in to detect or prevent errors. The Checker Framework is useful both to programmers who wish to write error-free code, and to type system designers who wish to evaluate and deploy their type systems. The Checker Framework includes new \Java syntax for expressing type qualifiers; declarative and procedural mechanisms for writing type-checking rules; and support for flow-sensitive local type qualifier inference and for polymorphism over types and qualifiers. The Checker Framework is well-integrated with the \Java language and toolset. We have evaluated the Checker Framework by writing 5 checkers and running them on over 600K lines of existing code. The checkers found real errors, then confirmed the absence of further errors in the fixed code. The case studies also shed light on the type systems themselves.},
  author = {Papi, Matthew M},
  doi = {10.1145/1390630.1390656},
  isbn = {9781605580500},
  keywords = {annotation,bug finding,case study,compiler,flow,igj,immutable,intern,java,javac,javari,nonnull,pluggable type,polymorphism,readonly,sensitivity,type qualifier,type sys},
  pages = 87,
  school = {Massachusetts Institute of Technology},
  title = {Practical pluggable types for {\Java}},
  url = {http://portal.acm.org/citation.cfm?doid=1390630.1390656},
  year = 2008
}
@inproceedings{Bodden:14,
  abstract = {Typestate analyses determine whether a program's use of a given API obeys this API's usage constraints in the sense that the right methods are called on the right objects in the right order. Previously, we and others have described approaches that generate typestate analyses from textual finite-state property definitions written in specialized domain-specific languages. While such an approach is feasible, it requires a heavyweight compiler, hindering an effective integration into the programmer's development environment and thus often also into her software-development practice.  Here we explain the design of a pure-\Java interface facilitating both the definition and evaluation of typestate analyses.  The interface is fluent, a term coined by Eric Evans and Martin Fowler. Fluent interfaces provide the user with the possibility to write method-invocation chains that almost read like natural-language text, in our case allowing for a seemingly declarative style of typestate definitions. In all previously described approaches, however, fluent APIs are used to build configuration objects.  In this work, for the first time we show how to design a fluent API in such a way that it also encapsulates actual computation, not just configuration. We describe an implementation on top of Soot, Heros and Eclipse, which we are currently evaluating together with pilot customers in an industrial context at Fraunhofer SIT.},
  author = {Bodden, Eric},
  booktitle = {Proceedings of the \nth{3} ACM SIGPLAN International Workshop on the State of the Art in \Java Program Analysis - SOAP '14},
  doi = {10.1145/2614628.2614629},
  file = {:home/tomerlevi/Downloads/bodden14ts4j.pdf:pdf},
  isbn = {9781450329194},
  keywords = {dynamic analysis,fluent interfaces,static analysis},
  pages = {1--6},
  title = {{TS4J} : A Fluent Interface for Defining and Computing Typestate Analyses},
  url = {http://dl.acm.org/citation.cfm?doid=2614628.2614629 http://www.bodden.de/pubs/bodden14ts4j.pdf},
  year = 2014
}
