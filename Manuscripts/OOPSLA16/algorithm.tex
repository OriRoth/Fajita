%! TEX root = 00.tex

\subsection{The Realtime LL Parser}
\label{section:realtime}
The \emph{\textbf Realtime \textbf Left-to-right \textbf Leftmost-derivation
Parser} (\RLLp), is a variant of
The adjective realtime is to claim that:
\begin{itemize}
  \item an \RLLp examines its input only after consuming it, and,
  \item an \RLLp conducts at most one (potentially extended) stack operation in
    each step.
\end{itemize}
An extended stack operation is either a~$\Function push(α)$ of a string of
symbols, or a long~$\Function jump(·)$ into the stack position denoted
by its argument, involving an unbounded number of~$\Function pop()$ operation.

The stack symbols of an \RLLp are \emph{items}, where an item is pair of a
grammar rule and a ‟\emph{dot}”, written as \[
  \<A> ::= Y₀…Y_{i-1}·Yᵢ…Yₖ
\]
Formally, the dot is integer, ranging from 0 to the length of the right-hand
side of the rule. But it is better to think of it as a notation for the prefix
of this right-hand side.

An item represents these precise moments in the analysis process of the
input in which:
\begin{itemize}
  \item all symbols included in this prefix have been successfully parsed, and,
  \item all symbols that lie after this prefix, are awaiting their turn
      to be parsed.
\end{itemize}

Items can be thought of as a generalization of the stack symbols of an \LLp
(recall that these are the grammar's terminals and nonterminals). \LLp stack
symbols are markers of the next symbol to be read or parsed. \RLLp stack
symbols store this information as well: The next symbol to be read or parsed,
is simply the symbol that follows that dot. The generalization is in adding to
this symbol the context of containing rule and the point of derivation within
it.

Just like the \LLp, the \RLLp is a stack automaton equipped with a prediction
table, whose next action is a function (realized in the prediction table) of
the next input symbol and the item present at the stack's top.
token without consuming it.

The \RLLp is initialized with the stack containing an item denoting the
degenerate prefix of a rule for deriving the start symbol. In case there are
more than one such rule, the automaton selects the rule dictated by the first
input token. (This rule is uniquely determined since the grammar is LL.)

After this initialization, the \RLLp proceeds following the instructions
in~\cref{algorithm:sll-parser}.

\begin{algorithm}
  \caption{\label{algorithm:sll-parser}
  A high level sketch of the iterative step of an \RLLp
}
  \begin{algorithmic}[1]
    \LET{$[X ::=α·Yβ]$}{\Function pop()}\COMMENT{retrieve parsing state}
    \LET{$t$}{$\Function next()$}\COMMENT{examine input once per iteration}
    \IF[was rule fully parsed]{$|Yβ|=0$}
      \IF{$X$ is not the start symbol}
         \STATE{$\Function jump(t)$}\COMMENT{reduce this, potentially other rules}
         \CONTINUE\COMMENT{restart, popping a new item}
      \FI
      \IF[$X$ must be the start symbol]{$t=\$$}
        \STATE{\textsc{Accept}}\COMMENT{start symbol fully parsed}
      \ELSE[start symbol fully derived, but more input stil]
        \STATE{\textsc{Reject}}\COMMENT{\RLLp halts in error}
      \FI % Not anticipated EOF
    \FI
    \IF[$Y$ is a terminal]{$Y∈Σ$}
      \IF[read terminal is not anticipated~$Y$]{$Y≠t$}
        \STATE{\textsc{Reject}}\COMMENT{\RLLp halts in error}
        \ELSE[anticipated terminal found on input, proceed]
      \STATE{$\Function push(X::=αY·β)$}\COMMENT{push item with dot advanced}
      \CONTINUE\COMMENT{restart, popping this item, and parsing~$β$}
      \FI
    \FI
    \STATE{\textbf{assert}~$Y∈Ξ$}\COMMENT{$Y$ must be a nonterminal}
    \LET{$a$}{$\Function Δ(Y, t)$}\COMMENT{$Δ(Y,t)$ says what to do with~$Y$}
    \IF[input~$t$ was unanticipated]{$a=⊥$}
      \STATE{\textsc{Reject}}\COMMENT{\RLLp halts in error}
    \FI
    \IF[a string of~$ℓ$ items to push]{$a=I₁,…,I_ℓ$}
      \STATE{$\Function push(I₁, …, I_ℓ)$}
      \CONTINUE\COMMENT{restart with a somewhat deeper stack}
    \FI
    \STATE{\textbf{assert}~$a$ must represent a jump} \COMMENT{token~$t$ indicates that~$Y \stackrel*⇒ε$}
    \STATE{$\Function jump(t)$}\COMMENT{reduce this, and potentially other rules}
  \end{algorithmic}
\end{algorithm}

Comparing \cref{algorithm:sll-parser} with the LL-parsing algorithm
(\cref{algorithm:ll-parser}), we see that they both begin with popping a stack
symbol. More similarities are apparent, after observing that the next
symbol to read or parse, denoted~$X$ in \cref{algorithm:ll-parser} is obtained
by extracting the symbol~$Y$ that follows the dot in the item~$X$ in
\cref{algorithm:sll-parser}.

In some ways, our \RLLp emulates an \LLp except that it attaches to each symbol
the rule in which it was found and the location within this rule.
(Thus, a push of single item is equivalent to the loop of push operations in
line 20 in \cref{algorithm:ll-parser}).

Function,~$Δ(·,·)$, the transition function of an \RLLp is also a bit more
general, and may command the algorithm it to push a sequence of stack symbols
(items), or carry out a jump into the stack.

We delay the detail discussion of the concept of (long) jump and its
realization \cref{algorithm:rll-parser} to \cref{section:jump} below.

The section uses the \RLLp described in~\cref{section:sll} to solve
  the problems presented in~\cref{section:intuition} and then
  by modifying the \RLLp a bit more, we fully encode it using \Java Generics.

\subsection{Solving the Substitution Factor \texorpdfstring{$k'>0$}{k'>0}
problem}
In \cref{substitution-factor}~$k'$ was defined and it was shown problematic
when~$k'>0$. The problem relies in the need to perform several substitutions
of the top of the stack with the next rule without consuming the input token.

What we would like to have, is a ‟big” substitution that composes all
consecutive substitutions, i.e., upon seeing the top of the stack and the input
token, the \RLLp in one step will perform all substitutions.

The problem was presented for the \LLp rather then for the \RLLp, but it
exists almost at the same form in the \RLLp. Following is a redefinition
of~$k'$ for the \RLLp.

\begin{Definition}[$k'$ - \RLLp's subtitution factor]
  \label{sll-substitution-factor} Let~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$ be the item at
  the top of the stack and~$t$ be the next input symbol. If~$t∈\Function
  First(Yᵢ…Yₖ)$ then~$k'$ is the number of consecutive substitutions the parser
will perform (replacing the item at the top of the stack with one
of~$\<Y\ensuremath{ᵢ}>$'s rules) until~$t$ will be consumed from the input.
\end{Definition}

An important observation is that when computing~$k'$, the computation does not
use the information \emph{inside} the stack, but only the very top of the
stack. This observation can be made solely because~$t$ is in~$\Function
First(Yᵢ…Yₖ)$ which ensures that~$t$ will be consumed while parsing~$Yᵢ…Yₖ$.
The result of this observation is that for every item, we can compute the
wanted ‟big” substitution statically (without running the \RLLp on any input).

In~\cref{algorithm:sll-closure} the algorithm for computing this ‟closure” of
operations is shown.

\begin{algorithm}
  \caption{\label{algorithm:sll-closure}
    An algorithm for computing~$\Function Closure(i,t)$ the closure
    of operations that will happen upon seeing item~$i$ at the top
    of the \RLLp's stack and terminal~$t∈Σ∪❴\$❵$ at the input string.
    Output is returned in~$S$.
  }
  \begin{algorithmic}
    \STATE{$Yᵢ←\Function afterDot(i)$} \COMMENT{get the symbol after~$i$'s dot}
    \LET{$S$}{[i]} \COMMENT{initialize output stack}
    \WHILE[loop while~$Yᵢ$ is a nonterminal]{$Yᵢ∉Σ$}
      \STATE{$r←δ(Yᵢ,t)$} \COMMENT{next rule to apply}
      \STATE{$\Function print(r)$} \COMMENT{useful for parsing}
      \STATE{$\Function advance(S)$} \COMMENT{advance the TOTS}
      \STATE{$\<B>::=X₀…Xₘ←r$} \COMMENT{break~$r$ into its components}
      \IF[$δ$ returned an~$ε$-rule]{$X₀…Xₘ=ε$}
        \WHILE[pop all parsed rules]{$\Function parsed(\Function peek(S))$}
          \STATE{$\Function pop(S)$}
        \ENDWHILE
      \ELSE[$δ$ returned a non~$ε$-rule]
        \STATE{$\Function push(S,r)$} \COMMENT{we now turn to parse~$r$}
      \FI
      \STATE{$Yᵢ←\Function afterDot(\Function peek(S))$} \COMMENT{prepare for next iteration}
    \ENDWHILE
    \STATE{$\Function advance(S)$} \COMMENT{advance the TOTS}
  \end{algorithmic}
  \vspace{0.3ex}
  \hrule
  \vspace{0.3ex}
  \scriptsize
  \begin{enumerate}
    \item function~$\Function afterDot(·)$ receives an item as input
      and return the symbol after the ‟$·$” of the item.
      The algorithm ensures that for every invocation of~$\Function afterDot(·)$
      the input rule has at least one symbol after its ‟$·$”
    \item function~$\Function advance(S)$ pops an item from the top of
      the stack~$S$ whose~‟$·$” is at index~$i$ and pushes
      the following item - with index~$i+1$.
      Again, the algorithm ensures~$i$ is not the end of the rule.
    \item function~$\Function parsed(i)$ receives an item as input
      and returns whether its ‟$·$” is at the end of rule,
      i.e., the rule is fully parsed.
  \end{enumerate}

\end{algorithm}

The algorithm takes as input an item and an input terminal
  and computes the list of items that the \RLLp will push until
  the input terminal will be consumed.
The algorithm also prints a list of applied reductions ;
  this list can be used to build a parse tree without additional
  computation at runtime.

The computation process is rather simple:
given an item~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$
†{in case there's a terminal at the top of the stack~$k'=0$
and there are no substitutions}
and the next input symbol~$t∈Σ∪❴\$❵$, the algorithm iteratively
applies the rules for substitution, while keeping a list
of all substitutions on the way, the output of the algorithm
is the list of substitutions for each nonterminal% NOT FINISHED WRITING HERE

The algorithm applies the following inductive step:
use~$r = \Function predict(A,t)$ to predict the next rule as the LL(1)
parser would ; add the RHS of~$r$ to the beginning of the result.
If the first symbol of the result is~$t$, finish.
Otherwise, it is a nonterminal. Let set~$A$ to be that nonterminal, and
apply the inductive step again.
The full algorithm is given in~\cref{algorithm:sll-closure}.

\subsection{Main Algorithm}

\begin{algorithm}
  \begin{algorithmic}
    \caption{\label{algorithm:construction-delta}
      Algorithm for construction of~$Δ$.
      For each item and terminal it computes the required operation.
    }
    \FOR[for each item]{$i∈ \Function Items()$}
    \STATE{$[\<A>::=Y₀…Y_{i-1}…Yᵢ…Yₘ]←i$} \COMMENT{break~$i$}
      \IF[$Δ$ doesn't handle terminals]{$Yᵢ∈Σ$}
        \CONTINUE \COMMENT{handle next item.}
      \FI
      \FOR[calculate entry~$\Function Δ(i,t)$]{$t∈Σ$}
        \IF[$t$ is consumed while parsing~$i$]{$t∈\Function First(Yᵢ…Yₘ)$}
          \LET{$l$}{$\Function Closure(i,t)$} \COMMENT{use closure table}
          \STATE{$\Function Δ(i,t)= \Function Push(l)$} \COMMENT{a push operation}
          \ELSIF[$t$ is consumed after parsing~$i$]{$t∈\Function Follow(\<A>)$}
          \STATE{$\Function Δ(i,t)= \Function Jump(t)$} \COMMENT{a jump operation}
        \FI
      \ENDFOR
    \ENDFOR
  \end{algorithmic}
\end{algorithm}

\subsection{The Long Jumps Data Structure}
\label{section:jump}

It is easier to describe the ds in terms of data abstraction. Later on we will
worry about the implementation.

Think of a stack~$S₀$ implemented as a linked list of items. Then, the top item
of the stack is represented by a single pointer, which can be used for pushing
or popping from the list. The top pointer can also be used for pushing into the
stack a string of items.

Storing pointers into deeper designated items in the stack makes it possible to
make a direct jump into these items. Let~$J$ be the type of these ‟jump”
pointers. Let~$T$ be the type these tokens.

Let us now build on top of~$S₀$ a second stack~$S₁$, \[
  D =ζₙ ⋯ζ₁ \$
\]
where~$ζᵢ$ is a partial map of the type~$T↛J$. A query~$\Function get(t)$ for
some token~$t∈T$ retrieves its value from the top most~$ζᵢ$ which contains
it~$t$, and returns~$⊥$ if no such~$ζᵢ$ exists.

There is an efficient implementation of~$S₁$ in which~$\Function get(t)$
is~$O(1)$ time, regardless of the depth at which~$t$ is found in~$S₁$,, while
keeping updates of the form~$\Function push(ζ)$ or~$ζ←\Function pop()$
in~$O(|ζ|)$ time.

In fact, since~$S₁$ has the same semantics of the stack of symbol tables of a
language with dynamic scoping (such as \TeX), the same trick~\cite{see if y ou
an can find c knuth mnnetions this} can be applied:
\begin{quote}
Maintain a hash table which maps keys of the~$T$ to \emph{stacks} of values of
type~$J$. Let~$s(t)$ be the stack associated by this hash table with key~$t$.
Then, a search for a key~$t$ returns the value at the top of the stack that
the hash table associates with~$t$.

The call~$\Funtion push(ζ)$,~$ζ=❴(t₁,p₁),…,(tₘ,pₘ)❵$,~$|ζ|=m$ iterates over
the~$m$ pairs~$(tᵢ, pᵢ)$,~$i=1,…,m$, pushing~$pᵢ$ to stack~$s(tᵢ)$.
The call~$\Funtion push(ζ)$ terminates by pushing~$ζ$ itself (say as linked list),
into an auxiliary stack. When~$S₁$ pops a map~$ζ$, just before returning it,
it pops stack~$s(t)$ for all~$t∈ζ$
\end{quote}
