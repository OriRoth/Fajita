%! TEX root = 00.tex

The section uses the SLL described in~\cref{section:sll} to solve
  the problems presented in~\cref{section:intuition} and then
  by modifying the SLL a bit more, we fully encode it using \Java Generics.

\subsection{Solving the Substitution Factor \texorpdfstring{$k'>0$}{k'>0}
problem} In \cref{substitution-factor}~$k'$ was defined and it was shown
problematic when~$k'>0$.  The problem relies in the need to perform several
substitutions of the top of the stack with the next rule without consuming the
input token.

What we would like to have, is a ‟big” substitution that composes all
consecutive substitutions, i.e., upon seeing the top of the stack and the input
token, the SLL in one step will perform all substitutions.

The problem was presented for the LL parser rather then for the SLL, but it
exists almost at the same form in the SLL\@.  Following is a redefinition
of~$k'$ for the SLL\@.

\begin{Definition}[$k'$ - SLL's subtitution factor]
  \label{sll-substitution-factor} Let~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$ be the item at
  the top of the stack and~$t$ be the next input symbol.  If~$t∈\Function
  First(Yᵢ…Yₖ)$ then~$k'$ is the number of consecutive substitutions the parser
will perform (replacing the item at the top of the stack with one
of~$\<Y\ensuremath{ᵢ}>$'s rules) until~$t$ will be consumed from the input.
\end{Definition}

An important observation is that when computing~$k'$, the computation does not
use the information \emph{inside} the stack, but only the very top of the
stack.  This observation can be made solely because~$t$ is in~$\Function
First(Yᵢ…Yₖ)$ which ensures that~$t$ will be consumed while parsing~$Yᵢ…Yₖ$.
The result of this observation is that for every item, we can compute the
wanted ‟big” substitution statically (without running the SLL on any input).

In~\cref{algorithm:sll-closure} the algorithm for computing this ‟closure” of
operations is shown.

\begin{algorithm}[p]
  \caption{\label{algorithm:sll-closure}
    An algorithm for computing~$\Function Closure(i,t)$ the closure
    of operations that will happen upon seeing item~$i$ at the top
    of the SLL's stack and terminal~$t∈Σ∪❴\$❵$ at the input string.
    Output is returned in~$S$.
  }
  \begin{algorithmic}
    \STATE{$Yᵢ←\Function afterDot(i)$} \COMMENT{get the symbol after~$i$'s dot}
    \LET{$S$}{[i]} \COMMENT{initialize output stack}
    \WHILE[loop while~$Yᵢ$ is a nonterminal]{$Yᵢ∉Σ$}
      \STATE{$r←δ(Yᵢ,t)$} \COMMENT{next rule to apply}
      \STATE{$\Function print(r)$} \COMMENT{useful for parsing}
      \STATE{$\Function advance(S)$} \COMMENT{advance the TOTS}
      \STATE{$\<B>::=X₀…Xₘ←r$} \COMMENT{break~$i$ into its components}
      \IF[$δ$ returned an~$ε$-rule]{$X₀…Xₘ=ε$}
        \WHILE[pop all parsed rules]{$\Function parsed(\Function peek(S))$}
          \STATE{$\Function pop(S)$}
        \ENDWHILE
      \ELSE[$δ$ returned a non~$ε$-rule]
        \STATE{$\Function push(S,r)$} \COMMENT{we now turn to parse~$r$}
      \FI
      \STATE{$Yᵢ←\Function afterDot(\Function peek(S))$} \COMMENT{prepare for next iteration}
    \ENDWHILE
    \STATE{$\Function advance(S)$} \COMMENT{advance the TOTS}
  \end{algorithmic}
  \vspace{0.3ex}
  \hrule
  \vspace{0.3ex}
  \scriptsize
  \begin{enumerate}
    \item function~$\Function afterDot(·)$ receives an item as input
      and return the symbol after the ‟$·$” of the item.
      The algorithm ensures that for every invocation of~$\Function afterDot(·)$
      the input rule has at least one symbol after its ‟$·$”
    \item function~$\Function advance(S)$ pops an item from the top of
      the stack~$S$ whose~‟$·$” is at index~$i$ and pushes the
      the following item - with index~$i+1$.
      Again, the algorithm ensures~$i$ is not the end of the rule.
    \item function~$\Function parsed(i)$ receives an item as input
      and returns whether its ``$\cdot$'' is at the end of rule,
      i.e., the rule is fully parsed.
  \end{enumerate}

\end{algorithm}

The algorithm takes as input an item and an input terminal
  and computes the list of items that the SLL will push until
  the input terminal will be consumed.
The algorithm also prints a list of applied reductions ;
  this list can be used to build a parse tree without additional
  computation at runtime.

The computation process is rather simple:
given an item~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$
†{in case there's a terminal at the top of the stack~$k'=0$
and there are no substitutions}
and the next input symbol~$t∈Σ∪❴\$❵$, the algorithm iteratively
applies the rules for substitution, while keeping a list
of all substitutions on the way, the output of the algorithm
is the list of substitutions for each nonterminal% NOT FINISHED WRITING HERE

The algorithm applies the following inductive step:
use~$r = \Function predict(A,t)$ to predict the next rule as the LL(1)
parser would ; add the RHS of~$r$ to the beginning of the result.
If the first symbol of the result is~$t$, finish.
Otherwise, it is a nonterminal. Let set~$A$ to be that nonterminal, and
apply the inductive step again.
The full algorithm is given in~\cref{algorithm:sll-closure}.

\endinput
\subsection{Solving~$k^*$}

\subsection{Main Algorithm}

The idea of the main is simple
