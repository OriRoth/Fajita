%! TEX root = 00.tex

\subsection{Solving~$k'$ using closure}

The section uses the SLL described in~\cref{section:simplified} to solve
  the problems presented in~\cref{section:intuition} and then to
  implement a full encoding of the SLL using \Java Generics.

\subsection{Substitution Factor~$k'$}
The problem defined in~\cref{substitution:factor} if~$k'>0$ is that
the recognizer needs to perform several substitutions of the top of
the stack with the next rule to parse without consuming the input token.

What we would like to have, is a ‟big” substitution that composes
all consecutive substitutions.

The problem was presented for the LL parser rather then for the SLL,
  but it exists almost at the same form in the SLL\@.
Following is a redefinition of~$k'$ for the SLL\@.

\begin{Definition}[$k'$ - SLL's subtitution factor]
  \label{sll-substitution-factor}
  Let~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$ be the item at the top of the stack
    and~$t$ be the next input symbol.
  If~$t∈\Function First(\<A>)$ then~$k'$ is the number of consecutive
    substitutions the parser will perform (replacing the item at
    the top of the stack with one of~$\<Y\ensuremath{ᵢ}>$'s rules)
  until~$t$ will be consumed from the input.
\end{Definition}

An important observation is that when computing~$k'$, the
  computation does not use the information \emph{inside} the stack,
  but only the very top of the stack.
This observation can be made solely because~$t$ is
  in~$\Function First(\<A>)$ which ensures that~$t$ will be consumed
  while parsing~$\<A>$.
The result of this observation is that for every item, we can
  compute the wanted ‟big” substitution statically
  (without running the SLL on any input).

In~\cref{algorithm:sll-closure} the algorithm for computing
  this ‟closure” of operations is shown.

\begin{algorithm}[p]
  \caption{\label{algorithm:sll-closure}
    An algorithm for computing~$\Function Closure(i,b)$ the closure
    of operations that will happen upon seeing item~$i$ at the top
    of the SLL's stack and terminal~$t∈Σ∪❴\$❵$ at the input string.
  }
  \begin{algorithmic}
    \STATE{$(A::=Y₀…Yₖ)←r$} \COMMENT{break~$r$ into its LHS ＆ RHS}
    \IF[$r$ cannot be derived to begin with~$b$]{$b∉\Function First(Y₀…Yₖ)$}
      \STATE{\textsc{Error}}
    \FI
    \STATE{$\text{LHS}=A$} \COMMENT{the output rule shares the LHS with the input}
    \STATE{$\text{RHS}=Y₀…Yₖ$} \COMMENT{initially, the RHS is the original rule}
    \LET{$h$}{$\Function PopHead(\text{RHS})$} \COMMENT{unroll the first symbol in RHS}
    \WHILE[$h$ is always a nonterminal in the loop]{$h∉Σ$}
      \FOR[for each~$h$-rule]{$h::=Y₀'…Yₖ'←get(P)$}
        \IF[if this rule matches]{$b∈\Function First(Y₀'…Yₖ')$}
          \STATE{$\text{RHS}=Y₀'…Yₖ' + \text{RHS}$} \COMMENT{add it to closure}
          \BREAK \COMMENT{since were in LL(1), can't be other}
        \ENDIF
      \ENDFOR
      \STATE{$h←\Function PopHead(\text{RHS})$} \COMMENT{unroll the first symbol in RHS}
    \ENDWHILE
    \RETURN{$\text{LHS}::=\text{RHS}$}
  \end{algorithmic}
\end{algorithm}

The computation process is rather simple:
given an item~$\<A>::=Y₀…Y_{i-1}·Yᵢ…Yₖ$
†{in case there's a terminal at the top of the stack~$k'=0$
and there are no substitutions}
and the next input symbol~$t∈Σ∪❴\$❵$, the algorithm iteratively
applies the rules for substitution, while keeping a list
of all substitutions on the way, the output of the algorithm
is the list of substitutions for each nonterminal% NOT FINISHED WRITING HERE

The algorithm applies the following inductive step:
use~$r = \Function predict(A,t)$ to predict the next rule as the LL(1)
parser would ; add the RHS of~$r$ to the beginning of the result.
If the first symbol of the result is~$t$, finish.
Otherwise, it is a nonterminal. Let set~$A$ to be that nonterminal, and
apply the inductive step again.
The full algorithm is given in~\cref{algorithm:llclosure}.

\endinput
\subsection{Solving~$k^*$}

\subsection{Main Algorithm}

The idea of the main is simple
