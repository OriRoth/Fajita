% Why can't we encode it as a normal DPDA?
The implementation of the LL parser as recoginer without using
  a jump-stack is problematic since LL grammars allow~$\epsilon$-rules.
During the processing of the~$\epsilon$-rule, the parser pops the 
  left-hand side of the rule and continues to process the penulitimate
  stack element.
It is possible to have multiple~$\epsilon$ rules processed sequencially,
  that leads to the \textit{realtime} problem - we can only encode
  automata that do constant amount of computation on each input character
  process.

%How does the LL parser work?
During normal LL parsing, the configuration of the parser consists
  of three elements:
\begin{Itemize}
  \item the current state of the parsing - which is the
    rule being currently processed and the part of the rule we
    haven't parsed yet.
  \item the environment, or the parsing information we got so far -
    which is the rest of the stack
  \item the rest of the input string
\end{Itemize}


% How can we encode it?
The corresponding \Java fluent API ought to have equivalent features.
The input string - since we transform each
  token to a method invocation, it is clear that the rest of the input is
  simply the rest of the method chain.
The current state of the parsing is transformed into a \Java type
  (\kk{class} or \kk{interface}) ; this way we can control for each state
  which operation can be made by determining the method of that type.
The environment is realized by type arguments of the states' \Java types.

Using these transformers, we can describe a state of the parser,
  with different stacks using a single type.
This is of course necessary in order to describe all posible configurations
  in a finite number of \Java types.

\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<BNF>                     & ::= \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header>                  & ::= \<Variables> \~\<Terminals> \hfill⏎
      {}                         & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables>               & ::= \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals>               & ::= \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body>                    & ::= \<Start> \~\<Rules> \hfill⏎
      \<Start>                   & ::= \cc{start(\<Variable>)} \hfill⏎
      \<Rules>                   & ::= \<Rule> \~\<Rules>\hfill⏎
      {}                         & \| \<Rule> \hfill⏎
      \<Rule>                    & ::= \cc{derives(\<Variable>)} \<Conjunctions>\hfill⏎
      \<Conjunctions>            & ::= \<First-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      \<First-Conjunction>       & ::= \cc{to(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                         & \| \cc{toNone()}\hfill⏎
      \<Extra-Conjunctions> & ::= \<Extra-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      {}                         & \| ε\hfill⏎
      \<Extra-Conjunction>  & ::= \cc{or(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                         & \| \cc{orNone()} \hfill⏎
      \<Symbol-Sequence>         & ::= ε \hfill⏎
      {}                         & \| \cc{and(\<Symbol>)}\~\<Symbol-Sequence> \hfill⏎
      \<Symbol>                  & ::= \cc{Variable} \hfill⏎
      {}                         & \| \<Verb>\hfill⏎
      {}                         & \| \<Verb> \cc{,} \<Noun> \hfill⏎
      \<Noun>                    & ::= \<Variable> \hfill⏎
      {}                         & \| \<Existing-Class> \hfill⏎
      \<Variable>                & ::= \cc{Variable} \hfill⏎
      \<Footer>                  & ::= \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{Figure:BNF:BNF}
\end{figure}

%
\subsection{LL states}
A state during the parser's computation is a grammar rule~$r = A→αβ$, and an
index in it, i.e.,~$A→α·β$.
It means that the parser is currently processing rule~$r$, it already realized parsed string~$alpha$
  from the input, and it expect to parse the string~$β$ next.
The number of states then, produced by \Fajita for a grammar is linear in the grammar size.

\subsection{Environment}



\renewcommand{\LET}[2]{\STATE{\textbf{Let} \ensuremath{\text{#1}←\text{#2}}}}
\newcommand\INPUT\REQUIRE
\newcommand\OUTPUT\ENSURE
\def\function#1(#2){\ensuremath{\textrm{\textup{\textsf{#1}}}(#2)}}
\def\table#1[#2]{\ensuremath{\textsf{#1}[#2]}}

\begin{algorithm}[p]
  \caption{\label{Algorithm:LLClosure}
  Function~$\function Closure(A,b)$: generates a closure of action from the original LL algorithm}
  \begin{algorithmic}
    \INPUT{a nonterminal~$A$}
    \INPUT{a terminal~$b$}
    \OUTPUT{the closure of consecutive actions}
    \LET{$l$}{$[]$}
    \LET{$X$}{$A$}
    \IF{$∀X→α . b∉\function First(α)$}
      \RETURN{\textrm{reject}}
    \ENDIF
    \WHILE{$\textrm{True}$}
      \IF{$X∈Ξ$}
        \STATE{let~$Y₁ Y₂… Yₖ$ be~$α$ s.t.~$∃X→α∈G∧b∈\function First(α)$}
        \STATE{$\function append(l,Yₖ,Y_{k-1},…,Y₂)$}
        \STATE{$X=Y₁$}
      \ELSE[$X$ must be~$b$]
        \STATE{\textbf{break}}
      \ENDIF
    \ENDWHILE
    \RETURN{$l$}
  \end{algorithmic}
\end{algorithm}

\endinput

\begin{Definition}[JETEM]
  JETEM is a variant of pushdown automata that maintains two
    stacks:
    \begin{description}
      \item[Call stack]
      \item[Epsilon stack]
    \end{description}
    At each step of the automaton, it reads a single character,
      and determines based on the character and the current top of the call stack, what to do:
    \begin{description}
      \item[Epsilon] if character is not in first, but is in follow
      \item[Call] if character is in first but not in follow
      \item[Reject] if character is not in first nor in follow
      \item[Accept] when input exhausted.
    \end{description}

  \begin{enumerate}
      \item

\end{Definition}
