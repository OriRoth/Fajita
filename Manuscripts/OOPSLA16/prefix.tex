\begin{theorem}\label{Theorem:Gil-Levy:2}
  Let~$A$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_A$ for types~\cc{L},~\cc{A} and
    other types such that the \Java command
  \begin{equation}
    \label{Equation:result}
    \cc{A.build~$\textsf{java}(α)$;}
  \end{equation}
  type checks against~$J_A$ if an only if there exists~$β∈Σ^*$ such
  that~$αβ∈L$.
  Furthermore, program~$J_A$ can be effectively generated from~$A$.
\end{theorem}

Informally, a call chain type-checks if and only if it is a prefix
  of some legal sequence.
Alternatively, a call chain won't type-check if there is no
  continuation that leads to a legal string in~$L$.

The proof resembles~\cref{Theorem:Gil-Levy}'s proof.
We provide a similar implementation for a jump-stack (see \cref{Definition:JDPDA}),
  that will not compile under illegal prefixes.

The main difference between the two theorems is:
  in~\cref{Theorem:Gil-Levy} we allowed illegal call chains to compile,
  but not return the required~\cc{L} type, while in~\cref{Theorem:Gil-Levy:2}
  the illegal chain won't compile at all.
  
Since the code suggested by the proof highly resembles the previously
  suggested code, we will describe the differences.
  
We will use the same running example, defined by~\cref{Table:A}.

\subsection{Main Types}
The main types here are a subset of the previously defined main types.

\begin{quote}
  \javaInput[left=-2ex,minipage,width=54ex]{prefix-proof.configuration.listing}
\end{quote}

First, type \cc{$\Sigma\Sigma$} is removed. 
A call chain that doesn't represent a valid prefix won't compile, 
  thus, there is no need for an error return type such as \cc{$\Sigma\Sigma$}.
Second, \kk{interface} \cc{C} is removed. 
Without it, the configuration types won't have the 
  methods \cc{$σ$1()}, … ,\cc{$σ${}$k$()} and \cc{\$()} from the supertype.
These inherited methods, is what differentiates the previous proof from the current.

\subsection{Top-of-Stack Types}
Types \cc{C$γ$1}, … ,\cc{C$γ${}$k$}, still represent stacks
  with \cc{$γ$1}, … ,\cc{$γ${}$k$} as their top,
  this time, the methods are defined ad-hock, in each type.
In A there are two such types:

\begin{quote}
  \javaInput[left=-2ex,minipage,width=45ex]{prefix-proof.many.listing}
\end{quote}

Note, that the type parameters of the former types hasn't changed,
  since the model we are trying to implement, hasn't changed.
  These~$k+1$ parameters still suffice for our cause.

\begin{wrapfigure}[14]r{45ex}
  \caption{\label{Figure:prefix-chain} Accepting and non-accepting call chains with the
  type encoding of jDPDA~$A$ (as defined in \cref{Table:A}), such that 
  illegal prefixes won't compile}
  \javaInput[left=-2ex,minipage,width=45ex]{prefix-proof.cases.listing}
\end{wrapfigure}

In~\cref{Figure:prefix-chain}, call chains in the~\cc{accepts()} method 
  correctly type-checks (i.e., in $L$), while the chains in~\cc{rejects()} 
  do not type-check (i.e., these prefixes has no continuation that leads to a legal word in $L$), 
  where the last method invocation generates an \textsf{the method ... is undefined for the type ...}
  error message.
Note the major difference from~\cref{Theorem:Gil-Levy} ; there is no need to
  use an auxiliary function \cc{isL()} as in~\cref{Figure:chain} since now illegal
  prefixes does not type-check.
  
\subsection{Transitions}
The transition table is encoded slightly different due to the changes we expressed.
The new encoding is as follows:
\begin{description}
 \item[\textsf{reject}] Since we add the methods ad-hock to each type, the reject entry means 
   that the corresponding type, won't have a~\cc{\$()} method, i.e., type~\cc{C$\gamma$1}
   doesn't have a method~\cc{\$()}.
 \item[\textsf{accept] The corresponding type, will have a~\cc{\$()} method with return type~\cc{L}
 \item[$\bot$] We encounter $\bot$ on the transition function when some input character~\cc{$\sigma$} 
   is not allowed for the top of the stack element $\gamma$. In that case, the corresponding type \cc{C$\gamma$} 
   must not have a method for~\cc{$\sigma$}, this way, invoking the methods will cause type error.
   In \cref{Table:A} $\bot$ occurs when the top of the stack is $\gamma{}2$ and the input character is $\sigma{}1$,
   thus, no method \cc{$\sigma$1} is introduced in type~\cc{C$\gamma{}$2}.
 \item[$\textsf{jump}(γᵢ)$]
  
\end{description}