%! TEX root = 00.tex
The section makes the first step of our construction: Presenting the \emph{SLL}
parser, a variant of the traditional LL parser (add reference to
\figuessoandso), but more economic in its use of the stack resource, and
perhaps of independent value.

Recall that The stack symbols of the LL parser of a given grammar are the union
of this grammar's terminals and nonterminals. In contrast, the stack symbols of
the SLL-parser are \emph{items}. An item is pair of a grammar rule and a
``\emph{dot}''. And, the dot is integer, ranging from 0 to the length of the
right hand side of the rule. 

Think of the dot as a notation for the prefix of a rule. With this perspective,
an item represents these precise moments in the input analysis process the
input in which: 
\begin{itemize}
  \item all symbols included in this prefix have been successfully parsed, and,
  \item all symbols that lie after this prefix, are awaiting to their turn
      to be parsed.
\end{itemize}

Just as the LL-parser, the SLL parser is a stack automaton equipped with a
prediction table, whose next action is a function (realized in the prediction
table) of the next input symbol and the top of the stack. This action may
involve consuming the input token and conducting push or pop operations on the
stack. Later, we show how this feature \whichexactly can revoked.

The SLL parser is initialized with the  tack containing start symbol's rule†{
  \ididnotquitegetthis
  Of course, the grammar's start symbol might have more than one rule,
  but since the grammar is LL, each rule has a
  distinct~$\Function First(·)$ set, thus by peeking into the
first input symbol we can choose a start rule.}
with a dot before the first symbol, and perform in loop the
step depicted
in~\cref{algorithm:sll-parser}.

\begin{algorithm}[p]
  \caption{\label{algorithm:sll-parser}
  SLL's parsing algorithm step}
  \begin{algorithmic}
    \LET{$X ::=α·Yβ$}{\Function pop()}\COMMENT{what's the anticipated input?}
    \IF[if rule is already parsed]{$|Yβ|=0$}
    \IF{$X$ is a start symbol}
    \IF[not the anticipated end-of-input]{$\$≠\Function next()$}
    \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
    \ELSE
    \STATE{\textsc{Accept}}\COMMENT{all input successfully consumed}
    \FI % Not anticipated EOF
    \FI % Start symbol
    \CONTINUE\COMMENT{restart, popping a new rule etc.}
    \FI
    \STATE{$\Function push(X::=αY·β)$}\COMMENT{push following item}
    \IF[$Y$ is a terminal]{$Y∈Σ$}
    \IF[read terminal is not anticipated~$Y$]{$Y≠\Function next()$}
    \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
    \ELSE[read terminal is the anticipated~$Y$]
    \CONTINUE\COMMENT{restart, popping a new~$X::=…$, etc.}
    \FI
    \ELSE[$Y$ must be a nonterminal]
    \LET{$R$}{$\Function δ(Y, \Function peek())$}\COMMENT{which rule to reduce?}
    \IF[no rule found]{$R=⊥$}
    \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
    \ELSE[A rule was found]
    \LET{$(Z ::= Y₁,…,Yₖ)$}{R}\COMMENT{break~$R$ into left/right}
    \STATE{$\Function print(R)$}\COMMENT{rule~$R$ has just been applied}
    \STATE{$\Function push(Z ::=·Y₁,…,Yₖ)$}\COMMENT{push the next rule}
    \CONTINUE\COMMENT{restart, popping a new rule etc.}
    \FI % No rule found
    \FI % Y is a terminal or a nonterminal
  \end{algorithmic}
\end{algorithm}

The parsing step of the SLL always begins with popping a rule
from the stack.
Upon popping the rule
\[
  \<A> ::= Y₀…Y_{i-1}·Yᵢ…Yₖ
\]
the SLL operates as follows:
\begin{enumerate}
  \item If~$\<A>$ is a start symbol, and~$i-1=k$ (i.e., it was fully parsed)
        then the SLL expects the end-of-input symbol~$\$$ at the input
        string ; matching it will cause the SLL to accept, and failing
        to match it will cause rejection.
  \item If~$i-1=k$ but~$\<A>$ is not the start symbol, the rule is
        simply popped (as it was fully parsed).
  \item
        If~$Yᵢ∈Σ$ then like the LL parser, the SLL tries to match
        it with the next terminal from the input string.
        Matching will advance the rule by one step, i.e.,
        push~$\<A> ::= Y₀…Yᵢ·Y_{i+1}…Yₖ$, while failing to match
        causes the SLL to reject.
  \item
        The last case is that~$\<Y\ensuremath{ᵢ}>∈Ξ$.
        In this case, as in LL parsing, we look for the right
        derivation of~$\<Y\ensuremath{ᵢ}>$, using the prediction table.
        If the table returned a rule~$\<Y\ensuremath{ᵢ}> ::= Y₀'…Yₘ'$,
        the SLL will push~$\<Y\ensuremath{ᵢ}> ::=·Y₀'…Yₘ'$.
        Failing to find such rule causes rejection.
\end{enumerate}
The simplified LL parser (SLL) is an LL parser with a ‟higher”
perspective.
