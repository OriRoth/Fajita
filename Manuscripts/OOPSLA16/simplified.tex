%! TEX root = 00.tex

Advancing toward the algorithm, we now present a somewhat simplified
  version of the LL(1) parsing algorithm, that will help us encode it
  using \Java Generics, but will not weaken the model.

The simplified LL parser (SLL) is a LL parser with a ‟higher”
  perspective.
While the LL's stack symbols are the terminals and
  nonterminals of the grammar, the SLL's symbols are the grammar's
  rules.

As the LL parser, the SLL is consisted of a stack automaton,
  a prediction table and an input string.
The SLL makes it's decision based on the next input symbol and
  symbol at the top of the stack.
It may also decide whether to consume the input token (a feature that
  will be later revoked).

The SLL's stack symbols are grammar rules with an index, indicating
  what is the prefix of the rule that have already been parsed and
  what is the suffix that still needs to be parsed.
The SLL's stack symbols are similar to the famous LR items,
  both in notation and meaning.
For example, if the SLL currently parses the rule~$\<A> ::=αβ$,
  when~$α$ was already parsed, then the top of the stack symbol
  will be denoted by~$\<A> ::=α·β$.

The SLL begins by pushing the grammar's start symbol's rule with a
  dot before the first symbol, and perform in loop the step depicted
  in~\cref{algorithm:sll-parser}.

\begin{algorithm}[p]
  \caption{\label{algorithm:sll-parser}
  SLL's parsing algorithm step}
  \begin{algorithmic}
    \LET{$X ::=α·Yβ$}{\Function pop()}\COMMENT{what's the anticipated input?}
    \IF[rule is parsed]{$|Yβ|=0$}
      \IF{$X ::=αYβ$ is a start rule}
        \IF[not the anticipated end-of-input]{$\$≠\Function next()$}
          \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
        \ELSE
          \STATE{\textsc{Accept}}\COMMENT{all input successfully consumed}
        \FI
      \FI
      \CONTINUE 
    \FI 
    \STATE{$\Function push(X::=αY·β)$}\COMMENT{push next}
    % STOPPED HEREEEEEEEEEEEEEEEEEEEEEEEEE

    %\IF[ancipated~$Y$ is a terminal]{$Y∈Σ$}
      %\IF[read terminal is not anticipated~$Y$]{$Y≠\Function next()$}
        %\STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
      %\ELSE[read terminal is the anticipated~$Y$]
        %\STATE{\textsc{Continue}}\COMMENT{next step}
      %\FI
    %\ELSIF[anticipating end-of-input]{$X=\$$}
      %\IF[not the anticipated end-of-input]{$\$≠\Function next()$}
        %\STATE{\textsc{Reject}}\COMMENT{automaton halts in error}
      %\ELSE[terminal just read was the anticipated~$X$]
        %\STATE{\textsc{Accept}}\COMMENT{all input successfully consumed}
      %\FI
    %\ELSE[anticipated terminal~$X$ must be a nonterminal]
      %\LET{$R$}{$\Function δ(X, \Function peek())$}\COMMENT{which rule to reduce?}
      %\IF[no rule found]{$R=⊥$}
        %\STATE{\textsc{Reject}}\COMMENT{automaton halts in error}
      %\ELSE[A rule was found]
        %\LET{$(Z ::= Y₁,…,Yₖ)$}{R}\COMMENT{break~$R$ into left/right}
        %\STATE{\textbf{assert}~$Z=X$}\COMMENT{$δ$ constructed to return valid~$R$ only}
        %\STATE{$\Function print(R)$}\COMMENT{rule~$R$ has just been applied}
        %\STATE{\textbf{For}~$i=k,…,1$,~$\Function push(Yᵢ)$}\COMMENT{push in reverse order}
        %\STATE{\textsc{Continue}}\COMMENT{restart, popping a new~$X$, etc.}
      %\FI % No rule found
    %\FI % Main
\end{algorithmic}
\end{algorithm}
