%! TEX root = 00.tex

Advancing toward the algorithm, we now present a somewhat simplified
  version of the LL(1) parsing algorithm, that will help us encode it
  using \Java Generics, but will not weaken the computational model.

The simplified LL parser (SLL) is an LL parser with a ‟higher”
  perspective.
While the LL's stack symbols are the terminals and
  nonterminals of the grammar, the SLL's symbols are the grammar's
  rules.

As the LL parser, the SLL is consisted of a stack automaton
  and an input string.
The SLL makes it's decision based on the next input symbol an
  symbol at the top of the stack.
It may also decide whether to consume the input token (a feature that
  will later be revoked).

The SLL's stack symbols are grammar rules with an index, indicating
  what is the prefix of the rule that have already been parsed and
  what is the suffix that still needs to be parsed.
The SLL's stack symbols are similar to the famous LR items,
  both in notation and meaning.
For example, if the SLL currently parses the rule~$\<A> ::=αβ$,
  where~$α$ was already parsed, then the top of the stack symbol
  will be denoted by~$\<A> ::=α·β$.

  The SLL begins by pushing the grammar start symbol's rule†{
    Of course, the grammar's start symbol might have more than one rule,
    but since the grammar is LL, each rule have a
    distinct~$\Function First(\cdot)$ set, thus by peeking into the
    first input symbol we can choose a start rule.}
  with a dot before the first symbol, and perform in loop the 
  step depicted
  in~\cref{algorithm:sll-parser}.

\begin{algorithm}[p]
  \caption{\label{algorithm:sll-parser}
  SLL's parsing algorithm step}
  \begin{algorithmic}
    \LET{$X ::=α·Yβ$}{\Function pop()}\COMMENT{what's the anticipated input?}
    \IF[rule is parsed]{$|Yβ|=0$}
      \IF{$X ::=αYβ$ is a start rule}
        \IF[not the anticipated end-of-input]{$\$≠\Function next()$}
          \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
        \ELSE
          \STATE{\textsc{Accept}}\COMMENT{all input successfully consumed}
        \FI
      \FI
      \CONTINUE
    \FI
    \STATE{$\Function push(X::=αY·β)$}\COMMENT{push next}
    % STOPPED HEREEEEEEEEEEEEEEEEEEEEEEEEE

    \IF[$Y$ is a terminal]{$Y∈Σ$}
      \IF[read terminal is not anticipated~$Y$]{$Y≠\Function next()$}
        \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
      \ELSE[read terminal is the anticipated~$Y$]
        \STATE{\textsc{Continue}}\COMMENT{next step}
      \FI
    \ELSE[$Y$ must be a nonterminal]
      \LET{$R$}{$\Function δ(Y, \Function peek())$}\COMMENT{which rule to reduce?}
      \IF[no rule found]{$R=⊥$}
        \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
      \ELSE[A rule was found]
        \LET{$(Z ::= Y₁,…,Yₖ)$}{R}\COMMENT{break~$R$ into left/right}
        \STATE{$\Function print(R)$}\COMMENT{rule~$R$ has just been applied}
        \STATE{$\Function push(Z ::= Y₁,…,Yₖ)$}\COMMENT{push the next rule}
        \CONTINUE\COMMENT{restart, popping a new~$X::=…$, etc.}
      \FI % No rule found
    \FI % Y is terminal or nonterminal
  \end{algorithmic}
\end{algorithm}
