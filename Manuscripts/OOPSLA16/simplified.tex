%! TEX root = 00.tex
The section makes the first step of our construction: Presenting the \emph{SLL}
parser, a variant of the traditional LL parser~\cite{lewis:66}, but more
economic in its use of the stack resource, and perhaps of independent value.

Recall that the set of stack symbols of the LL parser of a given grammar are
the union of this grammar's terminals and nonterminals. In contrast, the stack
symbols of the SLL-parser are \emph{items}. An item is pair of a grammar rule
and a ``\emph{dot}'', written as \[
  \<A> ::= Y₀…Y_{i-1}·Yᵢ…Yₖ
\]
Formally, the dot is integer, ranging from 0 to the length of the right hand
side of the rule.  But it better to think of it as a notation for the prefix of
the this right hand side. 

An item represents these precise moments in the input analysis process the
input in which: 
\begin{itemize}
  \item all symbols included in this prefix have been successfully parsed, and,
  \item all symbols that lie after this prefix, are awaiting to their turn
      to be parsed.
\end{itemize}

Just as the LL-parser, the SLL parser is a stack automaton equipped with a
prediction table, whose next action is a function (realized in the prediction
table) of the next input symbol and the top of the stack. This action may
involve consuming the input token and conducting push or pop operations on the
stack. Later, we modify the parser so that it cannot examine the  next input
token without consuming it.

The SLL parser is initialized with the stack containing an item denoting the
degenerate prefix of a rule for deriving the start symbol. In case there are
more than one such rule, the automaton selects the rule dictated by the first
input token. (This rule is uniquely determined since the grammar is LL.)

After this initialization, the SLL parser proceeds following the instructions
in~\cref{algorithm:sll-parser}.

\begin{algorithm}[h]
  \caption{\label{algorithm:sll-parser}
  SLL's parsing algorithm step}
  \begin{algorithmic}[1]
    \LET{$X ::=α·Yβ$}{\Function pop()}\COMMENT{what's anticipated on input?}
    \IF[was rule fully parsed]{$|Yβ|=0$}
      \IF{$X$ is the start symbol}
        \IF[not the anticipated end-of-input]{$\$≠\Function next()$}
          \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
        \ELSE
          \STATE{\textsc{Accept}}\COMMENT{all input successfully consumed}
        \FI % Not anticipated EOF
      \FI % Start symbol
      \CONTINUE\COMMENT{restart, popping a new item etc.}
    \FI
    \STATE{$\Function push(X::=αY·β)$}\COMMENT{advance the dot, and push result}
    \IF[$Y$ is a terminal]{$Y∈Σ$}
      \IF[read terminal is not anticipated~$Y$]{$Y≠\Function next()$}
        \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
      \ELSE[read terminal is the anticipated~$Y$]
        \CONTINUE\COMMENT{restart, popping a new~$X::=…$, etc.}
      \FI
    \ELSE[$Y$ must be a nonterminal]
      \LET{$R$}{$\Function δ(Y, \Function peek())$}\COMMENT{which rule to reduce?}
      \IF[no rule found]{$R=⊥$}
        \STATE{\textsc{Reject}}\COMMENT{SLL halts in error}
      \ELSE[a rule was found]
        \LET{$(Z ::= Y₁,…,Yₖ)$}{R}\COMMENT{break into left/right}
        \STATE{$\Function print(R)$}\COMMENT{rule~$R$ has just been applied}
        \STATE{$\Function push(Z ::=·Y₁,…,Yₖ)$}\COMMENT{push the next item}
        \CONTINUE\COMMENT{restart, popping a new rule etc.}
      \FI % No rule found
    \FI % Y is a terminal or a nonterminal
  \end{algorithmic}
\end{algorithm}

Comparing \cref{algorithm:sll-parser} with the LL-parsing algorithm
(\cref{algorithm:ll-parser}), we see that they both begin with popping a stack 
symbol. 

However, after this popping, the SLL parser gives a special treatment to the
case that the prefix denoted by the dot makes the entire right-hand-side of the
rule. The instructions in charge (lines 2--7, of \cref{algorithm:sll-parser})
do not occur as is in \cref{algorithm:ll-parser} (even though handling of `\$'
in the input is similar in both), since the stack symbols of the LL parser do
not carry any information on their location in the rule that originated them. 

Other than that, the two algorithms are similar, except that the next symbol to
parse, denoted $X$ in \cref{algoirthm:ll-parser} is obtained by extracting the
symbol $Y$ that follows the dot in the item $X$ in \cref{algorithm:sll-parser}.

We see that the SLL parser essentially emulates the LL parser except that it
attaches to each symbol the location within the rule. This makes it possible to
eliminate the loop of several of push operations of LL (line 20 in
\cref{algorithm:ll-parser}) with a single push (line 22 in
\cref{algorithm:sll-parser}). 

