\documentclass[nonatbib,preprint,numbers]{sigplanconf}

\authorinfo{Mr.\ U. N. Owen \& Co.}{}{}

\title
{%
  %%\begin{flushright}
  %  \textcolor{blue!20!black}
  %  {\footnotesize\mdseries\slshape
  %    \renewcommand\baselinestretch{0.3}
  %    Software design is language design\\
  %    (and vice versa).\vspace{-4ex}\tiny\\
  %    \renewcommand\baselinestretch{0.3}
  %    ---a programmers' proverb
  %  }
  %\end{flushright}
  An Algorithm For Generating Fluent APIs for  Java 
}

\usepackage{\jobname}
%\overfullrule=1mm
%\directlua{dofile("DetectUnderfull.lua")}

\begin{document}
\maketitle

\begin{abstract}
  \input{abstract}
\end{abstract}

\section{Introduction}
\input{aa}

\paragraph{Outline.} \Cref{section:example} familiarizes the reader with
techniques of converting a formal language specification into \Java types that
realizes the fluent API defined by the language. The example in this section is
used in \cref{section:fajita} to demonstrate \Fajita.  The reminder of LL
parsing theory in \cref{section:intuition} is to explain the challenges to be
met by main algorithm for the compilation of an LL language into into the \Java
type-checking model.  The main algorithm is described in
\cref{section:algorithm}.  \Cref{section:zz} concludes.

\section{Type States and a Fluent API Example}
\label{section:example}
\input{example}

\section{Fajita}
\label{section:fajita}
\input{generalization}

\section{LL Parsing and Realtime Constraints}
\label{section:intuition}
\input{intuition}

\section{Generating a Realtime Parser \\ from an LL Grammar}
\label{section:algorithm}
\input{algorithm}

\section{Conclusions}
\label{section:zz}
\input{zz}

\bibliographystyle{abbrv}\small
\bibliography{author-names,other-shorthands-abbreviated,%
  publishers-abbreviated,%
  conferences-abbreviated,%
  journals-abbreviated,journals-full,%
  yogi-tr,yogi-book,yogi-practice,yogi-journal,yogi-theory,yogi-confs,%
  GPCE,OOPSLA,PLDI,USENIX,ECOOP,%
  00}
\end{document}
