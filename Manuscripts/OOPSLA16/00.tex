\documentclass[nonatbib,preprint,numbers]{sigplanconf}

\authorinfo{Mr.\ U. N. Owen}{}{}

\title
{%
  %%\begin{flushright}
  %  \textcolor{blue!20!black}
  %  {\footnotesize\mdseries\slshape
  %    \renewcommand\baselinestretch{0.3}
  %    Software design is language design\\
  %    (and vice versa).\vspace{-4ex}\tiny\\
  %    \renewcommand\baselinestretch{0.3}
  %    ---a programmers' proverb
  %  }
  %\end{flushright}
  An Algorithm For Generating Fluent APIs for  Java 
}

\usepackage{\jobname}
%\overfullrule=1mm
%\directlua{dofile("DetectUnderfull.lua")}

\begin{document}
\maketitle

\begin{abstract}
  \input{abstract}
\end{abstract}

\section{Introduction}
\input{aa}

\paragraph{Outline.} \Cref{section:example} explains how \Fajita may serve the
designer of a fluent API\@.
Then, \Cref{section:background} discusses the core computational theory problem
that \Fajita needs to solve: recognizing and parsing of formal languages within
the framework of the limited abilities of \Java generics.  The language
recognition algorithm that \Fajita implements is the subject of
\cref{section:intuition}.  \Cref{section:zz} concludes.

\section{Type States and a Fluent API Example}
\label{section:example}
\input{example}

\section{Type State For Making Type States?}
\label{section:generalization}
\input{generalization}

\section{Intuition}
\label{section:intuition}
\input{intuition}

\section{Generating a Realtime Parser \\ from an LL Grammar}
\label{section:algorithm}
\input{algorithm}

\section{Compiling an \RLLp to \Java types}
\label{section:background}
\input{background}


\section{Conclusions}
\label{section:zz}
\input{zz}

\bibliographystyle{abbrv}\small
\bibliography{author-names,other-shorthands-abbreviated,%
  publishers-abbreviated,%
  conferences-abbreviated,%
  journals-abbreviated,journals-full,%
  yogi-tr,yogi-book,yogi-practice,yogi-journal,yogi-theory,yogi-confs,%
  GPCE,OOPSLA,PLDI,USENIX,ECOOP,%
  00}
\end{document}

\clearpage
\appendix
\section{Hints from ECOOP}
\label{section:ecoop}
\input{ecoop}
