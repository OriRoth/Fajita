We now turn to the proof of \cref{Theorem:Gil-Levy}, which will be showing a type encoding for the DPDA that recognizes a certain DCFG language.
The proof is by reduction to type encoding of SDPDAs, which are simpler version of deterministic pushdown automata.

\subsection{Reduction}
The difficulty in type-encoding of general DPDAs is that of~$ε$-moves:
A DPDA is allowed to make a transition into a different state,
  pop one or more stack elements, and then, pop, push or even both pop and push, any number of stack symbols,
  all without reading a single input symbol.

In contrast, our type encoding relies on the encoding of an input string~$α∈Σ^*$, one character at a time, as a sequence of method calls.
A step of computation occurs in the domain of \Java types only at method calls. There are no-provisions for encoding~$ε$-moves, however determistic
  they are.
The following definition is of a deterministic pushdown automata without such moves.

\begin{Definition}
  \label{Definition:SDPDA}
  \slshape
  A \emph{\textbf Simplified \textbf Deterministic \textbf Pushdown \textbf Automaton} (SDPDA) of order~$k$ is
    a quintuple~$⟨Γ,Q,q₀,A,δ⟩$,
  where~$Γ$,~$Q$,~$q₀∈Q$,~$A⊆Q$ are precisely as in \cref{Definition:DPDA}.
  The signature of function~$δ$, the \emph{generalized partial transition function}
  of an SDPDA of order~$k$, is however~$δ: Q⨉Γᵏ⨉Σ↛Q⨉Γ^*$. % this is the right order
  \par
  An SDPDA begins as a DPDA. At each step it examines~$σ∈Σ$,
    the next input symbol,~$q∈Q$, the current state,
    and~$γ₁,⋯,γₖ∈Γ$, the~$k$ top most stack elements,
  \par
  If the stack is empty, or~$q∈A$, the automaton stops in accepting.
  If the transition function is undefined, i.e.,~$δ(q,γ₁,…,γₖ,σ)=⊥$ the automaton
    stops in rejection.
  Otherwise, and since there are no~$ε$-moves, there are~$q'∈Q$ and~$ζ∈Γ^*$
    such that~$δ(q,γ₁,…,γₖ,σ)=(q',ζ)$.
  The automaton then pops~$γ₁$ through~$γₖ$, pushes the sequence~$ζ$, and
    moves to state~$q'$.
\end{Definition}

Consider a state~$q$ of a DPDA, and assume the top of the stack is~$γ$.
If~$δ(q,γ,σ)$ is defined for some~$σ∈Σ$, then the definition of a
  DPDA requries that there are no~$ε$-moves.
Such moves occur when~$δ(q,γ,ε) =(q',ζ)$ for
  some state~$q'$ and a sequence of stack elements~$ζ$.
  (Note that in this case,~$δ(q,γ,σ)=⊥$ for all~$σ∈Σ$).
Let us compute the~$ε$-closure of the state~$(q,γ)$ as follows:

\subsection{Type Encoding}
\begin{Theorem}
  \label{Theorem:SDPDA}
  For every SDPDA~$M$ there exists a set~$J_M$ of \Java type definitions, such that
  the command \[
    \cc{M x = M.build.$\textsf{java}(α)$}.\$();
  \]
  compiles against~$Jₘ$ if an only if~$α$ is the language recognized by~$M$.
\end{Theorem}

The remainder of this section is dedicated to the proof of \cref{Theorem:SDPDA}.
In particular, we describe how~$J_M$ is constructed from the
  specification of~$M$.

We will use the following notation for
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,

\begin{figure}[H]
\begin{JAVA}
class Stack<Head extends ¢$Γ$¢, Rest extends Stack<?,?> > {¢¢
  Head head;
  Rest rest;
  Stack(Head head, Rest rest) {¢¢ this.head = head; this.rest = rest;}
  Rest pop() {¢¢ return rest; };
}
\end{JAVA}
For each state~$ξ∈Q$, we generate a \Java class~$ξ$,
\begin{JAVA}
class ¢$ξ$¢ <T extends S> extends S<T> {¢¢
  ¢$ξ$¢(T t) {¢¢ super(t); }
  // ¢…¢
}
\end{JAVA}
\end{figure}
In addition, we define a special class~$\vdash$ to designate the empty stack.
\begin{JAVA}
class ¢$\vdash$¢ extends Stack<¢$Γ$¢, ¢$\vdash$¢> {¢¢
  ¢$\vdash$ ¢() {¢¢ super(null); }
  ¢$\vdash$ ¢pop() {¢¢ throw new RunTimeException(); }
}
\end{JAVA}
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,
where~$ξ₁,ξ₂∈Q$ are stack elements,
is represented by the following type
\begin{JAVA}
  ¢$ξ₁$¢ < ¢$ξ₂$¢ < ¢$ξ₁$¢ < ¢$⊥$ > > >
\end{JAVA}
This is a general concept for implementing an unbounded stack with \Java's type system,
that will be extended in the future.

\subsection{Encoding states of pushdown automaton with \Java generics}
The generalized transition function \cref{Equation:generalized:transition}
  takes~$k+2$ arguments: a state~$q∈Q$, an input symbol~$σ∈Σ$
    and~$k$ stack elements drawn from~$Γ$.
To capture the full behavior of the automaton, the transition function
  must be able to pass along, in one way or another, the full contents of the stack.

Since the scheme described above can only be applied for binary functions,
  we shall pack together the state~$q$, the stack, and the~$k$ top most
  elements of it into a single type.
The next input symbol,~$σ∈Σ$, the remaining argument of function~$δ$,
  is encoded as a method.

The type part of the encoding is obtained by instantiating a generic type as follows:
Let~\cc{Q} be the abstract class that represents~$Q$, and let~\cc{q} be the concrete class that
  implements~\cc{Q} for an automaton state~$q∈Q$.
Then, to accommodate the extra~$k$ parameters of~$δ$, we add~$k$ generic parameters
  to class~$Q$ and to every class~\cc{q} that implements it.
Yet another such parameter is added for representing stack contents.

Consider the case~$k=2$.
\begin{figure}
  \begin{JAVA}
abstract class Q<S, ¢$γ₁$¢, ¢$γ₂$¢
  \end{JAVA}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:hierarchy}%
    Type hierarchy of the type encoding of a simple SDPDA.
  }
  \begin{adjustbox}{}
    \input ../Figures/automaton.tikz
  \end{adjustbox}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:example}%
    A type encoding of a simple pushdown automaton.
  }
  \javaInput[minipage,width=\linewidth]{spda.listing}
\end{figure}
As might be expected, this type is obtained
The
The

To encode this function within
