\begin{Definition}[Deterministinc Pushdown Automaton]
  \label{Definition:DPDA}
  A \emph{deterministic pushdown automaton} (DPDA)~$M$ is an 8-tuple
  \[
    M =⟨Q,Σ,Γ, q₀,⊥, A,δ,η⟩
  \]
  where~$Q$ is the a finite set of
  \emph{the states of~$M$},~$Σ$ is a finite
  \emph{set of input symbols},~$Γ$ is a finite
  \emph{set of stack symbols},~$q₀∈Q$ is the initial state,~$⊥∈Γ$
  is a \emph{special symobl designating the bottom of the stack}
  and~$A⊆Q$ is the \emph{set of accepting states} while~$δ$ and~$η$ are
  the \emph{partial functions of state transition}
  \[
    \begin{array}{crlc}
      δ: & Q⨉Σ⨉Γ &↛& Q⨉Γ^*⏎
      η: & Q⨉Γ &↛& Q⨉Γ^*,⏎
    \end{array}
  \]
\end{Definition}
We shall be using the following notation for
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,

\begin{Definition}[Simplified Pushdown Automaton]
  \label{Definition:SPDA}
  A \emph{\textbf simplified \textbf pushdown \textbf automaton} (SPDA)~$M$ of order~$k$ is a 7-tuple
  \[
    M =⟨Q,Σ,Γ,q₀,⊥, A,δ⟩
  \]
  where~$Q$,~$Σ$,~$Γ$,~$q₀$,~$⊥∈Γ$ and~$A$ are precisely as in \cref{Definition:DPDA}.
  However, the signature of function~$δ$, the \emph{generalized partial transition function}
  of an SPDA of order~$k$, is:
  \begin{equation}
    \label{Equation:generalized:transition}
      δ: Q⨉Σ⨉Γᵏ↛Q⨉Γ^*
    \end{equation}
\end{Definition}

\begin{Theorem}
  \label{Theorem:SPDA}
  For every SPDA~$M$ there exists a set~$J_M$ of \Java type declarations, such that
    I do not know what to so say here yet.
\end{Theorem}

The remainder of this section is dedicated to the proof of \cref{Theorem:SPDA}.
In particular, we describe how~$J_M$ is constructed from the
  specification of~$M$.

\subsection{Encoding the stack with \Java generics}
First is the stack.
\begin{JAVA}
class S<T extends S> {
  T t;
  S(T t) { this.t = t; }
  T pop() { return t; };
}
\end{JAVA}
For each state~$ξ∈Q$, we generate a \Java class~$ξ$,
\begin{JAVA}
class ¢$ξ$¢ <T extends S> extends S<T> {
  ¢$ξ$¢(T t) { super(t); }
  // ¢…¢
}
\end{JAVA}
In addition, we define a special class~$⊥$ that designates the bottom of the stack.
\begin{JAVA}
class ¢$⊥$¢ extends S<¢$⊥$¢> {
  ¢$⊥$¢() { super(null); }
  ¢$⊥$¢pop() { throw new RunTimeException(); }
}
\end{JAVA}
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,
where~$ξ₁,ξ₂∈Q$ are stack symbols,
is represented by the following type
\begin{JAVA}
  ¢$ξ₁$¢ < ¢$ξ₂$¢ < ¢$ξ₁$¢ < ¢$⊥$ > > >
\end{JAVA}
This is a general concept for implementing an unbounded stack with \Java's type system,
that will be extended in the future.

\subsection{Type encoding of unary (non-partial) functions}
\begin{figure}
  \begin{JAVA}[style=numbered]
  static final class ¢$⊥$¢ extends T¢$⁺$¢ {} // Error Value ¢$⊥∈T⁺$¢
  static abstract class T extends T¢$⁺$¢ { // Set ¢$T⊂T⁺$¢
    abstract T g(); 
  } 
  static final class t1 extends T { // Value ¢$t₁∈T$¢
    final t2 g() { return null; }
  } 
  static final class t2 extends T { // Value ¢$t₂∈T$¢
    final t1 g() { return null; }
  } 
}
\end{JAVA}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).}
\end{figure}
\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$
  within the framework of \Java generics and static type checking.
Before showing how this is done in the general case, consider this example:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  T & = ❴ t₁, t₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}

\begin{figure}
  \begin{JAVA}[style=numbered]
abstract class R { // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R { // Value ¢$r₁∈R$¢
    t1 s1() { return null; }
    t2 s2() { return null; }
  }
  static final class r2 extends R { // Value ¢$r₂∈R$¢
    t2 s1() { return null; }
    ¢$⊥$¢ s2() { return null; }
  }
}
abstract class T¢$⁺$¢ { // Set ¢$T∪❴⊥❵~$¢
  static final class ¢$⊥$¢ extends T¢$⁺$¢ {} // Error Value ¢$⊥∈T⁺$¢
  static abstract class T extends T¢$⁺$¢ { // Set ¢$T⊂T⁺$¢
    abstract T g(); 
  } 
  static final class t1 extends T { // Value ¢$t₁∈T$¢
    final t2 g() { return null; }
  } 
  static final class t2 extends T { // Value ¢$t₂∈T$¢
    final t1 g() { return null; }
  } 
}
\end{JAVA}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).}
\end{figure}

\begin{figure}
  \begin{JAVA}
abstract class f { // A non-instantiable ¢\cc{abstract}¢ class
  private f() { throw new RuntimeException(); }
  static r1() { return new r1(); }
  static r2() { return new r2(); }
}
\end{JAVA}
  \begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type 
f.r1().s2().g(); // ¢✓¢
f.r2().s1().g(); // ¢✓¢
f.r2().s2().g(); // ¢✗¢ compile time error, function \cc{g()} is undefined for type $T^+$.
\end{JAVA}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).}
\end{figure}
\cmark\xmark

Here is an example,
To do so, generate an abstract class \cc{R} that represents~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
To do so, generate an abstract class \cc{T} that represents~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$s∈S$, introduce an abstract method named \cc{s},
  in class~$R$

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode

\subsection{Encoding states of pushdown automaton with \Java generics}
The generalized transition function \cref{Equation:generalized:transition}
  takes~$k+2$ arguments: a state~$q∈Q$, an input symbol~$σ∈Σ$
    and~$k$ stack symbols drawn from~$Γ$.
To capture the full behavior of the automaton, the transition function
  must also save, in some fashion the full state of the stack, and
  encode in it the changes applied to the stack.

Since the scheme described above can only be applied for binary functions,
  we shall pack together the state~$q$, the stack, and the~$k$ top most
  elements of it into a single type.
  The remaining argument of function~$δ$, i.e., the next input symbol,~$σ∈Σ$,
  is encoded as a method.

The type part of the encoding is obtained by instantiating a generic type as follows:
Let \cc{Q} be the abstract class that represents~$Q$, and let \cc{q} be the concrete class that
  implements \cc{Q} for an automaton state~$q∈Q$.
Then, to accommodate the extra~$k$ parameters of~$δ$, we add~$k$ generic parameters
  to class~$Q$ and to every class \cc{q} that implements it.
Yet another such parameter is added for representing the full information on the stack.
\begin{JAVA}
abstract class Q<S' extends S, T extends
\end{JAVA}

Let~$q∈Q$ be a state of the automaton. Then, we

  As might be expected, this type is obtained
  The
  The

To encode this function within

\subsubsection{Building the automaton's dependency graph}

\begin{description}
  \item [Input:] LR(1) parser.
  \item [Output:] A dependency graph defining the dependencies between
  instantiations of state classes
  \item [Notations:]
\end{description}
\begin{itemize}
  \item~$Q^B$ a state that we are look at the instantiation from his context.
  \item Let~$σ$ be a transition from~$Q^B$ then~$Q_σ^B$
        is the instantiation of~$action(Q_B,σ)$ in context
        of~$Q^B$
  \item Let~$σ₂$be a transition from~$Q_{σ₁}$ then~$Q_{σ₁σ₂}$
        is the instantiation of~$action(Q_{σ₁}^B,σ₂)$
        in context of~$Q^B$
  \item the symbols a,b,c,d will be terminals (not including \$)
  \item the symbols A,B,C,D will be nonterminals(not including S').
  \item the symbols X,Y,Z,W will be either terminals or nonterminals.
        \item~$α,β,γ$ will be strings of grammar symbols
\end{itemize}
\begin{description}
  \item [Method:]
  \begin{enumerate}
    \item~$V=∅$,$E=∅$
    \item For each~$Q^B∈Parser$
          \begin{enumerate}
            \item~$∀[A\rightarrowε·,b]∈Q^B$
            \begin{enumerate}
              \item~$V=V\bigcup❴ Q_{Ab}^B,Q_{b}^B❵~$
              \item~$E=E\bigcup❴ (Q_{Ab}^B,Q_{b}^B)❵~$
            \end{enumerate}
            \item~$∀[A→·Xα,b]∈Q^B$
            \begin{enumerate}
              \item~$Q_{Ab}^B=Find(Q^B,A,b)$
              \item If~$Q_{Ab}^B≠null$ :
                    \begin{enumerate}
                      \item~$V=V\bigcup❴ Q_{Ab}^B,Q_{X}^B❵~$
                      \item~$E=E\bigcup❴ (Q_{Ab}^B,Q_{X}^B)❵~$
                    \end{enumerate}
            \end{enumerate}
            \item~$∀[A→·Cd,b]∈Q^B$
            \begin{enumerate}
              \item~$Q_{Ab}^B=Find(Q^B,A,b)$
              \item If~$Q_{Ab}^B≠null$ :
                    \begin{enumerate}
                      \item~$Q_{Cd}^B=Find(Q^B,C,d)$
                      \item~$V=V\bigcup❴ Q_{Ab}^B,Q_{Cd}^B❵~$
                      \item~$E=E\bigcup❴ (Q_{Ab}^B,Q_{Cd}^B)❵~$
                    \end{enumerate}
            \end{enumerate}
            \item~$∀Q_{Ab}^B∈V$
            \begin{enumerate}
              \item~$V=V\bigcup❴ Q_{A}^B,Q_{b}^{A}❵~$
              \item~$E=E\bigcup❴ (Q_{A}^B,Q_{Ab}^B)❵~$
              \item~$Q_{b}^{A}=Find(Q^{A},b)$
              \item~$E=E\bigcup❴ (Q_{b}^{A},Q_{Ab}^B)❵~$
            \end{enumerate}
          \end{enumerate}
  \end{enumerate}
  /{*}{*}
  Returns the state that will consume b, or null, if it cannot be determined.
  {*}{*}/
  \begin{description}
    \item [Function]~$Find(Q^B,A,b)$ returns ContexedState
  \end{description}
  \begin{enumerate}
    \item If~$action(Q_{A}^B,b)=sᵢ$
          \begin{enumerate}
            \item return~$Qᵢ$
          \end{enumerate}
    \item else //$Q_{A}^B$ reduces by rule~$C\rightarrowα·,b$
          \begin{enumerate}
            \item If~$|α|>1$
                  \begin{enumerate}
                    \item return null //‟Inherited TA”
                  \end{enumerate}
            \item else if~$|α|=1$ ($α=A$ )
                  \begin{enumerate}
                    \item return~$Find(Q^B,C,b)$
                  \end{enumerate}
            \item else //$α=ε$
                  \begin{enumerate}
                    \item return~$Find(Q^{A},C,b)$
                  \end{enumerate}
          \end{enumerate}
  \end{enumerate}
  \begin{description}
    \item [Function]~$Find(Q^B,b)$ returns ContexedState
  \end{description}
  \begin{enumerate}
    \item If~$action(Q^B,b)=sᵢ$
          \begin{enumerate}
            \item return~$Qᵢ$
          \end{enumerate}
    \item else //$Q^B$ reduces by rule~$C\rightarrowα·,b$
          \begin{enumerate}
            \item If~$|α|>0$
                  \begin{enumerate}
                    \item return null //‟Inherited TA”
                  \end{enumerate}
            \item else //$α=ε$
                  \begin{enumerate}
                    \item return~$Find(Q^B,C,b)$
                  \end{enumerate}
          \end{enumerate}
  \end{enumerate}
  \item [Complexity:]
  \begin{itemize}
    \item~$V=O()$
    \item~$E=O()$
  \end{itemize}
\end{description}
\subsubsection*{Instantiating states}
\begin{description}
  \item [Input:] A dependency graph~$G=(V,E)$ for state~$Q_B$.
  \item [Output:] An instantiated class for s.
  \item [Method:]
  \begin{enumerate}
    \item Handle dependency cycles.
    \item Run a topoligical sort on~$G$ ( we now know~$G$ is a~$DAG$)
    \item for each~$S$ in topological order:
          \begin{enumerate}
            \item If~$S=Q_{X}^B$
                  \begin{enumerate}
                    \item~$FillSingleTransition(Q_{X}^B)$
                  \end{enumerate}
            \item Else if~$S=Q_{XY}^B$
                  \begin{enumerate}
                    \item~$FillDoubleTransition(Q_{XY}^B)$
                  \end{enumerate}
          \end{enumerate}
  \end{enumerate}
  \begin{description}
    \item [Function]~$FillSingleTransition(Q_{X}^B):$
    \begin{enumerate}
      \item For each triplet~$(A,i,a)∈Q_{X}^B$
            \begin{enumerate}
              \item If~$(A,i-1,a)∈Q^B$ then //inherited TA(Type Argument)
                    \begin{enumerate}
                      \item~$Q_{X}^B[(A,i,a)]:=Q^B[(A,i-1,a)]$
                    \end{enumerate}
              \item Else // synthesized TA
                    \begin{enumerate}
                      \item~$Q_{X}^B[(A,i,a)]:=Q_{Aa}^B$
                    \end{enumerate}
            \end{enumerate}
    \end{enumerate}
    /{*}{*}
    merges~$Q^{X}_{Y},Q^B_{X}$ into an extended instantiation of~$Q_{XY}^B$
    {*}{*}/
    \item [Function]~$FillDoubleTransition(Q_{XY}^B)$:
    \begin{enumerate}
      \item For each triplet~$(A,i,a)∈Q_{XY}^B$
            \begin{enumerate}
              \item If~$((A,i-1,a)∈Q^B_{X})∧((A,i-2,a)\notin Q^B)$ //Inherited TA or Synthesized from~$Q^B$
                    \begin{enumerate}
                      \item~$Q_{XY}^B[(A,i,a)]:=Q_{X}^B[(A,i-1,a)]$
                    \end{enumerate}
              \item Else // Synthesized from~$Q_{X}^B$
                    \begin{enumerate}
                      \item~$Q_{XY}^B[(A,i,a)]:=Q^{X}_{Y}[(A,i-1,a)]$
                    \end{enumerate}
            \end{enumerate}
    \end{enumerate}
  \end{description}
  \item [Complexity:]
  Instantiation algorithm time complexity:~$O()$
\end{description}
