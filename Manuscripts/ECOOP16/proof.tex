On a first sight, the proof of \cref{Theorem:Gil-Levy} could follows the techniques
  sketched in \cref{Section:toolkit} to type encode a DPDA (\cref{Definition:DPDA}).
The partial transition function~$δ$ may be type encoded as in \cref{Figure:simple-binary},
and the stack data structure of a DPDA can be encoded as in \cref{Figure:stack-encoding}.

The techniques however fail with~$ε$-transitions,
  which allow the automaton to move between an unbounded number of
  configurations and maneuver the stack in a non-trivial manner,
  without making any progress on the input.
The fault in scheme lies with compile time computation being carried out
  by the~$\textsf{java}(σ)()$ functions, each convertin>g
  their receiver type to the type of the receiver of the next call in the chain.
We are not aware of a \Java type encoding which makes
  it possible to convert an input type into an output type, where
  the output is a computed from the input by an unbounded number o steps.†{%
    With the presumption that the \Java compiler halts for all inputs (a presumption that does
    not hold for e.g., \CC, and was never proved for \Java), the claim that there is no \Java type encoding of all DPDAs can be proved:
 Employing~$ε$-transitions, it is easy to construct an automaton~$A^∞$ that
  never halts on any input.
A type encoding of~$A^∞$ creates programs that send the compiler in an infinite loop.
}

The literature speaks of finite-delay DPDAs, in which the number
  of consecutive~$ε$-transitions is uniformally bounded and even of
  realtime DPDAs in which this bound is 0, i.e., no~$ε$-transitions.
Our proof relies on a special kind of realtime automata,
  described by Courcelle~\cite{Courcelle:77}.

\begin{Definition}[Simple-Jump Single-State Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \textit{simple-jump, single-state, realtime deterministic pushdown automaton}
  (jDPDA, for short) is a triplet~$⟨Γ,γ₁,δ⟩$
  where~$Γ$ is a set of stack elements,~$γ₁∈Γ$ is the initial stack element,
  and~$δ$ is the \emph{partial transition function},~$δ:Γ⨉Σ↛Γ^*∪j(Γ)$,
  \[
    j(Γ) = ❴ \textit{instruction \textup{\textsf{jump}}}(γ) \; | \;γ∈Γ❵.
  \]
  A configuration of a jPDA is some~$c∈Γ^*$ representing the stack contents.
  Initially,~$ζ=γ₁$.
  At each steps a jPDA examines~$σ∈Σ$,
  the next input character and~$γ$ the element at the top of the stack, and
  executes the following:
  \begin{quote}
    \begin{enumerate}
      \item consume~$σ$
      \item pop~$γ$
      \item if~$δ(γ,σ)=ζ$,~$ζ∈Γ^*$, the automaton pushes~$ζ$ into the stack.
      \item if~$δ(γ,σ)=\textsf{jump}(γ)$,~$γ∈Γ$, then the automaton repetetively
            pops stack elements upto and incuding the first occurrence of~$γ$.
    \end{enumerate}
  \end{quote}
  The automaton accepts by reaching the end of the input with an empty stack.
  It rejects if~$δ(γ,σ) =⊥$, or if it encounters
  an empty stack (either at the beginning of a step or on course
  of a \textsf{jump operations}.
\end{Definition}

As it turns out, every DCFG language is recognized by some jDPDA~\cite{Courcelle:77}.
The proof of \cref{Theorem:Gil-Levy} is therefore reduced to type-encoding of a given jPDA.
Towards this end, we use the above type encoding of the jump-stack data structure.
In particular let instantiations of generic type \cc{JS} (\cref{Figure:jump}) encode the configuration of a jPDA and
assume that

\subsection{Encoding states of pushdown automaton with \Java generics}
The generalized transition function
  takes~$k+2$ arguments: a state~$q∈Q$, an input character~$σ∈Σ$
    and~$k$ elements drawn from~$Γ$.
To capture the full behavior of the automaton, the transition function
  must be able to pass along, in one way or another, the full contents of the stack.

Since the scheme described above can only be applied for binary functions,
  we shall pack together the state~$q$, the stack, and the~$k$ top most
  elements of it into a single type.
The next input character,~$σ∈Σ$, the remaining argument of function~$δ$,
  is encoded as a method.

The type part of the encoding is obtained by instantiating a generic type as follows:
Let~\cc{Q} be the abstract class that represents~$Q$, and let~\cc{q} be the concrete class that
  implements~\cc{Q} for an automaton state~$q∈Q$.
Then, to accommodate the extra~$k$ parameters of~$δ$, we add~$k$ generic parameters
  to class~$Q$ and to every class~\cc{q} that implements it.
Yet another such parameter is added for representing stack contents.

Consider the case~$k=2$.
\begin{figure}
  \begin{JAVA}
abstract class Q<S, ¢$γ₁$¢, ¢$γ₂$¢>
  \end{JAVA}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:hierarchy}%
    Type hierarchy of the type encoding of a simple SDPDA.
  }
  \begin{adjustbox}{}
    \input ../Figures/automaton.tikz
  \end{adjustbox}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:example}%
    A type encoding of a simple pushdown automaton.
  }
  \javaInput[minipage,width=\linewidth]{spda.listing}
\end{figure}
\begin{Definition}
  \label{Definition:realtime}
  \slshape
We say a DPDA supplies the \emph{realtime condition} if
  for all~$q∈Q$,~$γ∈Γ$ :~$δ(q,γ,ε)=⊥$ (i.e., undefined).
\end{Definition}
