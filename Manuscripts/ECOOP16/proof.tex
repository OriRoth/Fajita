\begin{Definition}[Simplified Pushdown Automaton]
  \label{Definition:SDPDA}
  A \emph{\textbf simplified \textbf pushdown \textbf automaton} (SDPDA)~$M$ of order~$k$ is a 7-tuple
  \[
    M =⟨Q,Σ,Γ,q₀,⊥, A,δ⟩
  \]
  where~$Q$,~$Σ$,~$Γ$,~$q₀$,~$⊥∈Γ$ and~$A$ are precisely as in \cref{Definition:DPDA}.
  However, the signature of function~$δ$, the \emph{generalized partial transition function}
  of an SDPDA of order~$k$, is:
  \begin{equation}
    \label{Equation:generalized:transition}
      δ: Q⨉Σ⨉Γᵏ↛Q⨉Γ^*
    \end{equation}
\end{Definition}


\begin{Theorem}
  \label{Theorem:SDPDA}
  For every SDPDA~$M$ there exists a set~$J_M$ of \Java type definitions, such that
  the command \[
    \cc{M x = M.build.$\textsf{java}(α)$}.\$();
  \]
  compiles against~$Jₘ$ if an only if~$α$ is the language recognized by~$M$.
\end{Theorem}

The remainder of this section is dedicated to the proof of \cref{Theorem:SDPDA}.
In particular, we describe how~$J_M$ is constructed from the
  specification of~$M$.

We will use the following notation for
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,

\begin{figure}[H]
\begin{JAVA}
class Stack<Head extends ¢$Γ$¢, Rest extends Stack<?,?> > {¢¢
  Head head;
  Rest rest;
  Stack(Head head, Rest rest) {¢¢ this.head = head; this.rest = rest;}
  Rest pop() {¢¢ return rest; };
}
\end{JAVA}
For each state~$ξ∈Q$, we generate a \Java class~$ξ$,
\begin{JAVA}
class ¢$ξ$¢ <T extends S> extends S<T> {¢¢
  ¢$ξ$¢(T t) {¢¢ super(t); }
  // ¢…¢
}
\end{JAVA}
\end{figure}
In addition, we define a special class~$\vdash$ to designate the empty stack.
\begin{JAVA}
class ¢$\vdash$¢ extends Stack<¢$Γ$¢, ¢$\vdash$¢> {¢¢
  ¢$\vdash$ ¢() {¢¢ super(null); }
  ¢$\vdash$ ¢pop() {¢¢ throw new RunTimeException(); }
}
\end{JAVA}
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,
where~$ξ₁,ξ₂∈Q$ are stack elements,
is represented by the following type
\begin{JAVA}
  ¢$ξ₁$¢ < ¢$ξ₂$¢ < ¢$ξ₁$¢ < ¢$⊥$ > > >
\end{JAVA}
This is a general concept for implementing an unbounded stack with \Java's type system,
that will be extended in the future.

\subsection{Encoding states of pushdown automaton with \Java generics}
The generalized transition function \cref{Equation:generalized:transition}
  takes~$k+2$ arguments: a state~$q∈Q$, an input symbol~$σ∈Σ$
    and~$k$ stack elements drawn from~$Γ$.
To capture the full behavior of the automaton, the transition function
  must be able to pass along, in one way or another, the full contents of the stack.

Since the scheme described above can only be applied for binary functions,
  we shall pack together the state~$q$, the stack, and the~$k$ top most
  elements of it into a single type.
The next input symbol,~$σ∈Σ$, the remaining argument of function~$δ$,
  is encoded as a method.

The type part of the encoding is obtained by instantiating a generic type as follows:
Let~\cc{Q} be the abstract class that represents~$Q$, and let~\cc{q} be the concrete class that
  implements~\cc{Q} for an automaton state~$q∈Q$.
Then, to accommodate the extra~$k$ parameters of~$δ$, we add~$k$ generic parameters
  to class~$Q$ and to every class~\cc{q} that implements it.
Yet another such parameter is added for representing stack contents.

Consider the case~$k=2$.
\begin{figure}
  \begin{JAVA}
abstract class Q<S, ¢$γ₁$¢, ¢$γ₂$¢
  \end{JAVA}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:hierarchy}%
    Type hierarchy of the type encoding of a simple SDPDA.
  }
  \begin{adjustbox}{}
    \input ../Figures/automaton.tikz
  \end{adjustbox}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:example}%
    A type encoding of a simple pushdown automaton.
  }
  \javaInput[minipage,width=\linewidth]{spda.listing}
\end{figure}
As might be expected, this type is obtained
The
The

To encode this function within
