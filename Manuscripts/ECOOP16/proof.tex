Proof of \cref{Theorem:Gil-Levy} follows the type encoding scheme
  sketched in \cref{Section:result}.
Transitions are nothing but partial functions with multiple parameters.
As we saw in \cref{Section:toolkit}
  it is possible to encode these as types, and just as the unbounded
    stack data found in DPDA.

The difficulty in applying the scheme to a plain DPDA
  (\cref{Definition:DPDA}) is with~$ε$-transitions.
With these, the automaton may move between an unbounded number of
  configurations and maneuver the stack in a non-trivial manner,
  without making any progress on the input.
However, in our scheme, compile time computation is carried out
by the~$\textsf{java}(σ)()$ functions, each converting
  their receiver type to the type of the receiver of the next call in the chain.
We not aware of a \Java type encoding which makes
  it possible to convert an input type into an output type, where
  the output is a computed from the input by an unbounded number o steps.†{%
    With the presumption that the \Java compiler halts for all inputs (a presumption that does
    not hold for e.g., \CC), the claim that there is no \Java type encoding of all DPDAs:
 Employing~$ε$-transitions, it is easy to construct an automaton~$A^∞$ that
  never halts on any input.
A type encoding of~$A^∞$ creates programs that send the compiler in an infinite loop.
}

The following definition is of a deterministic pushdown automata without such moves.
The last construct we remind, is the less known \emph{Simple Jump Deterministic Pushdown Automaton},
the definition relies on Olsder's jump-DPDA supplying condition (S)~\cite{Courcelle:77}.

\begin{Definition}[Simple-Jump Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \textit{simple-jump, one-state, realtime deterministic pushdown automaton}
  (jDPDA, for short) is a triplet~$⟨Γ,γ₀,δ⟩$
  where~$Γ$ is a set of stack elements,~$γ₀∈Γ$ is the initial stack element,
  and~$δ$ is the \emph{partial transition function},~$δ:Γ⨉Σ↛Γ^*∪j(Γ)$,
  \[
    j(Γ) = ❴ \textit{instruction \textup{\textsf{jump}}}(γ) \; | \;γ∈Γ❵.
  \]
  A configuration of a jPDA is some~$c∈Γ^*$ representing the stack contents.
  Initially,~$ζ=γ₀$.
  At each steps a jPDA examines~$σ∈Σ$,
  the next input character and~$γ$ the element at the top of the stack, and
  executes the following:
  \begin{quote}
    \begin{enumerate}
      \item consume~$σ$
      \item pop~$γ$
      \item if~$δ(γ,σ)=ζ$,~$ζ∈Γ^*$, the automaton pushes~$ζ$ into the stack.
      \item if~$δ(γ,σ)=\textsf{jump}(γ)$,~$γ∈Γ$, then the automaton repetetively
            pops stack elements upto and incuding the first occurrence of~$γ$.
    \end{enumerate}
  \end{quote}
  The automaton accepts by reaching the end of the input.
  It rejects if~$δ(γ,σ) =⊥$, or if it encounters
  an empty stack (either at the beginning of a step or on course
  a \textsf{jump operations}.
\end{Definition}

A realtime simple-jump deterministic pushdown automaton is a jump-DPDA
  as defined in~\cref{Definition:JDPDA}
  that supplies~\cref{Definition:realtime}.
We now turn to the proof of \cref{Theorem:Gil-Levy}, which will be showing a type encoding for the DPDA that recognizes a certain DCFG language.
The proof is by reduction to type encoding of SDPDAs, which are simpler version of deterministic pushdown automata.




We will use the following notation for
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,

\begin{figure}[H]
\begin{JAVA}
class Stack<Head extends ¢$Γ$¢, Rest extends Stack<?,?> > {¢¢
  Head head;
  Rest rest;
  Stack(Head head, Rest rest) {¢¢ this.head = head; this.rest = rest;}
  Rest pop() {¢¢ return rest; };
}
\end{JAVA}
For each state~$ξ∈Q$, we generate a \Java class~$ξ$,
\begin{JAVA}
class ¢$ξ$¢ <T extends S> extends S<T> {¢¢
  ¢$ξ$¢(T t) {¢¢ super(t); }
  // ¢…¢
}
\end{JAVA}
\end{figure}
In addition, we define a special class~$\vdash$ to designate the empty stack.
\begin{JAVA}
class ¢$\vdash$¢ extends Stack<¢$Γ$¢, ¢$\vdash$¢> {¢¢
  ¢$\vdash$ ¢() {¢¢ super(null); }
  ¢$\vdash$ ¢pop() {¢¢ throw new RunTimeException(); }
}
\end{JAVA}
The stack contents~$⊥ξ₁ξ₁ξ₂ξ₁$,
where~$ξ₁,ξ₂∈Q$ are elements,
is represented by the following type
\begin{JAVA}
  ¢$ξ₁$¢ < ¢$ξ₂$¢ < ¢$ξ₁$¢ < ¢$⊥$ > > >
\end{JAVA}
This is a general concept for implementing an unbounded stack with \Java's type system,
that will be extended in the future.

\subsection{Encoding states of pushdown automaton with \Java generics}
The generalized transition function
  takes~$k+2$ arguments: a state~$q∈Q$, an input character~$σ∈Σ$
    and~$k$ elements drawn from~$Γ$.
To capture the full behavior of the automaton, the transition function
  must be able to pass along, in one way or another, the full contents of the stack.

Since the scheme described above can only be applied for binary functions,
  we shall pack together the state~$q$, the stack, and the~$k$ top most
  elements of it into a single type.
The next input character,~$σ∈Σ$, the remaining argument of function~$δ$,
  is encoded as a method.

The type part of the encoding is obtained by instantiating a generic type as follows:
Let~\cc{Q} be the abstract class that represents~$Q$, and let~\cc{q} be the concrete class that
  implements~\cc{Q} for an automaton state~$q∈Q$.
Then, to accommodate the extra~$k$ parameters of~$δ$, we add~$k$ generic parameters
  to class~$Q$ and to every class~\cc{q} that implements it.
Yet another such parameter is added for representing stack contents.

Consider the case~$k=2$.
\begin{figure}
  \begin{JAVA}
abstract class Q<S, ¢$γ₁$¢, ¢$γ₂$¢>
  \end{JAVA}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:hierarchy}%
    Type hierarchy of the type encoding of a simple SDPDA.
  }
  \begin{adjustbox}{}
    \input ../Figures/automaton.tikz
  \end{adjustbox}
\end{figure}

\begin{figure}
  \caption{\label{Figure:SDPDA:example}%
    A type encoding of a simple pushdown automaton.
  }
  \javaInput[minipage,width=\linewidth]{spda.listing}
\end{figure}
\begin{Definition}
  \label{Definition:realtime}
  \slshape
We say a DPDA supplies the \emph{realtime condition} if
  for all~$q∈Q$,~$γ∈Γ$ :~$δ(q,γ,ε)=⊥$ (i.e., undefined).
\end{Definition}
