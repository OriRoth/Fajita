On a first sight, the proof of \cref{Theorem:Gil-Levy} could follows the techniques
  sketched in \cref{Section:toolkit} to type encode a DPDA (\cref{Definition:DPDA}).
The partial transition function~$δ$ may be type encoded as in \cref{Figure:simple-binary},
and the stack data structure of a DPDA can be encoded as in \cref{Figure:stack-encoding}.

The techniques however fail with~$ε$-transitions,
  which allow the automaton to move between an unbounded number of
  configurations and maneuver the stack in a non-trivial manner,
  without making any progress on the input.
The fault in the scheme lies with compile time computation being carried out
  by the~$\textsf{java}(σ)()$ functions, each converting
  their receiver type to the type of the receiver of the next call in the chain.
We are not aware of a \Java type encoding which makes
  it possible to convert an input type into an output type, where
  the output is a computed from the input by an unbounded number o steps.†{%
    With the presumption that the \Java compiler halts for all inputs (a presumption that does
    not hold for e.g., \CC, and was never proved for \Java), the claim that there is no \Java type encoding of all DPDAs can be proved:
 Employing~$ε$-transitions, it is easy to construct an automaton~$A^∞$ that
  never halts on any input.
A type encoding of~$A^∞$ creates programs that send the compiler in an infinite loop.
}

The literature speaks of finite-delay DPDAs, in which the number
  of consecutive~$ε$-transitions is uniformly bounded and even of
  realtime DPDAs in which this bound is 0, i.e., no~$ε$-transitions.
Our proof relies on a special kind of realtime automata,
  described by Courcelle~\cite{Courcelle:77}.

\begin{Definition}[Simple-Jump Single-State Realtime Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \textit{simple-jump, single-state, realtime deterministic pushdown automaton}
  (jDPDA, for short) is a triplet~$⟨Γ,γ₁,δ⟩$
  where~$Γ$ is a set of stack elements,~$γ₁∈Γ$ is the initial stack element,
  and~$δ$ is the \emph{partial transition function},~$δ:Γ⨉Σ↛Γ^*∪j(Γ)$,
  \[
    j(Γ) = ❴ \textit{instruction \textup{\textsf{jump}}}(γ) \; | \;γ∈Γ❵.
  \]
  A configuration of a jDPDA is some~$c∈Γ^*$ representing the stack contents.
  Initially,~$ζ=γ₁$.
  For technical reasons, assume that the input terminates with~$\$ \not∈Σ$, a special end-of-file character.
  \begin{itemize}
    \item At each steps a jDPDA examines~$σ∈Σ$,
          the next input character and~$γ$ the element at the top of the stack, and
          executes the following:
          \begin{quote}
            \begin{enumerate}
              \item consume~$σ$
              \item pop~$γ$
              \item if~$δ(γ,σ)=ζ$,~$ζ∈Γ^*$, the automaton pushes~$ζ$ into the stack.
              \item if~$δ(γ,σ)=\textsf{jump}(γ)$,~$γ∈Γ$, then the automaton repetitively
                    pops stack elements up-to and including the first occurrence of~$γ$.
            \end{enumerate}
          \end{quote}
    \item If the next character is~$\$$, then the automaton may reject or accept,
          depending on the value of~$γ$.
  \end{itemize}
  In addition, the automator rejects if~$δ(γ,σ) =⊥$, or if it encounters
  an empty stack (either at the beginning of a step or on course
  of a \textsf{jump operation}.
\end{Definition}

\begin{wraptable}r{29ex}
  \caption{\label{Table:A} The transition function of a jDPDA~$A$,~$Σ=❴σ₁,σ₂❵$,~$Γ=❴γ₁,γ₂❵$}
  \begin{tabular}{c|ll}
             & \hfill~$γ₁$ & \hfill~$γ₂$⏎
    \midrule
$σ₁$ & $\textsf{push}(γ₁,γ₁)$ & $⊥$⏎
$σ₂$ & $\textsf{push}(γ₂,γ₂)$ & $\textsf{jump}(γ₁)$⏎
$\$$ & $\textsf{reject}$ & $\textsf{accept}$⏎
  \end{tabular}
\end{wraptable}

As it turns out, every DCFG language is recognized by some jDPDA, and conversely, every language accepted by a jDPDA
  is DCFG~\cite{Courcelle:77}.
The proof of \cref{Theorem:Gil-Levy} is therefore reduced to type-encoding of a given jDPDA.
Towards this end, we employ the type-encoding techniques developed above, and, in particular, the jump-stack data structure (\cref{Figure:jump}).

The simple~$|Γ|=2$,~$|Σ|=2$) jDPDA~$A$ defined in \cref{Table:A} will serve as our running example.
Let~$L$ be the language~$L$ recognized by~$A$.%
†{
  Incidintally,
\[
  L = ❴ σ₁^{n₁}σ₂^{2m₁} σ₁^{n₂}σ₂^{2m₂} ⋯ σ₁^{n_r}σ₂^{2m_r} \; | \; r≥0∧∀r', 1≤r'≤r⇒\sum_{i=1}^{r'} nᵢ≥\sum_{i=1}^{r'} mᵢ
\]
which is clearly not-regular; the equivalence of DCFG and jDPDAs means also that there is an nonambigous, deterministic
BNF for~$L$; neither the BNF nor the above repesentation are material for the proof.
}

\subsection{Preparation}
Generation of a type encoding for a jDPDA starts with two empty types for sets~$L$,~$Σ^*$:
\begin{JAVA}
\end{JAVA}
Let~$k =|Σ|$.
A configuration is encoded by a generic type~\cc{C}.
Essentially,~\cc{C} is a representation of the stack,
  but~$2k+1$ other parameters are required:
\begin{itemize}
  \item \cc{Rest} a type encoding of the stack after a push
  \item \cc{J$γ$1},…,\cc{J$γ${}$k$},
    type encoding of the stack
    after~$\textsf{jump}{γ₁}$,…,$\textsf{jump}{γₖ}$,
  \item \cc{JR$γ$1}…\cc{JR$γ${}$k$},
    type encoding of \cc{Rest}
    after~$\textsf{jump}{γ₁}$,…~$\textsf{jump}{γₖ}$,
\end{itemize}
Actual arguments would be properly constrained, making sure that
  they are (the type version of) pointers into the actual stack.
In the running example,~\cc{C} is defined as
\begin{JAVA}
\end{JAVA}
This excerpt shows also classes~\cc{E} and~\cc{¤} which encode (as in \cref{Figure:jump})
  the empty and the error configurations.

Classes \cc{C$γ$1},…,\cc{J$γ${}$k$} all specializing~\cc{C}
  encode stacks whose top element is~$γ₁$,…,~$γₖ$.
In the running example,
\begin{JAVA}
\end{JAVA}
