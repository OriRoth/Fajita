\subsection{Method Chaining \emph{vs.} Fluent API}
The pattern ‟invoke function on \cc{sb}” occurs
  six times in the code in \cref{Figure:non-chaining}.

\begin{wrapfigure}[10]{r}{44ex}
  \caption{\label{Figure:non-chaining}%
    Recurring invocations of the pattern ‟invoke function on the same
      receiver”.
  }
  \begin{lcode}[minipage,width=\linewidth]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  StringBuilder sb = new StringBuilder();
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString();
}\end{lcode}
\end{wrapfigure}

Some languages, e.g., \Smalltalk offer syntactic sugar, called \emph{method cascading}, for this pattern.
Method chaining is a ‟programmer made” syntactic sugar for this pattern:
  If a method~$f$ returns its receiver, i.e., \kk{this},
  then, instead of the series of two commands \mbox{\cc{o.$f$(); o.$g$();}}, clients can write
  only one command \mbox{\cc{o.$f()$.$g$();}}.
\cref{Figure:chaining} is the method chaining
  (also, shorter and arguably clearer) version of
  \cref{Figure:non-chaining}.
It is made possible by the designer of class \cc{StreamBuilder} making sure that all overloaded variants of
  of \cc{append} return their receiver.

\begin{wrapfigure}[8]{r}{44ex}
  \caption{\label{Figure:chaining}%
    Method chaining onto an object of class \cc{StreamBuilder}.
  }
  \begin{lcode}[minipage,width=\linewidth]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  StringBuilder sb = new StringBuilder();
    return sb
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}\end{lcode}
\end{wrapfigure}

Now, definition found in the web of the term \emph{fluent API†{API =
    \textbf Application \textbf Program \textbf Interface
}} are a bit illusive.
Invariably, such definitions liken fluent API to method chaining;
  they also tend to emphasize that fluent API is ‟more” than method
  chaining, and ask the reader to extrapolate from one term to the other.

The distinction between the two terms is the identity of the receiver.
In method chaining, all methods are invoked on the same object, whereas in fluent API
  the receiver of each method in the chain may be arbitrary.
Perhaps surprisingly, this difference makes fluent API more expressive.
Consider, for example, the following JAVA fragment (drawn from JMock~\cite{Freeman:Pryce:06})
\begin{JAVA}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{JAVA}
Let the return type of function \cc{allowing} be denoted by~$τ₁$ and let the
  return type of function \cc{method} be denoted by~$τ₂$.
Then, the fact that~$τ₁≠τ₂$ means that the set of methods that can be placed after the dot
  in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).
\end{JAVA}
is distinct from the set of methods that can be placed after the dot in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).method("get.*").
\end{JAVA}
This distinction makes it possible to design expressive and rich fluent APIs, in which a
  sequence ‟chained” calls is not only readable, but also robust, in the sense that the
  sequence is type correct, only when it the sequence makes sense semantically.

\subsection{Fluent API and the Type Safe Toilette Seat}

An object of type toilette seat is created in the \cc{down} state, but it can
then be \cc{raise}d to the \cc{up} state, and then be \cc{lower}ed to the
\cc{down} state.†{%
  This example is inspired by earlier work of
  Richard Harter on the topic~\cite{Harter:05}.
}
Such an object be used by two kinds of users, \cc{male}s and \cc{female}s, for two distinct purposes:
  \cc{urinate} and \cc{defecate}.
Now a good fluent API design is one by which the sequences of method calls in
  \cref{Figure:toilette:legal} are type correct.

\begin{figure}[htbp]
  \begin{JAVA}
new Seat().male().raise().urinate();
new Seat().female().urinate();\end{JAVA}
  \caption{Legal sequences of calls in the toilette seat example}
  \label{Figure:toilette:legal}
\end{figure}

Conversely, sequences of method calls made in \cref{Figure:toilette:illegal}
  should be illegal in the desired implementation of the fluent API.

\begin{figure}[htbp]
  \begin{JAVA}
new Seat().female().raise();
new Seat().male().raise().defecate();
new Seat().male().male();
new Seat().male().raise().urinate().female().urinate();\end{JAVA}
  \caption{Illegal sequences of calls in the toilette seat example}
  \label{Figure:toilette:illegal}
\end{figure}
It should be clear that the type checking engine of the compiler can
be employed to distinguish between legal and illegal sequences.
It should also be clear that fabricating the \kk{class}es, \kk{interface}s
and the \kk{extends} and \kk{implements} relationships between these, is
far from being trivial.

\subsection{What is fluent API?}

\subsection{Context Free Languages and Pushdown Automata: Reminder and Terminology}
Each of the notions discussed here is probably common knowledge
(see e.g.,~\cite{Hopcroft:book:2001,must be others}).
The purpose here is to set a common vocabulary. 

Let~$Σ$ be a finite alphabet of \emph{terminals} (often called input symbols).
A \emph{language} over $Σ$
  is a subset of~$Σ^*$ (the set of all strings, including the empty string,
whose characters are drawn from~$Σ$).
Keep~$Σ$ implicit henceforth.

A \emph{\textbf Context-\textbf Free \textbf Grammar}(CFG) is a formal description of a language.
A CFG~$G$ has three components:~$Ξ$,
a set of \emph{variables} (also called nonterminals), a unique \emph{start variable}~$ξ∈Ξ$, and
  a finite set of (production) \emph{rules}.
A rule~$r∈G$ describes the derivation of a variable~$ξ∈Ξ$ into
  a string of \emph{symbols}, where symbols are either terminals or variables.
Accordingly,~$r$ is written in the form~$r=ξ→β$, where~$β∈\left(Σ∪Ξ\right)^*$.
This description is often called BNF.

The \emph{language} of a CFG is the set of strings of terminals (and terminals only)
  that can be derived from the start symbol, following any sequence of applications of the rules.
CFG languages include regular languages, and are contained in the set
  of ‟context-sensitive” languages.

An LR(1) parser for a grammar~$G$ has three components:
\begin{description}
  \item[An automaton] whose states are~$Q=❴q₀,…,qₙ❵$
  \item[A stack] which may contain any member of~$Q$.
  \item[Specification of state transition] with the aid of two tables:
        \begin{description}
          \item[Goto table] which defines a partial function~$δ:Q⨉Ξ↛Q$ of transitions
          between the states of the automaton.
          \item[Action table] which
            defines a partial function\[η:Q⨉Σ↛ ❴ \textsf{Shift}(q) \,|\, q∈Q❵ ∪ ❴\textsf{Reduce}(r) \,| \, r∈G❵.\]
        \end{description}
\end{description}
The parser begins by pushing~$q₀$ (the initial state) into the stack,
and then repetitively executes the following:
Examine~$q∈Q$, the state at the top of the stack.
If~$q=qₙ$ (the accepting state), then the parser stops in accepting the input.
Let~$σ∈Σ$ be the next input symbol.
If~$η(q,σ)=⊥$, the parser stops in rejecting the input.
If~$η(q',σ) = \textsf{Shift}(q')$, the parser pushes state~$q'$ into the stack.
If however,~$a(q,σ) = \textsf{Reduce}(r)$,
where~$r=ξ→β$,
the parser pops~$|β|$ stack symbols from the stack.
Let~$q'$ be the state at the top of the stack after these pops.
The parser then pops~$q'$, the new state it reached,
  and pushes instead a state,~$q”$, defined by applying the transition function on~$ξ$, the variable just discovered and~$q'$ , i.e.,~$q”=δ(q',ξ)$.

\begin{Definition}[Deterministinc Pushdown Automaton]
  \label{Definition:DPDA}
  A \emph{deterministic pushdown automaton} (DPDA),~$M$, is an 8-tuple
  \[
    M =⟨Q,Σ,Γ, q₀,⊥, A,δ,η⟩
  \]
  where~$Q$ is a finite set of
  \emph{the states of~$M$},~$Σ$ is a finite
  \emph{set of input symbols},~$Γ$ is a finite
  \emph{set of stack symbols},~$q₀∈Q$ is the initial state,~$⊥∈Γ$
  is a \emph{special symbol designating the bottom of the stack}
  and~$A⊆Q$ is the \emph{set of accepting states} while~$δ$ and~$η$ are
  the \emph{partial functions of state transition}
  \[
    \begin{array}{crlc}
      δ: & Q⨉Σ⨉Γ &↛& Q⨉Γ^*⏎
      η: & Q⨉Γ &↛& Q⨉Γ^*,⏎
    \end{array}
  \]
\end{Definition}



\paragraph{Pushdown Automaton}
A \emph{pushdown automaton}(PDA) is an model machine, consisting a non-deterministic state machine
  and a stack.
The non-determinism of the state machine is expressed by the fact that the transition function
  is non-deterministic, meaning that a single mapping results in a set of results, instead of one.
The stack can hold an unbounded number of stack symbols, as a consequence, informally,
  this model can ‟remember” arbitrary amount of information, with the inherent FIFO restriction
  of a stack.
The language accepted by a PDA is defined by the set of words the PDA accepts on
  (via empty stack or accepting states).
An important result is, the equivalence of PDA's and CFG's expressiveness, in a sense that
  the set of languages that CFGs can define is equivalent to the set of languages that can be
  accepted by a pushdown automaton.
\paragraph{Deterministic PDA and Deterministic CFL}
Informally, the difference between a deterministic and non-deterministic PDA resides in the
  the transition function.
While the latter defined to return a set of results, the former returns a single result.
The DPDA languages are strictly stronger than regular languages, and strictly weaker than
  general CFL.
Deterministic CFL can be defined by the set of languages that D-PDA accept.
This is an interesting class because as we will prove, the \Java compiler can determine,
  given a D-CFG and a word in the corresponding alphabet, whether the word is in the
  grammar's language, or not.
\paragraph{LR($k$)}
The class of LR($k$) grammars are well known for their role in theory of compilation~\cite{Aho:86}
In terms of expressiveness, Knuth~\cite{Knuth:65} proved that for every~$k>0$ the set of languages
  that LR($k$) parsers can parse is equal to D-CFL.
LR($k$) parsers will be discussed in detail, at~\cref{Section:algorithm}.
\paragraph{LL{$*$}}
In order to see the full picture of the expressiveness of the discussed classes, we will only
  only mention the LL($*$) class and it's expressiveness. The LL($*$)~\cite{Parr:2011} class does not contain,
  and neither contained by any of the LR($k$) grammar classes, in addition, LL($*$) can also
  parser some context-sensitive grammars.

\Cref{Figure:expressiveness} is a visualization of the discussed grammar's hierarchy.

\begin{wrapfigure}{r}{0.6\linewidth}
  \caption{ \label{Figure:expressiveness}
  Hierarchy of CFGs and pushdown automata}
  \input ../Figures/expressiveness-diagram.tikz
\end{wrapfigure}
