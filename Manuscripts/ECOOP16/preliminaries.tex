\subsection{Method Chaining \emph{vs.} Fluent API}
The pattern ‟invoke function on \cc{sb}” occurs
  six times in the code in \cref{Figure:non-chaining}.

\begin{wrapfigure}[10]{r}{44ex}
  \caption{\label{Figure:non-chaining}%
    Recurring invocations of the pattern ‟invoke function on the same
      receiver”.
  }
  \begin{lcode}[minipage,width=\linewidth]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  StringBuilder sb = new StringBuilder();
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString();
}\end{lcode}
\end{wrapfigure}

Some languages, e.g., \Smalltalk offer syntactic sugar, called \emph{method cascading}, for this pattern.
Method chaining is a ‟programmer made” syntactic sugar for this pattern:
  If a method~$f$ returns its receiver, i.e., \kk{this},
  then, instead of the series of two commands \mbox{\cc{o.$f$(); o.$g$();}}, clients can write
  only one command \mbox{\cc{o.$f()$.$g$();}}.
\cref{Figure:chaining} is the method chaining
  (also, shorter and arguably clearer) version of
  \cref{Figure:non-chaining}.
It is made possible by the designer of class \cc{StreamBuilder} making sure that all overloaded variants of
  of \cc{append} return their receiver.

\begin{wrapfigure}[8]{r}{44ex}
  \caption{\label{Figure:chaining}%
    Method chaining onto an object of class \cc{StreamBuilder}.
  }
  \begin{lcode}[minipage,width=\linewidth]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  StringBuilder sb = new StringBuilder();
    return sb
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}\end{lcode}
\end{wrapfigure}

Now, definition found in the web of the term \emph{fluent API†{API =
    \textbf Application \textbf Program \textbf Interface
}} are a bit illusive.
Invariably, such definitions liken fluent API to method chaining;
  they also tend to emphasize that fluent API is ‟more” than method
  chaining, and ask the reader to extrapolate from one term to the other.

The distinction between the two terms is the identity of the receiver.
In method chaining, all methods are invoked on the same object, whereas in fluent API
  the receiver of each method in the chain may be arbitrary.
Perhaps surprisingly, this difference makes fluent API more expressive.
Consider, for example, the following JAVA fragment (drawn from JMock~\cite{Freeman:Pryce:06})
\begin{JAVA}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{JAVA}
Let the return type of function \cc{allowing} be denoted by~$τ₁$ and let the
  return type of function \cc{method} be denoted by~$τ₂$.
Then, the fact that~$τ₁≠τ₂$ means that the set of methods that can be placed after the dot
  in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).
\end{JAVA}
is distinct from the set of methods that can be placed after the dot in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).method("get.*").
\end{JAVA}
This distinction makes it possible to design expressive and rich fluent APIs, in which a
  sequence ‟chained” calls is not only readable, but also robust, in the sense that the
  sequence is type correct, only when it the sequence makes sense semantically.

\subsection{Fluent API and the Type Safe Toilette Seat}

An object of type toilette seat is created in the \cc{down} state, but it can
then be \cc{raise}d to the \cc{up} state, and then be \cc{lower}ed to the
\cc{down} state.†{%
  This example is inspired by earlier work of
  Richard Harter on the topic~\cite{Harter:05}.
}
Such an object be used by two kinds of users, \cc{male}s and \cc{female}s, for two distinct purposes:
  \cc{urinate} and \cc{defecate}.
Now a good fluent API design is one by which the sequences of method calls in
  \cref{Figure:toilette:legal} are type correct.

\begin{figure}[htbp]
  \begin{JAVA}
new Seat().male().raise().urinate();
new Seat().female().urinate();\end{JAVA}
  \caption{Legal sequences of calls in the toilette seat example}
  \label{Figure:toilette:legal}
\end{figure}

Conversely, sequences of method calls made in \cref{Figure:toilette:illegal}
  should be illegal in the desired implementation of the fluent API.

\begin{figure}[htbp]
  \begin{JAVA}
new Seat().female().raise();
new Seat().male().raise().defecate();
new Seat().male().male();
new Seat().male().raise().urinate().female().urinate();\end{JAVA}
  \caption{Illegal sequences of calls in the toilette seat example}
  \label{Figure:toilette:illegal}
\end{figure}
It should be clear that the type checking engine of the compiler can
be employed to distinguish between legal and illegal sequences.
It should also be clear that fabricating the \kk{class}es, \kk{interface}s
and the \kk{extends} and \kk{implements} relationships between these, is
far from being trivial.

\subsection{Type State}
The toilette seat problem may be amusing to some, but it is not contrived in
any way. In fact, there is huge body of research on the general topics of
\emph{type-states}. (See e.g., review articles such
as~\cite{Aldrich:Sunshine:2009,Bierhoff:Aldrich:2005}) Informally, an object
that belongs to a certain type (\kk{class} in the object oriented lingo), has
type-states, if not all methods defined in this object's class are applicable
to the object in all states it may be in.

A classical example of type-states is a file object: which can be in one of two
states: ‟open” or ‟closed”. Invoking a \cc{read()} method on the object is only
permitted when the file is in an ‟open” state. In addition, method \cc{open()}
(respectively \cc{close()}) can only be applied if the object is in the
‟closed” (respectively, ‟open”) state.

Objects with type states such as toilette seats and files are not rarities.
In fact, a recent study~\cite{Beckman:2011} estimates
  that about 7.2％ of \Java classes define protocols, that can be interpreted as type-state.
Type-state pose two main challenges to software engineering
\begin{enumerate}
  \item \emph{\textbf{Identification.}}
    In the typical case, type-state
        receive little to no mention at all in the documentation.
    The identification problem is to find the implicit
    type state in existing JAVA: Given an implementation of a class
    (or more generally of a software framework),
    \emph{determine} which sequences of method calls are valid and which violate the
    type state hidden in the JAVA.
  \item \emph{\textbf{Maintenance and Enforcement.}}
    Having identified the type-states, the challenge is in automatically flagging out
      illegal sequence of calls that does not conform
      with the type-state, furthermore, with the
      evolution of an API, the challenge is in updating the type-state information,
      and the type checking of JAVA of clients.
\end{enumerate}

\subsection{What is fluent API?}

\subsection{Context Free Languages and Pushdown Automata}
To conclude this section, we will cover some formal
  constructs that will be prompted in the remind of this manuscript.
  For a more extensive read of formal definitions and properties
  of these constructs, consult J. Hopcroft et al.~\footnote{Hopcroft:book:2001}
  
\paragraph{Context Free Grammar}
A \emph{Context Free Grammar}(CFG) is a formal grammatical description of a language,
  composed of four components: A finite set of input symbols, also referred to as terminals,
  a finite set of abstract symbols, referred to as nonterminals, a start symbol from the 
  nonterminal set, and a set of productions, sometimes referred to as rules. 
A production is constructed from a nonterminal known as left-hand side and a 
  string of terminals and nonterminal called right-hand side.
The language of a context free grammar, is defined by the set of terminal strings 
  that can be derived from the start symbol, through the various nonterminals.
\paragraph{Context Free Language}
Language~$\mathcal{L}$ is said to be a \emph{Context Free Language}(CFL), if there
  is a \emph{Context Free Grammar}~$G$ such that,~$L(G)=\mathcal{L}$.
The context free languages set, contains the regular languages, 
  is contained in the recursively enumerable set, and the context-sensitive languages set.
A classic example of a language that is CF and not a regular, 
  is the language~${a^nb^n|n\in\mathbb{N}}$ over the alphabet~$\Sigma={a,b}$,
  while the analogous language~${a^nb^nc^n|n\in\mathbb{N}}$ is context-sensitive 
  and not context-free over the same~$\Sigma$.
A CFL can be defined using BNF, which is also an important and widespread tool for 
  defining programming languages.
\paragraph{Pushdown Automaton}
A \emph{pushdown automaton}(PDA) is an model machine, consisting a non-deterministic state machine
  and a stack. 
The non-determinism of the state machine is expressed by the fact that the transition function
  is non-deterministic, meaning that a single mapping results in a set of results, instead of one.
The stack can hold an unbounded number of stack symbols, as a consequence, informally, 
  this model can ``remember'' arbitrary amount of information, with the inherent FIFO restriction 
  of a stack.
The language accepted by a PDA is defined by the set of words the PDA accepts on 
  (via empty stack or accepting states).
An important result is, the equivalence of PDA's and CFG's expressiveness, in a sense that
  the set of languages that CFGs can define is equivalent to the set of languages that can be
  accepted by a pushdown automaton.
\paragraph{Deterministic PDA and Deterministic CFL}
Informally, the difference between a deterministic and non-deterministic PDA resides in the
  the transition function. 
While the latter defined to return a set of results, the former returns a single result.
The DPDA languages are strictly stronger than regular languages, and strictly weaker than
  general CFL.
Deterministic CFL can be defined by the set of languages that D-PDA accept.
This is an interesting class because 
\paragraph{LR($k$)}
\begin{wrapfigure}r{0.5\linewidth}
  \caption{Hierarchy of CFGs and pushdown automata}
  \input ../Figures/expressiveness-diagram.tikz
\end{wrapfigure}
