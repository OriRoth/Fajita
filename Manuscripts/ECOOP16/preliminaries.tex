\subsection{Method Chaining \emph{vs.} Fluent API: Reminder and Terminology}
The pattern ‟invoke function on variable \cc{sb}”, specifically with
  a function named \cc{append}, occurs six times in the code in \cref{Figure:chaining}(a), designed
  to format a clock reading, given as integers hours, minutes and
  seconds.

\begin{figure}[H]
  \caption{\label{Figure:chaining}%
    Recurring invocations of the pattern ‟invoke function on the same
      receiver”, before, and after method chaining.
  }%
    \begin{tabular}{@{}cc@{}}%
  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  final StringBuilder sb = new StringBuilder();
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString();
}\end{lcode}
\hfill
&
\hspace{1ex}
  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}\end{lcode}
⏎
\textbf{(a)} before & \textbf{(b)} after
\end{tabular}
\end{figure}

Some languages, e.g., \Smalltalk offer syntactic sugar, called \emph{cascading}, 
  for abbreviating this pattern.
\emph{Method chaining} is a ‟programmer made” syntactic sugar serving the same purpose:
  If a method~$f$ returns its receiver, i.e., \kk{this},
  then, instead of the series of two commands: \mbox{\cc{o.$f$(); o.$g$();}}, clients can write
  only one: \mbox{\cc{o.$f$().$g$();}}.
  \cref{Figure:chaining}(b) is the method chaining
  (also, shorter and arguably clearer) version of
  \cref{Figure:chaining}(a).
It is made possible thanks to the designer of class \cc{StringBuilder} ensuring that all overloaded variants of
  of \cc{append} return their receiver.

The distinction between \emph{fluent API} and method chaining is the identity of the receiver:
In method chaining, all methods are invoked on the same object, whereas in fluent API
  the receiver of each method in the chain may be arbitrary.
Fluent API are more interesting for this reason.
Consider, for example, the following \Java fragment (drawn from JMock~\cite{Freeman:Pryce:06})
\begin{JAVA}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{JAVA}
Let the return type of function \cc{allowing} be denoted by~$τ₁$ and let the
  return type of function \cc{method} be denoted by~$τ₂$.
Then, the fact that~$τ₁≠τ₂$ means that the set of methods that can be placed after the dot
  in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).
\end{JAVA}
is distinct from the set of methods that can be placed after the dot in the partial call chain
\begin{JAVA}
allowing(any(Object.class)).method("get.*").
\end{JAVA}
This distinction makes it possible to design expressive and rich fluent APIs, in which a
  sequence ‟chained” calls is not only readable, but also robust, in the sense that the
  sequence is type correct only when it the sequence makes sense semantically.

\subsection{Context Free Languages and Pushdown Automata: Reminder and Terminology}
Each of the notions discussed here is probably common knowledge
 (see e.g.,~\cite{Hopcroft:book:2001,Linz:2001} for a text book description, 
 or~\cite{Autebert:97} for a systematic review).
The purpose here is to set a unifying common vocabulary.

Let~$Σ$ be a finite alphabet of \emph{terminals} (often called input characters or tokens).
A \emph{language} over~$Σ$
  is a subset of~$Σ^*$.
Keep~$Σ$ implicit henceforth.

A \emph{\textbf Nondeterministic \textbf Pushdown \textbf Automaton} (NPDA) is a device for language recognition,
  made of a nondeterministic finite automaton
  and a stack of unbounded depth of stack elements.
An NPDA begins execution with a single copy of the initial stack element on the stack.
In each step, the NPDA
  examines the next input token,
  the state of the automaton,
  and the top of the stack.
It then pops the top element from the stack, and nondeterministically chooses which actions of
  its transition function to perform:
  Consuming the next input token,
  moving to a new state,
  or, pushing stack elements to the stack.
Nondeterminism effectively means
  that any combination of these actions can be done.

The language recognized by an NPDA is the set of strings that it accepts,
  either by reaching an accepting state or by encountering an empty stack.

A \emph{\textbf Context-\textbf Free \textbf Grammar}(CFG) is a formal description of a language.
A CFG~$G$ has three components:~$Ξ$ a set of \emph{variables} (also called nonterminals),
  a unique \emph{start variable}~$ξ∈Ξ$, and a finite set of (production) \emph{rules}.
A rule~$r∈G$ describes the derivation of a variable~$ξ∈Ξ$ into
  a string of \emph{symbols}, where symbols are either terminals or variables.
Accordingly, rule~$r∈G$ is written as~$r=ξ→β$, where~$β∈\left(Σ∪Ξ\right)^*$.
This description is often called BNF\@.
The \emph{language} of a CFG is the set of strings of terminals (and terminals only)
  that can be derived from the start symbol, following any sequence of applications of the rules.
CFG languages include regular languages, and are strictly contained in the set
  of ‟context-sensitive” languages.

The expressive power of NPDAs and BNFs is the same:
  For every language defined by a BNF, there exists an NPDA that recognizes it.
Conversely, there is a BNF definition for any language recognized by some NPDA.

NPDAs run in exponential deterministic time.
Since our encoding surely will be deterministic, we need a simpler
  model, that runs in polynomial deterministic time.

\begin{Definition}[Deterministic Pushdown Automaton]
  \label{Definition:DPDA}
  \slshape
  A \emph{deterministic pushdown automaton} (DPDA) is a quintuple~$⟨Q,Γ,q₀,A,δ⟩$
  where~$Q$ is a finite set of
    \emph{states},~$Γ$ is a finite
  \emph{set of stack elements},~$q₀∈Q$ is the initial state,
  and~$A⊆Q$ is the \emph{set of accepting states} while~$δ$ is
  the \emph{partial state transition function}~$δ:Q⨉Γ⨉(Σ∪❴ε❵)↛Q⨉Γ^*$.
  \par
  A DPDA begins its work in the initial state with a single designated stack element residing on the stack.
  At each step, the automaton examines:~$σ$, the next input token, the current state~$q∈Q$, and the element~$γ∈Γ$ at the top of the stack. Based on the values of these, it decides how to proceed:
  \par
  If~$γ$ is undefined, i.e., the stack is empty, the DPDA accepts the input and halts.
  The same happens if~$q∈A$.
  \par
  Suppose that~$δ(q,γ,ε)≠⊥$ (in this case, the definition of a DPDA requires that~$δ(q,γ,a')=⊥$ for all~$σ'∈Σ$),
  and let~$δ(q,γ,ε)=(q',ζ)$.
  Then the automaton pops~$γ$
  and pushes the string of stack elements~$ζ∈Γ^*$ into the stack.
  If~$δ(q,γ,a)=(q',ζ)$, then the same happens, but the
  automaton also irrevocably consumes the token~$σ$.
  \par
  If~$δ(q,γ,ε)=δ(q,γ,a)=⊥$ the automaton rejects the input and stops.
\end{Definition}

As mentioned above, NPDA languages are the same as CFG languages.
It is convenient to speak also of DCFG languages, the \emph{deterministic context-free grammar} languages,
which are those context-free languages that are recognizable by a DPDA.

DCFG languages are a strict container of regular languages,
  and are strictly contained in CFG languages.
On the other hand, DPDA are easier to parse:
  Recognition of a DPDA language
  can be done in linear time and one pass.
  In contrast, CYK, one of the best algorithms for recognizing NPDA languages run in super-quadratic time~\cite{Younger:1967,Cocke:1969,Earley:1970}.

\begin{Definition}
  \label{Definition:realtime}
  \slshape
We say a DPDA supplies the \emph{realtime condition} if
  for all~$q∈Q$,~$γ∈Γ$ :~$δ(q,γ,ε)=⊥$ (i.e., undefined).
\end{Definition}

The last construct we remind, is the less known \emph{Simple Jump Deterministic Pushdown Automaton},
the definition relies on Olsder's jump-DPDA supplying condition (S)~\cite{Olsder:05}.

\begin{Definition}[Simple-Jump Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \emph{simple-jump deterministic pushdown automaton} (jump-DPDA) is a quintuple~$⟨Q,Γ,q₀,A,δ⟩$
  where~$Q,Γ,q₀,A$ are exactly as in~\cref{Definition:DPDA},
  and~$δ$ is the
  \emph{partial state transition function}~$δ:Q⨉Γ⨉(Σ∪❴ε❵)↛(Q⨉Γ^*)∪(Q⨉❴E❵⨉Γ)$
  (E is a special symbol which means ‟erase”).
  \par
  A jump-DPDA begins its work like a general DPDA\@.
  \par
  Let~$σ$ be in~$Σ∪❴ε❵$,~$q∈Q$ the current state, and~$γ∈Γ$ be the top of the stack.
  If~$δ(q,γ,σ)=(q,ζ)$ then it acts as a DPDA\@.
  If~$δ(q,γ,σ)=(q,E,γ')$ then as in a DPDA,~$γ$ is popped, and the automaton
  moves to state~$q$, but in addition, stack elements are popped until
  popping a single~$γ'$.
  If there is no~$γ'$ in the stack, the result is undefined.
  \par
  If~$γ$ is undefined, i.e., the stack is empty, the automaton accepts the input and halts.
  The same happens if~$q∈A$.
  \par
  If~$δ(q,γ,ε)=δ(q,γ,a)=⊥$ the automaton rejects the input and stops.
\end{Definition}

A realtime simple-jump deterministic pushdown automaton is a jump-DPDA
  as defined in~\cref{Definition:JDPDA}
  that supplies~\cref{Definition:realtime}.

\subsection{Fluent APIs realizing Deterministic Context Free Grammars}
The following definition is pertinent.
Let~$\textsf{java}$ be a function that translates a terminal~$σ∈Σ$
into a call to a uniquely named function (with respect to~$σ$).
Let~$\textsf{java}(α)$, be the function
  that translates a string~$α∈Σ^*$ into a fluent API call chain.
If~$α=σ₁⋯σₙ∈Σ^*$, then⏎
  \mbox{\qquad\qquad}$\textsf{java}(α)=$~\cc{.}$\textsf{java}(σ₁)$\cc{().}~$⋯$~\cc{.}$\textsf{java}(σₙ)$\cc{()}⏎
For~$Σ=❴a,b,c❵$ we can define~$\textsf{java}(a)=\cc{a}$,~$\textsf{java}(b)=\cc{b}$, and,~$\textsf{java}(c)=\cc{c}$.
With these definitions,~$\textsf{java}(caba) = \cc{.c().a().b().a()}$.

\begin{theorem}\label{Theorem:Gil-Levy}
  Let~$D$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_D$ for types~\cc{L},~\cc{D} and other types with the following
  property: Consider the \Java command
  \[
    \cc{L_= M.build~$\textsf{java}(α)$}\cc{.\$()};
  \]
  (in words: starting from the \kk{static} field of \kk{class}~\cc{M},
  apply the sequence of call chain~$\textsf{java}(α)$, terminate with a call to the
  end symbol~\cc{\$()} and then assign to newly declared variable~‟\cc{\_}” of type~\cc{L}).
  Then, this command type checks against~$J_M$ if an only if~$α∈L$.
  Furthermore, program~$J_M$ can be effectively generated from~$M$.
\end{theorem}
