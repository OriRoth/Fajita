The thesis propounded by this research is that API design, and especially fluent API design
  can and should be made in terms of language design.
Software missionaries and preachers such as Fowler~\cite{Fowler:2005} have long claimed
  that API design resembles the design of a \textbf Domain \textbf Specific \textbf Language
  (henceforth \emph{DSL}, see, e.g.,~\cite{VanDeursen:Klint:2000,Hudak:1997,Fowler:2010} for review articles).
   In the words of Fowler ‟The difference between API design and DSL design is then rather small”~\cite{Fowler:2005}

Another objective of this research is
  to let the unification of the notions of DSL and (fluent) API
  design become tighter in this sense:
  With \Self, the design of a fluent API framework,
    is solely in terms of the grammar for the DSL
    that defines this fluent API\@.
This grammar specification is then automatically translated
  to an implementation of the fluent API that this DSL defines. 
This translation generates the intricate type hierarchy
  and methods of types in it in such a way
  that only sequence of calls that conform
  to the specification would
  compile correctly (concretely, type-check).


\subsection{Toilette Seat and Type States}

  To illustrate, consider the toilette seat example.
In this example,
  there are a total of six methods that might be invoked.
\begin{quote}
  \begin{tabular}{lll}
    \cc{male()} & \cc{raise()} & \cc{urinate()}⏎
    \cc{female()} & \cc{lower()} & \cc{defecate()}⏎
  \end{tabular}
\end{quote}
A fluent API design specifies the order in which such calls can be made.

The \emph{first} novelty in this research is that the fluent API definition is
  through a CFG, written as a BNF.
\cref{Figure:BNF} is such a specification for the toilette seat problem.

\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<Visitors>         & ::= \<Down-Visitors> \hfill⏎
      \<Down-Visitors>    & ::= \<Down-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| \<Raising-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitors>      & ::= \<Up-Visitor> \~\<Up-Visitors> \hfill⏎
      {}                  & \| \<Lowering-Visitor> \~\<Down-Visitors> \hfill⏎
      {}                  & \| ε \hfill⏎
      \<Up-Visitor>       & ::= \cc{male()} \~\cc{urinate()} \hfill⏎
      \<Down-Visitor>     & ::= \cc{female()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \cc{defecate()} \hfill⏎
      \<Raising-Visitor>  & ::= \cc{male()} \~\cc{raise()} \~\cc{urinate()} \hfill⏎
      \<Lowering-Visitor> & ::= \cc{female()} \~\cc{lower()} \~\<Action> \hfill⏎
                          & \| \cc{male()} \~\cc{lower()} \cc{defecate()} \hfill⏎
      \<Activity>         & ::= \cc{urinate()} \hfill⏎
                          & \| \cc{defecate()} \hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for the toilette seat problem}
  \label{Figure:BNF}
\end{figure}

\Self takes this grammar specification as input, and in response
  generates the corresponding
  \Java type hierarchy.

\subsection{Verbs and Nouns}
A second novelty of \Self is that the specification of a BNF such as in 
  \cref{Figure:BNF} can be also made with a \Java fluent API\@.
To do so, it is first necessary to
  define the set of \emph{grammar terminals}
  \begin{JAVA}
enum ToiletteTerminals implements Terminal {¢¢
  male, female,
  urinate, defecate,
  lower, raise;
}
\end{JAVA}
As common in fluent APIs we shall refer to these
as \emph{verbs}†{Admittedly, the words ‟male” and ‟female” are nouns. 
  An excuse might be that the words are used as nouns to mean ‟male-visit” and ‟female-visit”.}.
Verbs are translated by \Self into methods.

We are also required to define the set of \emph{grammar variables}
\begin{JAVA}
enum ToiletteVariables implements Variable {¢¢
  Visitors, Down_Visitors, Up_Visitors,
  Up_Visitor, Down_Visitor,
  Lowering_Visitor, Raising_Visitor,
  Activity
};
\end{JAVA}
  We shall use the term ‟\emph{noun}” as synonymous to ``variable''.

\subsection{Words and Grammar}
The terms ‟symbol” and ‟word” refer to an entity which is either
  a verb or a noun.

Once the verbs and the nouns are set, the grammar can be defined,
  using a fluent API generated by \Self itself as shown
  in \cref{Figure:fluent}.

\begin{figure}[H]
  \begin{JAVA}[style=numbered]
new BNF()
  ¢¢.with(ToiletteTerminals.class)
  ¢¢.with(ToiletteSymbols.class)
  ¢¢.start(Visitors)
  ¢¢.derive(Visitors).to(Down_Visitors)
  ¢¢.derive(Down_Visitors)
    ¢¢.to(Down_Visitor).and(Down_Visitors)
    ¢¢.or(Raising_Visitor).and(Up_Visitors)
    ¢¢.orNone()
  ¢¢.derive(Up_Visitors)
    ¢¢.to(Up_Visitor).and(Up_Visitors)
    ¢¢.or(Lowering_Visitor).and(Down_Visitors)
    ¢¢.orNone()
  ¢¢.derive(Up_Visitor).to(male).and(urinate)
  ¢¢.derive(Down_Visitor)
    ¢¢.to(female).and(Action)
    ¢¢.or(male).and(defecate)
  ¢¢.derive(Raising_Visitor).to(male).and(raise).and(urinate)
  ¢¢.derive(Lowering_Visitor)
    ¢¢.to(female).and(lower).and(Action)
    ¢¢.or(male).and(lower).and(defecate)
  ¢¢.derive(Activity)
    ¢¢.to(urinate)
    ¢¢.or(defecate)
  ¢¢.go();
  \end{JAVA}
  \caption{A BNF grammar for the toilette seat problem}
  \label{Figure:fluent}
\end{figure}

The call to function \cc{go()} (last line in \cref{Figure:fluent}) instructs
  \Self to generate the JAVA for the fluent API specified by the
  subsequent part of the expression.
Roughly speaking, nouns are translated to classes while verbs are translated to methods which
  take no parameters.
Two exceptions apply:
\begin{enumerate}
  \item 
    Library classes such as \cc{String} and \cc{Integer}, just as user-defined
    classes such as \cc{Invoice} may be used as nouns. 
    \Self generate class definitions only for classes whose name is declared 
    in an \kk{enum} which is passed to \cc{with} verb in the BNF declaration.
  \item Verbs may take noun parameters, as explained below.
\end{enumerate}
