As should be obvious from \cref{Figure:fluent}, \Self will be implemented
  in a bootstrapping fashion.
The specification of a BNF, is made itself using a fluent API.

This section describes how this is achieved.

\subsection{Reflective BNF}
\cref{Figure:BNF:BNF} is a \emph{reflective BNF}:
It uses the notation introduced in \cref{Figure:BNF}
  to specify this same notation.

\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<BNF>                     & ::= \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header>                  & ::= \<Variables> \~\<Terminals> \hfill⏎
      {}                         & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables>               & ::= \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals>               & ::= \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body>                    & ::= \<Start> \~\<Rules> \hfill⏎
      \<Start>                   & ::= \cc{start(\<Variable>)} \hfill⏎
      \<Rules>                   & ::= \<Rule> \~\<Rules>\hfill⏎
      {}                         & \| \<Rule> \hfill⏎
      \<Rule>                    & ::= \cc{derives(\<Variable>)} \<Conjunctions>\hfill⏎
      \<Conjunctions>            & ::= \<First-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      \<First-Conjunction>       & ::= \cc{to(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                         & \| \cc{toNone()}\hfill⏎
      \<Extra-Conjunctions> & ::= \<Extra-Conjunction>\~\<Extra-Conjunctions>\hfill⏎
      {}                         & \| ε\hfill⏎
      \<Extra-Conjunction>  & ::= \cc{or(\<Symbol>)}\~\<Symbol-Sequence>\hfill⏎
      {}                         & \| \cc{orNone()} \hfill⏎
      \<Symbol-Sequence>         & ::= ε \hfill⏎
      {}                         & \| \cc{and(\<Symbol>)}\~\<Symbol-Sequence> \hfill⏎
      \<Symbol>                  & ::= \cc{Variable} \hfill⏎
      {}                         & \| \<Verb>\hfill⏎
      {}                         & \| \<Verb> \cc{,} \<Noun> \hfill⏎
      \<Noun>                    & ::= \<Variable> \hfill⏎
      {}                         & \| \<Existing-Class> \hfill⏎
      \<Variable>                & ::= \cc{Variable} \hfill⏎
      \<Footer>                  & ::= \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{Figure:BNF:BNF}
\end{figure}
% this is not a formal BNF because <Symbol> and <Variable> are not defined in the Symbols set.
\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
Note that this specification can only be approximate;
the figure uses verbs as replacement to indentation,
and special symbols such as~$|$,~$::-$ and~$ε$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{comment}

From \cref{Figure:BNF:BNF} we learn
  that a BNF has three components: header, body and footer.
  \begin{enumerate}
    \item The sets of terminals and variables are defined in the header part.
    \item The body starts with a definition of the start symbol, followed by a list of derivation
  rules.
\item The footer is simply the verb \cc{go()} which instructs \Self
  to generate the JAVA that realizes the fluent API specified by the grammar.
  \end{enumerate}

A derivation rule starts with a variable, and is then followed by disjunctive alternatives.

The choice of verbs that may occur in, and between, these alternatives not incidental;
  fluency was in mind:
\begin{description}
  \item[\cc{to}] to introduce the first symbol in the first conjunction.
  \item[\cc{or}] to introduce the first symbol in each subsequent conjunction.
  \item[\cc{and}] to introduce all but the first symbol in each such conjunction.
  \item[\cc{toNone}] to declare that the first conjunction is empty.
  \item[\cc{orNone}] to declare any subsequent conjunction is empty.
\end{description}

\subsection{Reflective BNF of fluent API}

To translate \cref{Figure:BNF:BNF} into a fluent
API chain, the verbs and nouns must be defined.

Verb definitions are made in the JAVA excerpt in
\cref{Figure:Verbs}.

\begin{figure}[htb]
  \begin{JAVA}[style=JAVA]
enum BNFTerminals implements Terminal {¢¢
  toNone,orNone,go,// No parameters
  start,derive     // One parameter
  with,            // One parameter, overloaded
  or,and,to,       // One parameter (or more), overloaded, variadic
  ;
}\end{JAVA}
  \caption{The verbs of \Self}
  \label{Figure:Verbs}
\end{figure}
Each of the enumerands in the figure is destined to be a
  name of a method in a class to be generated by \Self.

Noun definitions are made in the JAVA excerpt in \cref{Figure:Nouns}.

\begin{figure}[htb]
  \begin{JAVA}[style=JAVA]
enum BNFVariables implements Variable {¢¢
  BNF, Header, Body, Footer,
  Terminals, Variables, Start,
  Rules,Rule,Conjunctions, Extra_Conjunctions,
  First_Conjunction, Extra_Conjunction, Symbol_Sequence,
  Symbol, Variable, Noun;
}\end{JAVA}
  \caption{The nouns of \Self}
  \label{Figure:Nouns}
\end{figure}
  \Self will eventually generate a JAVA with
  a class named after each the enumerands in the figure.

The
enumerations \cc{BNFTerminals} and
  \cc{BNFVariables}
  are now employed in \cref{Figure:BNF:fluent}.

\begin{figure}
  \begin{Code}{Java}
new BNF()
  ¢¢.with(BNFTerminals.class)
  ¢¢.with(BNFSymbols.class)
  ¢¢.start(BNF)
  ¢¢.derive(BNF)
    ¢¢.to(Header).and(Body).and(Footer)
  ¢¢.derive(Header)
    ¢¢.to(Variables).and(Terminals)
    ¢¢.or(Terminals).and(Variables)
  ¢¢.derive(Variables)
    ¢¢.to(with, Variable.class)
  ¢¢.derive(Terminals)
    ¢¢.to(with, Terminal.class)
  ¢¢.derive(Body)
    ¢¢.to(Start).and(Rules)
  ¢¢.derive(Start)
    ¢¢.to(start, Variable)
  ¢¢.derive(Rules)
    ¢¢.to(Rule).and(Rules)
    ¢¢.or(Rule)
  ¢¢.derive(Conjunctions)
    ¢¢.to(First_Conjunction).and(Extra_Conjunctions)
  ¢¢.derive(First_Conjunction)
    ¢¢.to(to,Symbol).and(Symbol_Sequence)
    ¢¢.or(toNone)
  ¢¢.derive(Extra_Conjunctions)
    ¢¢.to(Extra_Conjunction).and(Extra_Conjunctions)
    ¢¢.orNone()
  ¢¢.derive(Extra_Conjunction)
    ¢¢.to(or,Symbol).and(Symbol_Sequence)
    ¢¢.orNone()
  ¢¢.derive(Symbol_Sequence)
    ¢¢.toNone()
    ¢¢.or(and, Symbol).and(Symbol_Sequence)
  ¢¢.derive(Symbol)
    ¢¢.to(Verb)
    ¢¢.or(Verb,Noun)
    ¢¢.or(Variable)
  ¢¢.derive(Footer)
    ¢¢.to(go)
¢¢.go();
\end{Code}
  \caption{A BNF grammar for \Self API}
  \label{Figure:BNF:fluent}
\end{figure}

The JAVA excerpt in the figure is a rather long
  sequence of method calls.
This fluent API sequence is a reflective BNF
  of the \Self API;
  indeed, we may check that \cref{Figure:BNF:fluent} reiterates \cref{Figure:BNF:BNF}
  (with notational changes as appropriate).

\subsection{Parametrized Verbs}
The granularity of grammars of programming languages typically goes down to the \emph{lexical token} level,
  but no deeper.
Such tokens, the building blocks of grammars, come in two flavors:
\begin{itemize}
  \item \emph{Monomorphic tokens} are tokens such as punctuation marks and
    certain keywords such as ‟\kk{if}”, ‟\cc{static}” and ‟\cc{class}”.
    Such tokens carry no information other than their mere presence.
  \item \emph{Polymorphic tokens} are tokens which carry content beyond
    presence (or absence). The prime example of these are identifiers.
\end{itemize}

This distinction applies also to fluent APIs:
Methods, or verbs, are the tokens, and a fluent APIs sequence consists of
method calls that come in two kinds: those that do not take parameters (such as \cc{toNone()} in \cref{Figure:BNF:fluent}),
and those that do (such as the call \cc{derives($·$)} in the figure).

\Self supports verbs with, and without, noun parameters.
The following examples,`drawn from \cref{Figure:fluent} and \cref{Figure:BNF:fluent},
  demonstrate,
\begin{JAVA}
  ¢¢.to(male)
  ¢¢.to(with, Terminal.class)
  ¢¢.to(with, Variable.class)
  ¢¢.to(start, Variable)\end{JAVA}
(The above is made possible with minor \Java language trickery,
  involving overloading and use of variadic signatures,
  with respect to function name \cc{to}.
Same trickery was applied to verbs \cc{or}, and \cc{and}.)
