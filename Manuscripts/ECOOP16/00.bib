@article{Freeman:Pryce:06,
abstract = {This paper describes the experience of evolving a domain-specific
  language embedded in \Java over several generations of a test framework. We
    describe how the framework changed from a library of classes to an embedded
    language. We describe the lessons we have learned from this experience for
    framework developers and language designers.}, 
annote = {JMock reference},
author = {Freeman, Steve and Pryce, Nat},
doi = {10.1145/1176617.1176735},
isbn = {159593491X},
journal = {Companion to the \nth{21} ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications},
keywords = {embedded domain-specific language,java,mock},
title = {Evolving an embedded domain-specific language in {\Java}},
year = 2006
}
@book{Bauer:2005,
abstract = {Hibernate practically exploded on the \Java scene. Why is this
  open-source tool so popular? Because it automates a tedious task: persisting
    your \Java objects to a relational database. The inevitable mismatch
    between your object-oriented code and the relational database requires you
    to write code that maps one to the other. This code is often complex,
  tedious and costly to develop. Hibernate does the mapping for you. Not only
    that, Hibernate makes it easy. Positioned as a layer between your
    application and your database, Hibernate takes care of loading and saving
    of objects. Hibernate applications are cheaper, more portable, and more
    resilient to change. And they perform better than anything you are likely
    to develop yourself. "Hibernate in Action" carefully explains the concepts
    you need, then gets you going. It builds on a single example to show you
    how to use Hibernate in practice, how to deal with concurrency and
    transactions, how to efficiently retrieve objects and use caching. The
    authors created Hibernate and they field questions from the Hibernate
    community every day-they know how to make Hibernate sing. Knowledge and
    insight seep out of every pore of this book. "What's Inside" - ORM concepts
    - Getting started - Many real-world tasks - The Hibernate application
    development process},
author = {Bauer, Christian and King, Gavin},
isbn = {193239415X},
publisher = {Manning Publications Co},
title = {Hibernate in Action},
year = 2005
}

@article{Deursen:2000,
abstract = {We survey the literature available on the topic of domain-specific
  languages as used for the construction and maintenance of software systems.
    We list a selection of 75 key publications in the area, and provide a
    summary for each of the papers. Moreover, we discuss terminology, risks and
    benefits, example domain-specific languages, design methodologies, and
    implementation techniques.}, 
author = {Deursen, Arie Van and Klint, Paul and Visser, Joost},
doi = {10.1145/352029.352035},
isbn = {0362-1340},
issn = {03621340},
journal = {ACM Sigplan Notices},
number = 6,
pages = {26--36},
title = {Domain-specific languages: an annotated bibliography},
url = {http://portal.acm.org/citation.cfm?doid=352029.352035},
volume = 35,
year = 2000
}

@Article{Harter:05,
 author = {Richard Harter},
 title = {A Game Theoretic Approach to the Toilete Seat Problem},
 journal = {The Science Creative Quarterly},
 year = 2005,
 number = 1,
 volume = 1,
 month = May,
}

@article{VanDeursen:Klint:2000,
  author = {Van Deursen, Arie and Klint, Paul and Visser, Joost},
  title = {Domain-specific languages},
  journal = {Centrum voor Wiskunde en Informatika},
  volume = 5,
  pages = 12,
  year = 2000,
  publisher = {Citeseer}
}

@article{Hudak:1997,
  author = {Hudak, Paul},
  title = {Domain-specific languages},
  journal = {Handbook of Programming Languages},
  volume = 3,
  pages = {39--60},
  year = 1997
}


@book{Fowler:2010,
  title = {Domain-specific languages},
  author = {Fowler, Martin},
  year = 2010,
  publisher = {Pearson Education}
}

@inproceedings{Aldrich:Sunshine:2009,
 author = {Aldrich, Jonathan and Sunshine, Joshua and Saini, Darpan and Sparks, Zachary},
 title = {Typestate-oriented Programming},
 booktitle = {Proceedings of the \nth{24} ACM SIGPLAN Conference Companion on Object Oriented Programming Systems Languages and Applications},
 series = {OOPSLA '09},
 year = 2009,
 isbn = {978-1-60558-768-4},
 location = {Orlando, Florida, USA},
 pages = {1015--1022},
 numpages = 8,
 url = {http://doi.acm.org/10.1145/1639950.1640073},
 doi = {10.1145/1639950.1640073},
 acmid = 1640073,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {objects, paradigms, permissions, programming language, states, types, typestate},
} 



@inproceedings{Bierhoff:Aldrich:2005,
  author    = {Kevin Bierhoff and Jonathan Aldrich},
  title     = {Lightweight object specification with typestates},
  booktitle = {Proceedings of the \nth{10} European Software Engineering Conference held
               jointly with \nth{13} {ACM} {SIGSOFT} International Symposium on Foundations
               of Software Engineering, 2005, Lisbon, Portugal, September 5-9, 2005},
  pages     = {217--226},
  year      = 2005,
  crossref  = {DBLP:conf/sigsoft/2005},
  url       = {http://doi.acm.org/10.1145/1081706.1081741},
  doi       = {10.1145/1081706.1081741},
  timestamp = {Wed, 01 Apr 2015 20:06:24 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/sigsoft/BierhoffA05},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@proceedings{DBLP:conf/sigsoft/2005,
  editor    = {Michel Wermelinger and Harald C. Gall},
  title     = {Proceedings of the \nth{10} European Software Engineering Conference held
               jointly with \nth{13} {ACM} {SIGSOFT} International Symposium on Foundations
               of Software Engineering},
  Month = Sep,
  publisher = ACM,
  year      = 2005,
  isbn      = {1-59593-014-0},
  timestamp = {Wed, 01 Apr 2015 20:06:24 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/sigsoft/2005},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@mastersthesis{Gutterman:2003,
  title={Turing Templates---On \CC Compile Time Power},
  author={Gutterman, Zvi},
  school={Technion---Israel Institute of Technology},
  year=2003
}

@book{Chomsky:1963,
  title={Formal properties of grammars},
  author={Chomsky, Noam},
  year=1963,
  publisher={Wiley}
}

@article{Fowler:2005,
  title={Language workbenches: The killer-app for domain specific languages},
  author={Fowler, Martin},
  year=2005
}

@article{Turing:1936,
  title={On computable numbers, with an application to the Entscheidungsproblem},
  author={Turing, Alan Mathison},
  journal={J. of Math},
  volume=58,
  number={345-363},
  pages=5,
  year=1936
}

@incollection{Musser:Stepanov:1989,
  title={Generic programming},
  author={Musser, David R. and Stepanov, Alexander A.},
  booktitle={Symbolic and Algebraic Computation},
  pages={13--25},
  year=1989,
  publisher={Springer}
}

@incollection{Dehnert:Stepanov:2000,
  title={Fundamentals of generic programming},
  author={Dehnert, James C. and Stepanov, Alexander},
  booktitle={Generic Programming},
  pages={1--11},
  year=2000,
  publisher={Springer}
}

@incollection{Backhouse:Jansson:1999,
  title={Generic Programming},
  author={Backhouse, Roland and Jansson, Patrik and Jeuring, Johan and Meertens, Lambert},
  booktitle={Advanced Functional Programming},
  pages={28--115},
  year=1999,
  publisher={Springer}
}

@book{Austern:1998,
  title={Generic programming and the STL: using and extending the {\CC} Standard Template Library},
  author={Austern, Matthew H},
  year=1998,
  publisher={Addison-Wesley Longman Publishing Co., Inc.}
}


@inproceedings{Bracha:Odersky:1998,
  author    = {Bracha, Gilad and Odersky, Martin and Stoutamire,David and Wadler, Philip},
  title     = {Making the Future Safe for the Past: Adding Genericity to the {\Java} Programming Language},
  booktitle = {Proceedings of the 1998 {ACM} {SIGPLAN} Conference on Object-Oriented
               Programming Systems, Languages {\&} Applications {(OOPSLA} '98)},
  pages     = {183--200},
  year      = 1998,
  crossref  = {DBLP:conf/oopsla/1998},
  url       = {http://doi.acm.org/10.1145/286936.286957},
  doi       = {10.1145/286936.286957},
  timestamp = {Tue, 11 Jun 2013 10:03:19 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/oopsla/BrachaOSW98},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@proceedings{DBLP:conf/oopsla/1998,
  editor    = {Freeman, Bj{\o}rn N. {-}Benson and Chambers, Craig },
  title     = {Proceedings of the 1998 {ACM} {SIGPLAN} Conference on Object-Oriented
               Programming Systems, Languages {\&} Applications ({OOPSLA}'98)},
  publisher = {{ACM}},
  year      = 1998,
  url       = {http://dl.acm.org/citation.cfm?id=286936},
  isbn      = {1-58113-005-8},
  timestamp = {Tue, 11 Jun 2013 10:03:19 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/conf/oopsla/1998},
  bibsource = {dblp computer science bibliography, http://dblp.org}
}

@inproceedings{Garcia:Jarvi:2003,
  title={A comparative study of language support for generic programming},
  author={Garcia, Ronald and Jarvi, Jaakko and Lumsdaine, Andrew and Siek, Jeremy G and Willcock, Jeremiah},
  booktitle={OOPSLA},
  volume=3,
  pages={115--134},
  year=2003
}

@incollection{Beckman:2011,
  title={An empirical study of object protocols in the wild},
  author={Beckman, Nels E. and Kim, Duri and Aldrich, Jonathan},
  booktitle={ECOOP 2011--Object-Oriented Programming standards},
  pages={2--26},
  year=2011,
  publisher={Springer}
}

@mastersthesis{Larsen:2012,
author = {Larsen, Robert},
school = {University of Oslo},
title = {Fluenty: A type safe query {API}},
year = 2012
}

@article{Kabanov:2008,
abstract = {Projects like jMock and Hibernate Criteria Query introduced
  embedded DSLs into \Java. We describe two case studies in which we develop
    embedded typesafe DSLs for building SQL queries and engineering \Java
    bytecode. We proceed to extract several patterns useful for developing
    typesafe DSLs for arbitrary domains. Unlike most previous \Java DSLs we
    find that mixing the Fluent Interface idiom with static functions, metadata
    and closures provides for a better user experience than pure method
    chaining. We also make very liberal use of the \Java 5 Generics to improve
    the type safety properties of the DSLs.}, 
author = {Kabanov, Jevgeni and
      Raudj{\"{a}}rv, Rein},
doi = {10.1145/1411732.1411758},
isbn = 9781605582238,
journal = {Proceedings of the \nth{6} international symposium on Principles and practice of programming in \Java - PPPJ '08},
keywords = {domain-specific,dsl,java,typesafe},
title = {Embedded typesafe domain specific languages for {\Java}},
year = 2008
}
@book{Linz:2001,
abstract = {Written to address the fundamentals of formal languages, automata,
  and computabilty, An Introduction to Formal Languages and Automata provides
    an accessible, student-friendly presentation of all material essential to
    an introductory Theory of Computation course. It is designed to familiarize
    students with the foundations and principles of computer science and to
    strengthen the students' ability to carry out formal and rigorous
    mathematical arguments. In the new Fifth Edition, Peter Linz continues to
    offer a straightforward, uncomplicated treatment of formal languages and
    automata and avoids excessive mathematical detail so that students may
    focus on and understand the underlying principles. In an effort to further
    the accessibility and comprehension of the text, the author has added new
    illustrative examples and exercises throughout. There is a substantial
    amount of new material in the form of two new appendices, and a CD-ROM of
    JFLAP exercises authored by Susan Rodger of Duke University. The first
    appendix is an entire chapter on finite-state transducers. This optional
    chapter can be used to prepare students for further related study. The
    second appendix offers a brief introduction to JFLAP; an interactive
    software tool that is of great help in both learning the material and in
    teaching the course. Many of the exercises in the text require creating
    structures that are complicated and that have to be tested for correctness.
    JFLAP can greatly reduce students’ time spent on testing as well as help
    them visualize abstract concepts. The CD-ROM that accompanies this fifth
    edition expands this and offers exercises specific for JFLAP.}, 
author =
    {Linz, Peter},
isbn = {0763714224},
publisher = {Jones {\&} Bartlett Learning},
title = {An Introduction to Formal Languages and Automata},
year = 2011
}

@article{Parr:1995,
abstract = {Despite the parsing power of LR/LALR algorithms, e.g. YACC,
  programmers often choose to write recursive-descent parsers by hand to obtain
    increased flexibility, better error handling, and ease of debugging. We
    introduce ANTLR, a public-domain parser generator that combines the
    flexibility of hand-coded parsing with the convenience of a parser
    generator, which is a component of PCCTS. ANTLR has many features that make
    it easier to use than other language tools. Most important, ANTLR provides
    predicates which let the programmer systematically direct the parse via
    arbitrary expressions using semantic and syntactic context; in practice,
  the use of predicates eliminates the need to hand-tweak the ANTLR output,
  even for difficult parsing problems. ANTLR also integrates the description of
    lexical and syntactic analysis, accepts LL(k) grammars for k > 1 with
    extended BNF notation, and can automatically generate abstract syntax
    trees.ANTLR is widely used, with over 1000 registered industrial and
    academic users in 37 countries. It has been ported to many popular systems
    such as the PC, Macintosh, and a variety of UNIX platforms; a commercial
    \CC front-end has been developed as a result of one of our industrial
    collaborations.}, 
author = {Parr, T. J. and Quong, R. W.},
doi = {10.1002/spe.4380250705},
isbn = {0038-0644},
issn = {1097-024X},
journal = SPAE, 
keywords = {LL(k) parser,compiler,parser generator,parsing,predicates},
number = 7,
pages = {789--810},
title = {{ANTLR}: A predicated-{LL}(k) parser generator},
volume = 25,
year = 1995
}

@book{Hopcroft:2001,
author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
edition = {\nth{2}},
pages = 249,
publisher = {Addison-Wesley},
title = {Introduction to automata theory, languages, and computation},
year = 2001
}

@book{Hopcroft:book:2001,
author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
edition = {\nth{2}},
publisher = {Addison-Wesley},
title = {Introduction to automata theory, languages, and computation},
year = 2001
}
@book{Aho:86,
abstract = {This book is a descendant of Principles of Compiler Design by Alfred V. Aho and Jeffrey D. Ullman. Like its ancestor, it is intended as a text for a first course in compiler design. The emphasis is on solving problems universally encountered in designing a language translator, regardless of the source or tar- get machine.},
author = {Aho, Alfred V and Sethi, Ravi and Ullman, Jeffrey D},
isbn = {0201100886},
pmid = {2859937},
publisher = {Addison-Wesley},
title = {Compilers: Principles Techniques, and Tools},
volume = 11,
year = 1986
}
@article{Knuth:65,
abstract = {There has been much recent interest in languages whose grammar is sufficiently simple 
that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. 
In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, 
and they provide the basis for understanding all of the special tricks which have been used in 
the construction of parsing algorithms for languages with simple structure, e.g., algebraic languages.
We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, 
and also give methods for generating recognizes for LR(k) grammars. 
It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, 
and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. 
In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.},
author = {Knuth, Donald E.},
doi = {10.1016/S0019-9958(65)90426-2},
issn = {00199958},
journal = {Information and Control},
number = 6,
pages = {607--639},
title = {On the translation of languages from left to right},
volume = 8,
year = 1965
}
@article{Parr:2011,
abstract = {Despite the power of Parser Expression Grammars (PEGs) and GLR, parsing is not a solved problem. Adding nondeterminism (parser speculation) to traditional LL and LR parsers can lead to unexpected parse-time behavior and introduces practical issues with error handling, single-step debugging, and side-effecting embedded grammar actions. This paper introduces the LL(*) parsing strategy and an associated grammar analysis algorithm that constructs LL(*) parsing decisions from ANTLR grammars. At parse-time, decisions gracefully throttle up from conventional fixed k>=1 lookahead to arbitrary lookahead and, finally, fail over to backtracking depending on the complexity of the parsing decision and the input symbols. LL(*) parsing strength reaches into the context-sensitive languages, in some cases beyond what GLR and PEGs can express. By statically removing as much speculation as possible, LL(*) provides the expressivity of PEGs while retaining LL's good error handling and unrestricted grammar actions. Widespread use of ANTLR (over 70,000 downloads/year) shows that it is effective for a wide variety of applications.},
author = {Parr, Terence and Fisher, Kathleen},
doi = {http://doi.acm.org/10.1145/1993498.1993548},
isbn = {978-1-4503-0663-8},
issn = {03621340},
journal = {Proceedings of the \nth{32} ACM SIGPLAN conference on Programming language design and implementation},
keywords = {augmented transition networks,backtracking,context-sensitive parsing,deterministic finite automata,glr,memoization,nondeterministic parsing,peg,semantic predicates,subset construction,syntactic predicates},
pages = {425--436},
title = {{LL}(*): the foundation of the {ANTLR} parser generator},
url = {http://doi.acm.org/10.1145/1993498.1993548},
year = 2011
}
