===========================================================================
                          ECOOP 2016 Review #35A
---------------------------------------------------------------------------
     Paper #35: Formal Language Recognition with the Java Type Checker
---------------------------------------------------------------------------

                      Overall merit: B. OK paper, but I will not champion
                                        it
                         Confidence: Y. I am knowledgeable in this area,
                                        but not an expert
                    Writing Quality: Q. Adequate

                         ===== Paper Summary =====

The paper presents an effective reduction from the membership
problem of DPDA (deterministic pushdown automata) to typechecking
in Java. The basic idea is to make Java's typechecker simulate a
run of the DPDA. However, the basic idea does not (obviously)
work because a DPDA may take an unbounded number of
epsilon-transitions between processing two letters of the input.
To avoid this issue, the DPDA is first converted to a
jump-deterministic DPDA, invoking a construction of (Courcelle,
1977).

Along the way, the paper introduces an interesting toolbox for
encoding basic computations into the Java type system, relying on
generics and on covariance of return types.

                    ===== Points For and Against =====

+ reduction from recognition of deterministic CFGs to Java type checking
+ nice toolbox of generics patterns
- no bounds on reduction
- weak impact on fluent APIs

                       ===== Detailed Comments =====

+ Reduction from Recognition of Deterministic CFGs to Java Type Checking.

Given a deterministic context-free language L (represented as a
deterministic pushdown automaton) the authors explain how to
construct a set of Java classes such that the membership question
"a1...an \in L?" reduces to typechecking the code
  a1().a2()...an()
Roughly, the type returned by ak() encodes the configuration of
the pushdown automaton after processing letter ak.

The proof has two parts. The first part is an unsurprising but
intricate and beautiful construction for simulating non-epsilon
transitions. The second part -- handling epsilon transitions --
is highly nontrivial! The authors solve it by invoking a result
of Courcelle from 1977, which is perhaps not widely known. Given
this result, the task reduces to adding an extra sprinkle of Java
generics hackery.

The result and the insight of the proof are both beautiful.  The
result is that recognition of deterministic CFLs reduces to Java
typechecking. The insight is that a constructive proof is
possible by invoking (Courcelle, 1977).


+ Nice Toolbox of Generics Patterns.

Before reading Section 5 I spent about a day to see if I can
reproduce the main result, claimed in Section 4. I was able to
come up with something that handles non-epsilon transitions (but
not epsilon transitions). More importantly, my solution was
orders of magnitude uglier than what I then found in Section 5.
Thus, I feel that the authors produced a nice and reusable
toolbox of techniques for encoding computation in Java's type
system. Section 6 extends this toolbox further.

(Speaking of Section 6 ... I had no idea why am I reading it
while I was reading it. The motivation comes -- rather as a shock --
at the beginning of Section 7: that's how epsilon transitions are
handled.)


- No Bounds on Reduction.

The constructions described in the paper are polynomial. However,
it is unclear what is the complexity of the whole reduction,
because we don't know whether the construction from (Courcelle,
1977) explodes the size of the automaton. I think it would be
nice to discuss briefly the complexity of the reduction, so that
readers don't have to go read other papers to figure it out.


- Weak Impact on Fluent APIs.

The motivation for the work is ostensibly to aid in the design of
fluent APIs (that is, those that chain many method calls).
However, I think this work will have little impact on the
practice of designing fluent APIs.


= Other.

I would mention much earlier that epsilon-transitions pose a
challenge. Otherwise, readers may think the task is easier than
it really is.

The authors state several times that there are no results on the
complexity of Java's type system. I am aware of some decidability
results on related type systems. The authors may wish to do a
literature search starting from this seed:
  [Kennedy, Pierce, On Decidability of Nominal Subtyping with Variance, 2006]

Section 8 contains an example of a Java program whose compilation
takes a long time. The example is connected to the rest of the
paper only loosely: it uses generics. Also, despite what the
authors claim, I doubt many readers will find it surprising that
the Java compiler sometimes takes a long time to finish. I think
it would be worth mentioning that the Java compiler may take a
long time *if* it actually happens for *your* construction, not
just for some loosely similar kind of Java program.

Although the text is organized well, it has many spelling and
grammar mistakes.  Please proofread it.

Here's a small selection of typos:
  - letters are sometimes a and sometimes \sigma (e.g., bottom of page 6)
  - in Fig 5.7, the } that ends the class is on line 1 but should be on line 12
  - on page 15, "k=|\Sigma|" should be "k=|\Gamma|"

           ===== Questions for Authors in Response Period =====

Does your encoding use features specific to Java 8, or does it
also work in previous versions? Otherwise put, which are the key
features of the type system on which you rely?

What exactly are you proving in footnote 16? Your article
presents an encoding of all DPDA into the Java type system, so
such an encoding is clearly *not* impossible as footnote 16 seems
to claim. Perhaps you want to prove the impossibility of dumb
encodings, for some definition of "dumb"?

This Paper Ought to Have an Accompanying Artifact:
                                     1. No, does not need to


