Ever after their inception~\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
Inspired by the theory of formal languages~\cite{Linz:2001} and pushdown automata,
  this is a study of what can be done, and what can not be done, with a fluent API.

Consider some fluent API definition, permitting only certain call chains.
Now, think of the formal language that defines the set of these permissible chains.
The theoretical aspect of the study is a proof (with its implicit algorithm) that
  there is a \Java type definition that \emph{realizes} this fluent definition, if this
  language is \emph{deterministic context-free}.
Roughly speaking, deterministic context free languages are those context free languages
  that can be recongized by an LR (left-right~\cite{provide:lr:grammars}) parser.
    this is also the set of LL(*) languges~\cite{Knuth:65}, which happens also
      to to be the language of the popular ANTLR tool~\cite{ANTL}.

For a type definition to \emph{realize} a definition of fluent API,
  two must happen: Call chains that conform with the API definition
  compile correctly; conveserly, call chains that are forbidden by the API definition
  do not type-check, and result in compile-time error.

\begin{wraptable}[9]r{27ex}
\caption{\label{Table:box}Fluent API of a box object}
  \begin{tabular}{m{7ex} | m{8ex} @{}| m{8ex}}
           & \cc{open()} & \cc{close()}‚èé \hline
    ‚Äüclosed‚Äù & \color{blue}{\emph{become ‚Äüopen‚Äù}} & \color{red}{\emph{runtime error}}‚èé\hline
    ‚Äüopen‚Äù & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‚Äüclosed‚Äù}}‚èé
  \end{tabular}
\end{wraptable}

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box}
may receive two method invocations: \cc{open()} and \cc{close()},
and can be in either ‚Äüopen‚Äù or ‚Äüclosed‚Äù state,
Initially the instance is ‚Äüclosed‚Äù.
Its behavior henceforth is defined in \cref{Table:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, and
  all other blue regions in the table, type-check.
Conversely, with this type definition, type error occurs in \cc{\kk{new} Box.close()},
  and in all other red regions in the table.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary other auxiliary classes extending it, an appropriate method definition here and there, etc.

The proof makes a general recipe for handling examples of this sort:
Consider the language defined by the fluent API.
In the box example, this language is
\[
  L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}\big)?
\]

If this language is deterministic context free, then, the fluent API can be implemented, and,
  there is algorithm to produce this fluent API for you.
In the example, language~$L$ is written as a regular expression already,
  and hence is trivially deterministic context-free.
It follows from the proof that there exists a type definition
  for the box example.
Moreover, there is a way
  to automatically produce this type definition.

The proof is a construction of a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{determinisic context free language}.
With the generated types and methods, any chain of fluent API calls,
  actually runs the pushdown automaton against the specific input that the chain represents.
When used appropriately, if this run of the automaton ends with an accepting state,
  then the fluent API chain type checks correctly.
If however this run ends with a failure, i.e., non-accepting state,
  compile time error will occur.

The algorithm for generating the pushdown automaton is unofrunately impractical.
It is indeed polynomial time and space,
  yet formidable resource consuming.

A practical alternative is offered by the second aspect of this study:
\Self is a \Java library with a fluent interface, designed for generating fluent APIs.
To create a new fluent API~$œï$, use the fluent API of \Self to write, in \Java, a BNF for~$œï$.
Running the \Java program thus written, augmented with the \Self library,
  generates a \Java class library that realizes~$œï$.

This class library, ready for use by~$œï$'s clients, does more 
  than compile time recognition
  of the language of~$œï$.
The execution of a call chain of~$œï$, creates an AST data structure.
  compliant with the BNF of~$œï$, and augmented with a visitor, all ready
  for use by the implementor of~$œï$.

\Self generates LR(1) parsers, which as experience shows, is sufficient for many purpooses. 
Still, LR(1) are a stict subset of determinisic context-free languages. 
Practicality concerns stop \Self from implementing LR($k$) parsing for any 
  desired~$k$, and even the complete LR(*) .
  

It is just pra
\begin{itemize}
  \item Although \Self can potentially manage all LR($k$) grammars,
        the current implementation is limited to LR(1) languages
  \item Moreover, all LR($k$) languages are strict subsets of deterministic context free languages %according to Knuth:65 LR(*)=D-CFG
      which precisely those recognized by ANTLR. % ANTLR does not contain D-CFG,and not the opposite either.
\end{itemize}
We give reason why bridging this gap is highly unlikely.

Is it possible to implement a fluent API for a general
  (that is, non-deterministic) context free languages?
Again, we give reason why this might be possible in some cases,
  but it is highly unlikely that fluent APIs can be made for all context free languages.

Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‚Äüconcepts‚Äù in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$C‚Çò$ such that
    compilation of~$C‚Çò$ of terminates if and only if
      Turing-machine~$m$ halts.
  Furthermore, program~$C‚Çò$ can be effectively‚Ä†{in the computability lingo:
    effective~$‚âà$‚Äü~\emph{there is time
  bounded algorithm for carrying out the task}‚Äù.} generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‚Äü\emph{template specialization}‚Äù.

In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In one sense, my research shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
I hope to show that it is possible to enJAVA context free grammars within the \Java type system,
  in such a way that type-checking is equivalent to membership queries.
This objective is more precisely expressed in the following conjecture.

\begin{Theorem}
\label{Theorem:Gil-Levy}
Let~$Œ£$ be finite alphabet.
Let~$M$ be a \emph{push-down automaton(PDA)}, and let~$ùìõ‚Çõ‚äÜŒ£^*$ be
the \emph{formal language} such that~$M$ recognizes.
Then, there exists a \Java program,~$J‚Çõ$ and a location~$‚Ñì‚ààJ‚Çõ$
such that
\begin{quote}
  if a string~$Œ±‚ààŒ£$ is
  placed at location~$‚Ñì$ in~$J‚Çõ$ then
  \begin{quote}
    program~$J‚Çõ$ type checks, if an only if
    \[
      Œ±‚ààùìõ‚Çõ.
    \]
  \end{quote}
\end{quote}
Furthermore, program~$J‚Çõ$ can be effectively generated from~$M$.
\end{Theorem}

The proof shall be made with an algorithm that converts a
  PDA~$M$ into a program~$J‚Çõ$.
I am currently in the process of implementing a program that
  does precisely that.
This program, along with its API, other lesser components and
  some connecting tissue, are to be known as \Self.

The above discussion, formalism and conjecture may seem at sight too abstract
  and of little practical value.
Re-positioning perspective may shed a different light:
\cref{Theorem:Gutterman} is important not only because it tells us
  that the question of termination of a \CC compiler is as difficult
  the halting problem~\cite{Turing:1936}, but also because it
  justifies the common belief that is no limit to the power of
  template programming~\cite{Musser:Stepanov:1989,Dehnert:Stepanov:2000
  ,Backhouse:Jansson:1999, Austern:1998,Bracha:Odersky:1998,Garcia:Jarvi:2003}.

In the fashion, \cref{Theorem:Gil-Levy} has important
  implications to the emerging trend of employing fluent APIs
  to make complex software systems more accessible.
My thesis is that one can employ the conjecture for
  automatic generation of very rich such APIs.
