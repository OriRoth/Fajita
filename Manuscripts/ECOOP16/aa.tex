Ever after their inception\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
In many ways, fluent APIs are a kind of
  \emph{internal} \emph{\textbf Domain \textbf Specific \textbf Language}:
They make it possible to enrich a host programming language without changing it.
Advantages are many: base language tools (compiler, debugger, IDE, etc.) remain
  applicable, programmers are saved the trouble of learning a new syntax, etc.
However, these advantages come at the cost of expressive power;
  in the words of Fowler:
  ‟\emph{Internal DSLs are limited by the syntax and structure of your base language.}”†
  {M. Fowler, \emph{Language Workbenches: The Killer-App for Domain Specific Languages?}, 
    2005
    \newline
  \url{http://www.martinfowler.com/articles/languageWorkbench.html\#InternalDsl}}.
Indeed, in languages such as \CC, fluent APIs
  often make extensive use of operator overloading (examine, e.g., \textsf{Ara-Rat}~\cite{Gil:Lenz:07}),
  but this capability is not available in \Java.

Despite this limitation, fluent API in \Java can be rich and expressive, as demonstrated
  in \cref{Figure:DSL} showing use cases of the DSL of Apache Camel~\cite{Ibsen:Anstey:10}
(open-source integration framework),
and that of jOOQ\urlref{http://www.jooq.org}, a framework for writing
  SQL in \Java, much like Linq~\cite{Meijer:Beckman:Bierman:06}.

\begin{figure}[H]
  \caption{\label{Figure:DSL} Two examples of \Java fluent API}
  \begin{tabular}{@{}c@{}c@{}}
    \parbox[c]{44ex}{\javaInput[left=0ex]{camel-apache.java.fragment}} &
    \hspace{-3ex} \parbox[c]{59ex}{\javaInput[left=0ex]{jOOQ.java.fragment}} ⏎
    \textbf{(a)} Apache Camel                                          & \textbf{(b)} jOOQ
  \end{tabular}
\end{figure}

Other examples of fluent APIs in \Java are abundant: 
  jMock\cite{Freeman:Pryce:06}, 
  Hamcrest\urlref{http://hamcrest.org/JavaHamcrest/},
  EasyMock\urlref{http://easymock.org/},
  jOOR\urlref{https://github.com/jOOQ/jOOR},
  jRTF\urlref{https://github.com/ullenboom/jrtf}
  and many more.

\subsection{A Type Perspective on Fluent APIs}
Inspired by the theory of formal languages and automata,
this study explores what can be done, and what can not be done, with fluent API in \Java.

Consider some fluent API definition, permitting only certain call
chains and disallowing all others.
Now, think of the formal language that defines the set of these permissible chains.
The main contribution of this paper is a proof (with its implicit algorithm) that
there is always \Java type definition that \emph{realizes} this fluent definition, provided that this
language is \emph{deterministic context-free}, where
\begin{itemize}
  \item In saying that a type definition \emph{realizes} a definition of fluent
    API, we mean that call chains that conform with the API definition compile
    correctly, and, conversely, call chains that are forbidden by the API
    definition do not type-check, resulting in an appropriate compiler error.
  \item Roughly speaking, deterministic context free languages are those
    context free languages that can be recognized by an LR parser~†{The ‟L"
    means reading the input left to right; the ‟R" stands for rightmost derivation}~\cite{Aho:86}.
    An important property of this family is that none of its members is ambiguous.
\end{itemize}

A problem related to that of recognizing a formal language,
is that of parsing, i.e., creating, for input which is within the language,
  a parse tree according to the language's grammar, 
In the fluent APIs domain, the distinction between recognition and parsing is
  the distinction between compile time and runtime.
Before a program is run, the compiler checks whether the fluent API call is legal,
  and code completion tools will only suggest legal extensions of a current call chain.

In contrast, the parse tree is created at runtime.
Some fluent API definitions create the parse-tree
  iteratively, where each method invocations in the call chain adding
  more components to this tree.
However, it is always possible to generate this tree in ‟batch” mode:
This is done by maintaining a \emph{call list} which 
  starts empty and grows at runtime by having each method invoked add to it 
  a record storing the method's name and values of its parameters.  
The list is completed at the end of the call list, at which point it is fed to an appropriate parser that
  converts it into a parse tree (or even an AST).

\subsection{Contribution}
Concrete contributions made by this work include
\begin{itemize}
  \item the understanding that the definition of fluent APIs is analogous to 
      the definition of a formal language.
  \item a lower bound (deterministic pushdown automata). 
    on the theoretical ``computational complexity'' of the \Java type system.
  \item an algorithm for producing a fluent API for deterministic context free languages.
  \item a collection of generic programming techniques, developed towards this algorithm. 
  \item a demonstration that the runtime Oracle's \texttt{javac} compiler may be exponential in the program size. 
\end{itemize}
