Ever after their inception~\cite{Fowler:web:2005} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
Inspired by the theory of formal languages~\cite{Linz:2001} and pushdown automata,
  this is a study of what can be done, and what can not be done, with a fluent API.

Consider a fluent API definition, permitting only certain call chains.
Now, think of the formal language that defines the set of permissible call chains.
The theoretical aspect of the study is a proof (with its implicit algorithm) that
  there is \Java program that realizes this fluent API, if this
  language is \emph{deterministic context-free}.
The essence of the proof is in showing a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  the formal language behind the automaton.
With the generated types and methods, a chain of fluent API calls
  will type check only if the chain is within the language.

Practically speaking, the poof shows that the (potential)
  experessive power of fluent APIs,
  is the same as ANTLR~\cite{Parr:1995:I:Dont:Think:Its:Correct}:
If a grammar of a fluent API can be written in ANTLR, then it
  can be implemented with a \Java library.
Nevertheless, the algorithim for generating the parser, although polynomial
  in time and space, is too resource consuming to be implemented. 

The second aspect of this work takes is the actual production 
  of fluent APIs from their specification.
\Self, presented here, is a \Java library providing a fluent API for generating fluent APIs:
To create a new fluent API, use the fluent API of \Self to write, in \Java, a BNF for it.
Running the \Java program thus written, augmented with the \Self library,
  generates a \Java class library that implements this new fluent API.

Practicality concerns stopped \Self from realizing the full potential of the proof.
As a result, the expressive power of \Self is actually stictly less than that of ANTLR:
\begin{itemize}
  \item Although \Self can potentially manage all LR(k) grammars,
        the current implementation is limited to LR(1) languages
  \item Moreover, all LR(k) languages are strict subsets of deterministic context free languages
      which precisely those recognized by ANTLR.~\cite{Thats not true according to Knuth:65. Any DPDA have a equal LR(k) grammar}
\end{itemize}
We give reason why bridging this gap is highly unlikely.

Is it possible to implement a fluent API for a general 
  (that is, non-deterministic) context free languages? 
Again, we give reason why this might be possible in some cases,
  but it is highly unlikely that fluent APIs can be made for all context free languages.

Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‚Äüconcepts‚Äù in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine~$m$‚Ä†{We tacitly assume that a Turing machine
    enJAVAs in it its input}, there exists a \CC program,~$C‚Çò$ such that
  \begin{quote}
    compilation of~$C‚Çò$ of terminates if and only if
    \begin{quote}
      Turing-machine~$m$ halts.
    \end{quote}
  \end{quote}
  Furthermore, program~$C‚Çò$ can be effectively‚Ä†{in the computability lingo:
    effective~$‚âà$‚Äü~\emph{there is time
  bounded algorithm for carrying out the task}‚Äù.} generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‚Äü\emph{template specialization}‚Äù.

In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In one sense, my research shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
I hope to show that it is possible to enJAVA context free grammars within the \Java type system,
  in such a way that type-checking is equivalent to membership queries.
This objective is more precisely expressed in the following conjecture.

\begin{Theorem}
\label{Theorem:Gil-Levy}
Let~$Œ£$ be finite alphabet.
Let~$M$ be a \emph{push-down automaton(PDA)}, and let~$ùìõ‚Çõ‚äÜŒ£^*$ be
the \emph{formal language} such that~$M$ recognizes.
Then, there exists a \Java program,~$J‚Çõ$ and a location~$‚Ñì‚ààJ‚Çõ$
such that
\begin{quote}
  if a string~$Œ±‚ààŒ£$ is
  placed at location~$‚Ñì$ in~$J‚Çõ$ then
  \begin{quote}
    program~$J‚Çõ$ type checks, if an only if
    \[
      Œ±‚ààùìõ‚Çõ.
    \]
  \end{quote}
\end{quote}
Furthermore, program~$J‚Çõ$ can be effectively generated from~$M$.
\end{Theorem}

The proof shall be made with an algorithm that converts a
  PDA~$M$ into a program~$J‚Çõ$.
I am currently in the process of implementing a program that
  does precisely that.
This program, along with its API, other lesser components and
  some connecting tissue, are to be known as \Self.

The above discussion, formalism and conjecture may seem at sight too abstract
  and of little practical value.
Re-positioning perspective may shed a different light:
\cref{Theorem:Gutterman} is important not only because it tells us
  that the question of termination of a \CC compiler is as difficult
  the halting problem~\cite{Turing:1936}, but also because it
  justifies the common belief that is no limit to the power of
  template programming~\cite{Musser:Stepanov:1989,Dehnert:Stepanov:2000
  ,Backhouse:Jansson:1999, Austern:1998,Bracha:Odersky:1998,Garcia:Jarvi:2003}.

In the fashion, \cref{Theorem:Gil-Levy} has important
  implications to the emerging trend of employing fluent APIs
  to make complex software systems more accessible.
My thesis is that one can employ the conjecture for
  automatic generation of very rich such APIs.
