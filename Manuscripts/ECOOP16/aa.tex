Ever after their inception~\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
Inspired by the theory of formal languages~\cite{Linz:2001} and pushdown automata,
  this is a study of what can be done, and what can not be done, with a fluent API.

Consider some fluent API definition, permitting only certain call chains.
Now, think of the formal language that defines the set of these permissible chains.
The theoretical aspect of the study is a proof (with its implicit algorithm) that
  there is a \Java type definition that realizes this fluent definition, if this
  language is \emph{deterministic context-free}.
For a type definition to \emph{realize} a definition of fluent API,
  two must happen: Call chains that conform with the API definition
  compile correctly; conveserly, call chains that are forbidden by the API definition
  do not type-check, and result in compile-time error. 

To be concrete, consider this example of fluent API definition:
An instance of class \cc{Box} can be
is either ``open'' or ``closed'' state, and offers two methods \cc{open()} and \cc{close()}.
Initially the instance is ``closed''.
Its behavior is defined \cref{Table:box}.

\begin{wraptable}[9]r{27ex}
\caption{\label{Table:box}Fluent API of a box object}
  \begin{tabular}{m{7ex} | m{8ex} @{}| m{8ex}}
           & \cc{open()}                          & \cc{close()}                           \\ \hline
    ``closed'' & \color{blue}{\emph{become ``open''}} & \color{red}{\emph{runtime error}}      \\\hline
    ``open''   & \color{red}{\emph{runtime error}}    & \color{blue}{\emph{become ``closed''}} \\
  \end{tabular}
\end{wraptable}

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, and 
  all other blue regions in the table, type-check. 
Conversely, with this type definition, type error occurs in \cc{\kk{new} Box.close()}, 
  and in all other red regions in the table.

Obviosly, some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with 
  some auxiliary other auxiliary classes extending it, an appropriate method definition here and there, etc.
The proof makes a general recipe for handling examples of this sort: 
Consider the language defined by the fluent API. In the box case, 
  this is $\big(\cc{.open().close()}\big)^*\big(\cc{.open()}\big)?$.  
Given any fluent API definition, we would 
when is it possible to create a fluent 
The question engaged here is: 



The essence of the proof is in showing a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{determinisic context free language}. 
With the generated types and methods, any chain of fluent API calls,
  runs the pushdown automaton.
  will type check only if the chain is within the language.

Practically speaking, the poof shows that the (potential)
  experessive power of fluent APIs,
  is the same as deterministic context-free grammars.
%If a grammar of a fluent API can be written in ANTLR, then it
%  can be implemented with a \Java library.
Nevertheless, the algorithim for generating the parser, although polynomial
  in time and space, is too resource consuming to be implemented. 

The second aspect of this work takes is the actual production 
  of fluent APIs from their specification.
\Self, presented here, is a \Java library providing a fluent API for generating fluent APIs:
To create a new fluent API, use the fluent API of \Self to write, in \Java, a BNF for it.
Running the \Java program thus written, augmented with the \Self library,
  generates a \Java class library that implements this new fluent API.

Practicality concerns stopped \Self from realizing the full potential of the proof.
As a result, the expressive power of \Self is actually stictly less than that of ANTLR:
\begin{itemize}
  \item Although \Self can potentially manage all LR(k) grammars,
        the current implementation is limited to LR(1) languages
  \item Moreover, all LR(k) languages are strict subsets of deterministic context free languages %according to Knuth:65 LR(*)=D-CFG
      which precisely those recognized by ANTLR. % ANTLR does not contain D-CFG,and not the opposite either.
\end{itemize}
We give reason why bridging this gap is highly unlikely.

Is it possible to implement a fluent API for a general 
  (that is, non-deterministic) context free languages? 
Again, we give reason why this might be possible in some cases,
  but it is highly unlikely that fluent APIs can be made for all context free languages.

Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‚Äüconcepts‚Äù in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$C‚Çò$ such that
    compilation of~$C‚Çò$ of terminates if and only if
      Turing-machine~$m$ halts.
  Furthermore, program~$C‚Çò$ can be effectively‚Ä†{in the computability lingo:
    effective~$‚âà$‚Äü~\emph{there is time
  bounded algorithm for carrying out the task}‚Äù.} generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‚Äü\emph{template specialization}‚Äù.

In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In one sense, my research shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
I hope to show that it is possible to enJAVA context free grammars within the \Java type system,
  in such a way that type-checking is equivalent to membership queries.
This objective is more precisely expressed in the following conjecture.

\begin{Theorem}
\label{Theorem:Gil-Levy}
Let~$Œ£$ be finite alphabet.
Let~$M$ be a \emph{push-down automaton(PDA)}, and let~$ùìõ‚Çõ‚äÜŒ£^*$ be
the \emph{formal language} such that~$M$ recognizes.
Then, there exists a \Java program,~$J‚Çõ$ and a location~$‚Ñì‚ààJ‚Çõ$
such that
\begin{quote}
  if a string~$Œ±‚ààŒ£$ is
  placed at location~$‚Ñì$ in~$J‚Çõ$ then
  \begin{quote}
    program~$J‚Çõ$ type checks, if an only if
    \[
      Œ±‚ààùìõ‚Çõ.
    \]
  \end{quote}
\end{quote}
Furthermore, program~$J‚Çõ$ can be effectively generated from~$M$.
\end{Theorem}

The proof shall be made with an algorithm that converts a
  PDA~$M$ into a program~$J‚Çõ$.
I am currently in the process of implementing a program that
  does precisely that.
This program, along with its API, other lesser components and
  some connecting tissue, are to be known as \Self.

The above discussion, formalism and conjecture may seem at sight too abstract
  and of little practical value.
Re-positioning perspective may shed a different light:
\cref{Theorem:Gutterman} is important not only because it tells us
  that the question of termination of a \CC compiler is as difficult
  the halting problem~\cite{Turing:1936}, but also because it
  justifies the common belief that is no limit to the power of
  template programming~\cite{Musser:Stepanov:1989,Dehnert:Stepanov:2000
  ,Backhouse:Jansson:1999, Austern:1998,Bracha:Odersky:1998,Garcia:Jarvi:2003}.

In the fashion, \cref{Theorem:Gil-Levy} has important
  implications to the emerging trend of employing fluent APIs
  to make complex software systems more accessible.
My thesis is that one can employ the conjecture for
  automatic generation of very rich such APIs.
