Ever after their inception~\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
Inspired by the theory of formal languages~\cite{Linz:2001} and pushdown automata,
  this is a study of what can be done, and what can not be done, with a fluent API.

Consider some fluent API definition, permitting only certain call chains.
Now, think of the formal language that defines the set of these permissible chains.
The theoretical aspect of the study is a proof (with its implicit algorithm) that
  there is a \Java type definition that \emph{realizes} this fluent definition, if this
  language is \emph{deterministic context-free}.
Roughly speaking, deterministic context free languages are those context free languages
  that can be recognized by an LR (L for reading input from left to right,and R for rightmost derivation)~\cite{Aho:86} parser.
    It is also the set of LL(*) languages~\cite{Knuth:65}, which happens also
      to to be the language of the popular ANTLR tool~\cite{Parr:2011}.

For a type definition to \emph{realize} a definition of fluent API,
  two must happen: Call chains that conform with the API definition
  compile correctly; conversely, call chains that are forbidden by the API definition
  do not type-check, and result in compile-time error.

\begin{wraptable}[9]r{27ex}
\caption{\label{Table:box}Fluent API of a box object}
  \begin{tabular}{m{7ex} | m{8ex} @{}| m{8ex}}
           & \cc{open()} & \cc{close()}‚èé \hline
    ‚Äüclosed‚Äù & \color{blue}{\emph{become ‚Äüopen‚Äù}} & \color{red}{\emph{runtime error}}‚èé\hline
    ‚Äüopen‚Äù & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‚Äüclosed‚Äù}}‚èé
  \end{tabular}
\end{wraptable}

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box}
may receive two method invocations: \cc{open()} and \cc{close()},
and can be in either ‚Äüopen‚Äù or ‚Äüclosed‚Äù state,
Initially the instance is ‚Äüclosed‚Äù.
Its behavior henceforth is defined by \cref{Table:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, more generally
  blue regions in the table, type-check.
Conversely, with this type definition, type error should occur in \cc{\kk{new} Box.close()},
  and, more genrally, in red regions in the table.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary classes extending it, an appropriate method definition here and there, etc.

The proof makes a general recipe for handling examples of this sort:
First, consider the language defined by the fluent API.
In the box example, this language is
\[
  L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}|Œµ\big).
\]

Second, check whether this language defined is deterministic context-free.
If it is, the fluent API can be realized, and,
  there is an algorithm to produce the respective type definition.
In the box example, language~$L$ is written as a regular expression,
  and hence is trivially deterministic context-free.
It follows from the proof that there exists a type definition
  for the box example.
Moreover, there is a way
  to automatically produce this type definition.

The proof is a construction of a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{deterministic context free language}.
With the generated types and methods, any chain of fluent API calls,
  actually runs the pushdown automaton against the specific input that the chain represents.
When used appropriately, if this run of the automaton ends with an accepting state,
  then the fluent API chain type checks correctly.
If however this run ends with a failure, i.e., non-accepting state,
  compile time error will occur.

The algorithm for generating the pushdown automaton is unfortunately impractical.
It is indeed polynomial time and space,
  yet formidable resource consuming.
A practical alternative is offered by the second aspect of this study:
\Self is a \Java library with a fluent interface, designed for generating fluent APIs.
To create a new fluent API~$œï$, use the fluent API of \Self to write, in \Java, a BNF for~$œï$.
Running the \Java program thus written, augmented with the \Self library,
  generates a \Java class library that realizes~$œï$.

This class library, ready for use by~$œï$'s clients, does more
  than compile time recognition
  of the language of~$œï$.
The execution of a call chain of~$œï$, creates an AST data structure.
  compliant with the BNF of~$œï$, and augmented with a visiting API, all ready
  for use by the implementer of~$œï$.

\Self generates LR(1) parsers. Experience shows that these are
sufficient for many purposes~\cite{find some references, perhaps the bison manual, but I am sure there are better references}.
Still, LR(1) languages are a strict subset of deterministic context-free languages.

It is parser size explosion that stops mature tools such as Bison~\cite{Bison},
  SableCC~\cite{Sable:Search in databased, it should be there} and Lemon Parser Generator~\cite{something}
  from reaching up to LR($k$),~$k‚â•2$.
The same concern stops \Self from this venture.

One may ask whether the theoretical result is the
  best possible:
Can one implement a fluent API for a general
  (that is, non-deterministic) context free languages?
We give reason why this possibility is unlikely. 

Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‚Äüconcepts‚Äù in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$C‚Çò$ such that
    compilation of~$C‚Çò$ of terminates if and only if
      Turing-machine~$m$ halts.
  Furthermore, program~$C‚Çò$ can be effectively‚Ä†{in the computability lingo:
    effective~$‚âà$‚Äü~\emph{there is time
  bounded algorithm for carrying out the task}‚Äù.} generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‚Äü\emph{template specialization}‚Äù.

In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In one sense, my research shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
I hope to show that it is possible to encode context free grammars within the \Java type system,
  in such a way that type-checking is equivalent to membership queries.
This objective is more precisely expressed in the following conjecture.

\begin{Theorem}
\label{Theorem:Gil-Levy}
Let~$Œ£$ a be finite alphabet.
Let~$M$ be a \emph{push-down automaton(PDA)}, and let~$ùìõ‚Çõ‚äÜŒ£^*$ be
the \emph{formal language} such that~$M$ recognizes.
Then, there exists a \Java program,~$J‚Çõ$ and a location~$‚Ñì‚ààJ‚Çõ$
such that
\begin{quote}
  if a string~$Œ±‚ààŒ£$ is
  placed at location~$‚Ñì$ in~$J‚Çõ$ then
  \begin{quote}
    program~$J‚Çõ$ type checks, if an only if
    \[
      Œ±‚ààùìõ‚Çõ.
    \]
  \end{quote}
\end{quote}
Furthermore, program~$J‚Çõ$ can be effectively generated from~$M$.
\end{Theorem}

The proof shall be made with an algorithm that converts a
  PDA~$M$ into a program~$J‚Çõ$.
I am currently in the process of implementing a program that
  does precisely that.
This program, along with its API, other lesser components and
  some connecting tissue, are to be known as \Self.

The above discussion, formalism and conjecture may seem at sight too abstract
  and of little practical value.
Re-positioning perspective may shed a different light:~\cref{Theorem:Gutterman} is important not only because it tells us
  that the question of termination of a \CC compiler is as difficult
  the halting problem~\cite{Turing:1936}, but also because it
  justifies the common belief that is no limit to the power of
  template programming~\cite{Musser:Stepanov:1989,Dehnert:Stepanov:2000
  ,Backhouse:Jansson:1999, Austern:1998,Bracha:Odersky:1998,Garcia:Jarvi:2003}.

In the fashion,~\cref{Theorem:Gil-Levy} has important
  implications to the emerging trend of employing fluent APIs
  to make complex software systems more accessible.
My thesis is that one can employ the conjecture for
  automatic generation of very rich such APIs.
