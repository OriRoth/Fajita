Ever after their inception\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
Inspired by the theory of formal languages~\cite{Linz:2001} and pushdown automata,
  this is a study of what can be done, and what can not be done, with a fluent API.

Consider some fluent API definition, permitting only certain call chains.
Now, think of the formal language that defines the set of these permissible chains.
The theoretical aspect of the study is a proof (with its implicit algorithm) that
  there is a \Java type definition that \emph{realizes} this fluent definition, if this
  language is \emph{deterministic context-free}.
Roughly speaking, deterministic context free languages are those context free languages that can be recognized
  by an LR parser~†{The ‟L" means reading the input left to righ; the ‟R" stands for rightmost derivation}~\cite{Aho:86}.

For a type definition to \emph{realize} a definition of fluent API,
  two must happen: Call chains that conform with the API definition
  compile correctly; conversely, call chains that are forbidden by the API definition
  do not type-check, and result in some compile-time type error.

\begin{wraptable}[9]r{32.05ex}
\caption{\label{Table:box}Fluent API of a box object}
  \begin{tabular}[align=center]{m{7ex} | m{9ex} @{}| m{9ex}}
           & \cc{open()} & \cc{close()}⏎ \hline
    ‟closed”\ & \color{blue}{\emph{become ‟open”}} & \color{red}{\emph{runtime error}}⏎\hline
    ‟open” & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‟closed”}}⏎
  \end{tabular}
\end{wraptable}

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box}
may receive two method invocations: \cc{open()} and \cc{close()},
and can be in either ‟open” or ‟closed” state,
Initially the instance is ‟closed”.
Its behavior henceforth is defined by \cref{Table:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, more generally
  blue regions in the table, type-check.
Conversely, with this type definition, compile time type error should occur in \cc{\kk{new} Box.close()},
  and, more generally, in red regions in the table.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary classes extending it, an appropriate method definition here and there, etc.

The proof makes a general recipe for handling examples of this sort:
\begin{itemize}
  \item First, consider the language defined by the fluent API\@.
In the box example, this language is defined by the regular expression:
\[
  L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}|ε\big).
\]
\item Second, check whether this language is deterministic context-free.
If it is, the fluent API can be realized, and,
  there is an algorithm to produce the respective type definition.
In the box example, since language~$L$ is specified by a regular expression,
  it is trivially deterministic context-free.

It follows from the proof that there exists a type definition
  which realizes the box example.
Moreover, there is a way
  to automatically produce this type definition.
\end{itemize}

The proof is a construction of a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{deterministic context free language}.
With the generated types and methods, the compilation process of
  any chain of fluent API calls, actually runs the pushdown automaton against the
  specific input string that the chain represents.
When used appropriately, if this run of the automaton ends with an accepting state†{The acceptence of a PDA can also be defined by an empty stack, we will use the accepting state type of PDAs},
  then the fluent API chain type checks correctly.
If however this run ends with a failure, i.e., non-accepting state,
  compile time error will occur.

The algorithm for generating the pushdown automaton is unfortunately impractical.
It is indeed polynomial time and space,
  yet a consumer of formidable resources.
A practical alternative is offered by the second aspect of this study:
\Self is a \Java library with a fluent interface, designed for generating fluent APIs.
To create a new fluent API~$ϕ$, use the fluent API of \Self to write, in \Java, a BNF for~$ϕ$.
Running the \Java program thus written, augmented with the \Self library,
  generates a \Java class library that realizes~$ϕ$.

This class library, ready for use by~$ϕ$'s clients, does more
  than compile time recognition
  of the language of~$ϕ$.
The execution of a call chain of~$ϕ$, creates an AST data structure,
  compliant with the BNF of~$ϕ$.
At the moment, the AST's nodes are un-typed, though it is planned
  to them typed, in order to augment a visiting API, for the use of the
  implementor of~$ϕ$.
% and augmented with a visiting API, all ready
% for use by the implementer of~$ϕ$.

\Self generates LR($1$) parsers. Experience shows that these and even the strictly smaller set of
  LALR grammars is sufficient for many purposes (see e.g., an acknowledgement by T\@. Parr,
    the developer of LL($*$) grammars~\cite{Parr:1995}).
Evidently, Bison~\cite{Bison:manual},
  SableCC\urlref{http://www.sablecc.org}, Lemon Parser Generator\urlref{http://www.hwaci.com/sw/lemon/}
  and other popular generators of left to right parsers opt to stay within the confinement of LALR parsers.
Practicality concerns stop \Self from trangressing this limitation.

One may ask whether the theoretical result is the
  best possible:
It is possible to implement a fluent API for general
  (that is, non-deterministic) context free languages?
  We give reason why this possibility is unlikely.
