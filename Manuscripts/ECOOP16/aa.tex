Ever after their inception\urlref{http://martinfowler.com/bliki/FluentInterface.html} \emph{fluent APIs}
  increasingly gain popularity~\cite{Bauer:2005,Freeman:Pryce:06,Larsen:2012} and research
  interest~\cite{Deursen:2000,Kabanov:2008}.
In many ways, fluent APIs are a kind of
  \emph{internal} \emph{\textbf Domain \textbf Specific \textbf Language}:
They make it possible to ecrich a host programming language without changing it.
Advantages are many: base langauge tools (compiler, debugger, IDE, etc.) remain
  applicable, programmers are saved the trouble of learning a new syntax, etc.
However, these advantages come at the cost of expressive power;
  in the words of M. Fowler:
  ‟\emph{Internal DSLs are limited by the syntax and structure of your base language.}”†
  {M. Fowler,
    \emph{Language Workbenches: The Killer-App for Domain Specific Languages?},
  \url{http://www.martinfowler.com/articles/languageWorkbench.html＃InternalDsl}.}
Indeed, in langauges such as \CC{}, fluent APIs
  often make extensive use of operator overloading (examine, e.g., \textsf{AraRat}~\cite{Gil:Lenz:10}),
  but this capability is not available in \Java.

Despite this limitation, fluent API in \Java can be rich and expressive, as demonstrated
  in \cref{Figure:DSL} showing use cases of the DSL of Apache Camel~\cite{Ibsen:Anstey:10}
(open-source integration framework),
and that of jOOQ\urlref{http://www.jooq.org}, a framework for writing
  SQL in \Java, much like Linq~\cite{There:must:be:something:in:data:set}.
Other examples of fluent APIs in \Java are abundant: jMock, Hamcrest,~\cite{find:manY:more:and:put:urlref:to:these}.

\begin{figure}[H]
  \caption{\label{Figure:DSL} Two examples of \Java fluent API}
  \begin{tabular}{@{}c@{}c@{}}
    \parbox[c]{44ex}{\javaInput[left=0ex]{camel-apache.java.fragment}} &
    \hspace{-3ex} \parbox[c]{59ex}{\javaInput[left=0ex]{jOOQ.java.fragment}} ⏎
    \textbf{(a)} Apache Camel                                          & \textbf{(b)} jOOQ
  \end{tabular}
\end{figure}

Inspired by the theory of formal languages and pushdown automata
this study explores the of what can be done, and what can not be done, with fluent API in \Java.
Consider of some fluent API definition, permitting only certain call
chains and disallowing all others.
Now, think of the formal language that defines the set of these permissible chains.
The main contribution of this paper is a proof (with its implicit algorithm) that
there is always \Java type definition that \emph{realizes} this fluent definition, provided that this
language is \emph{deterministic context-free}, where
\begin{itemize}
  \item In saying that a type definition \emph{realizes} a definition of fluent
    API, we mean that call chains that conform with the API definition compile
    correctly, and, conversely, call chains that are forbidden by the API
    definition do not type-check, resulting in an appropriate compiler error.
  \item Roughly speaking, deterministic context free languages are those
    context free languages that can be recognized by an LR parser~†{The ‟L"
    means reading the input left to right; the ‟R" stands for rightmost derivation}~\cite{Aho:86}.
    An important property of this family is that none of its members is ambigious.
\end{itemize}

A problem related to that of recognition a formal langauge,
  is that of parsing, i.e., creating a parse tree for input which is within the language.
In the fluent APIs domain the distinction between recognition and parsing is
  the distinction between compile time and runtime.
Before a program is run, the compiler checks whether the fluent API call is legal,
  and code completion tools will only suggest legal extensions of a current call chain.

In contrast, the parse tree is created at runtime.
Some fluent API definitions create the parse-tree
  iteratively, where each method invocations in the call chain adding
  more components to this tree.
However, it is always possible to genererate this tree in ‟batch” mode:
This is done by maintaining an ordered list of the methods
  called---each method inovacation adding to this list an item containg the method's name
  parameters.
The parse tree is by applying some appropriate parser to this list
  once it is complete.

\begin{wrapfigure}[9]r{35.05ex}
\caption{\label{Figure:box}Fluent API of a box object, defined by a DFA}
% \begin{tabular}[align=center]{m{7ex} | m{9ex} @{}| m{9ex}}
% & \cc{open()} & \cc{close()}⏎ \hline
% ‟closed”\ & \color{blue}{\emph{become ‟open”}} & \color{red}{\emph{runtime error}}⏎\hline
% ‟open” & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‟closed”}}⏎
% \end{tabular}

  \input ../Figures/open-close-example.tikz
  % suggested improved visualisation
\end{wrapfigure}

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box}
may receive two method invocations: \cc{open()} and \cc{close()},
and can be in either ‟open” or ‟closed” state,
Initially the instance is ‟closed”.
Its behavior henceforth is defined by \cref{Figure:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, more generally
  blue, or accepting states in the figure, type-check.
Conversely, with this type definition, compile time type error should occur in \cc{\kk{new} Box.close()},
  and, more generally, in the red state.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary classes extending it, an appropriate method definition here and there, etc.

The proof makes a general recipe for handling examples of this sort:
\begin{itemize}
  \item First, consider the language defined by the fluent API\@.
        In the box example, this language is defined by the regular expression:
        \[
          L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}\:|\:ε\big).
        \]
  \item Second, check whether this language is deterministic context-free.
        If it is, the fluent API can be realized, and,
        there is an algorithm to produce the respective type definition.
        In the box example, since language~$L$ is specified by a regular expression,
        it is trivially deterministic context-free.
        \par
        It follows from the proof that there exists a type definition
        which realizes the box example.
        Moreover, there is a way
        to automatically produce this type definition.
\end{itemize}

The proof is a construction of a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{deterministic context free language}.
With the generated types and methods, the compilation process of
  any chain of fluent API calls, actually runs the pushdown automaton against the
  specific input string that the chain represents.
When used appropriately, if this run of the automaton ends with an accepting state†{The acceptance of a PDA can also be defined by an empty stack, we will use the accepting state type of PDAs},
  then the fluent API chain type checks correctly.
If however this run ends with a failure, i.e., non-accepting state,
  compile time error will occur.

The algorithm for generating the pushdown automaton is unfortunately impractical.
It is indeed polynomial time and space,
  yet a consumer of formidable resources.

One may ask whether our theoretical result is the
  best possible:
It is possible to implement a fluent API for general
  (that is, nondeterministic) context free languages?
  We give reason why this possibility is unlikely.
