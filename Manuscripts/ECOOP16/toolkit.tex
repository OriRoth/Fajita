This section presents techniques of type encoding in \Java.
Some readers may prefer to skip through to the next section,
where these are employed in the proof of \Cref{Theorem:Gil-Levy}.

Let~$g:Γ↛Γ$ be a partial function,
  from the finite set~$Γ$ into itself.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary-function} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.%
†{Unless otherwise stated,
      all code exerpts here represent full implementations,
      and automatically extracted, omitting headers and footers,
    from \Java programs that compile correctly with a \Java 8 compiler}

\begin{figure}[hbt]
  \caption{\label{Figure:unary-function}%
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{%
      \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{%
      \javaInput[left=0ex]{gamma.listing}
    }%
    &
    \hspace{-18ex}
    \parbox[c]{0.84\linewidth}{%
      \javaInput[left=0ex,toprule=3pt,leftrule=3pt,bottomrule=3pt]{gamma-example.listing}
    }%
⏎
\textbf{(a)} type hierarchy & \textbf{(b)} implementation & \hspace{-62ex} \textbf{(c)} use cases
  \end{tabular}
\end{figure}

The type hierarchy depicted in~\cref{Figure:unary-function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The remaining two classes are private final class~\cc{¤} that stands for an error value,
  and abstract class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.†{The use
  short names, e.g.,~\cc{$Γ$} instead of \cc{$Γ'.Γ$},
    is made possible by to an appropriate \kk{import} statement.
    For brevity, all \kk{import} statements are omitted.}

The full implementation of these classes is provided in~\cref{Figure:unary-function}(b)†{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary-function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Three recurring idioms employed in~\cref{Figure:unary-function}(b) are:
\begin{enumerate}
  \item An~\kk{abstract} class encodes a set.
    Abstract classes that extend it encode
      subsets, while~\kk{final} classes encode set members.
  \item The interest of frugal management of name-spaces is served
    by the agreement that if a class~\cc{$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}\cc{;} command.
      This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
†{%
A consequence of these idioms is that the augmented class~\cc{$Γ'$} is visible to clients.
It can be made~\cc{private}. Just move class~\cc{$Γ$} to outside of~\cc{$Γ'$}, defying the second idiom.
}
\end{enumerate}

Having seen how how inheritance and overriding make possible
  the encoding of unary functions, we turn now to encoding higher arity functions.
With the absence of multi-methods, other techniques must be used.

Consider the partial binary function~$f: R⨉S↛Γ$, defined by
\begin{equation}
  \label{Equation:simple-binary}
  \begin{array}{ccc}
    R=❴r₁,r₂❵ & f(r₁,s₁)=γ₁ & f(r₂,s₁)=γ₁⏎
    S=❴s₁,s₂❵ & f(r₁,s₂)=γ₂ & f(r₂, s₂)=⊥
  \end{array}.
\end{equation}
A \Java type encoding of this definition of function~$f$
  is in~\cref{Figure:simple-binary}(a); use cases
    are in~\cref{Figure:simple-binary}(b).

\begin{figure}[hbt]
  \caption{\label{Figure:simple-binary}%
    Type encoding of partial binary function~$f:R⨉S↛Γ$,
    where~$R=❴r₁,r₂❵$,~$S=❴s₁,s₂❵$, and~$f$
    is specified by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$,~$f(r₂,s₁)=γ₁$, and~$f(r₂, s₂)=⊥$.}
  \begin{tabular}{cc}
    \hspace{-3.5ex}
    \parbox[c]{0.57\linewidth}{%
    \javaInput[left=0ex]{binary-function.listing}
    }
      &
    \hspace{-16ex}
    \parbox[c]{51ex}{\javaInput[minipage,leftrule=3pt,toprule=3pt,bottomrule=3pt,width=51ex]{binary-function-example.listing}}
⏎
    \parbox{0.57\linewidth}
    {\textbf{(a)} implementation (for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2},
    which is in \cref{Figure:unary-function}).}
      & \hspace{-5ex}\textbf{(b)} use cases⏎
  \end{tabular}
\end{figure}

As the figure shows, to compute~$f(r₁,s₁)$ at compile time we write~\cc{f.r1().s1()}.
Also, the fluent API call chain~\cc{f.r2().s2().g()} results in a compile time
  error precisely because~$f(r₂, s₂)=⊥$.

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of~\kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function~\cc{r1()} is class~\cc{R.r1};
  the return type of function~\cc{r2()} is class~\cc{R.r2}.

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in class~\cc{R}.
These functions are defined as~\kk{abstract} with return type~\cc{$Γ$'}
  in~\cc{R}.
Both functions are overridden in classes~\cc{r1} and~\cc{r2},
   with the appropriate co-variant change of their return type,

It should be clear now that the encoding scheme presented
  in \Cref{Figure:simple-binary} can be generalized to functions
  with any number of arguments, provided that the domain and range sets are finite.
The encoding of sets of unbounded size require means for creating an unbounded
 number of types.
Genericity can be employed to serve this end.

\begin{wrapfigure}[8]{r}{29ex}
  \caption{\label{Figure:id}%
  Covrariant return type of function \cc{id()}
  with \Java generics.
  }
  \javaInput[left=-2ex,minipage,width=29ex]{id.listing}
\end{wrapfigure}

Consider first \Cref{Figure:id} showing a a genericity based recipe for
  a function whose return type
  is the same as the receiver type.
  This recipe is applied in the figure to classes~\cc{A},~\cc{B}, and~\cc{C}.
  In each of these classes, the return type of \cc{id} is,
  without overriding, (at least) the class itself.

\Cref{Figure:stack-use-cases} shows some use cases of a type encoding of
  a stack of unbounded depth, yet can only store members of the set~$Γ$.
With type encoding these are precisely classes~\cc{$γ$1}
  and \cc{$γ$2} defined in \cref{Figure:unary-function}.

\begin{figure}[!htp]
  \caption{\label{Figure:stack-use-cases}%
    Use cases of a compile-time stack data structure.
  }
  \javaInput[minipage]{stack-use-cases.listing}
\end{figure}

The figure demonstrates a stack that starts with five items in it.
These are popped in order. Just before popping the last item, its
  value is examined.
Trying then to pop from an empty stack, or to examine its top, ends with
  a compile time error.

The expression⏎
  \mbox{\qquad\qquad} \cc{Stack.empty.$γ$1().$γ$1().$γ$2().$γ$1().$γ$1()}⏎
represents the sequence of pushing the value~$γ₁$ into an
empty stack, followed by~$γ₁$,~$γ₂$,~$γ₁$, and, finally,~$γ₁$.
This expression's type is that of variable~\cc{\_1}:⏎
\mbox{\qquad\qquad} \cc{P<$γ$1,P<$γ$1,P<$γ$2,P<$γ$1,P<$γ$1,E>>>>>}.⏎
A recurring building block occurs in this type.
This is generic type~\cc{P}, \emph{short for ‟Push”}, which takes two parameters:
  \begin{enumerate}
    \item the \emph{top} of the stack, always a subtype of~\cc{$Γ$},
    \item the \emph{rest} of the stack, which can be of two kinds:
          \begin{enumerate}
            \item another instantiation of~\cc{P} (in most cases),
            \item non-generic type~\cc{E}, \emph{short for ‟Empty”}, which encodes the empty
                  set (only at the deepest~\cc{P}, rest is empty).
          \end{enumerate}
  \end{enumerate}
Incidentally, \kk{static} field \cc{Stack.bottom} is of type~\cc{E}.

\Cref{Figure:stack-encoding}(a) gives the type inheritance hierarchy of
of type \cc{Stak} and its subtypes.
\Cref{Figure:stack-encoding}(b).
gives the implementation of these types.

\begin{figure}[!htb]
  \caption{Type encoding of an unbounded stack data structure.}
  \label{Figure:stack-encoding}
  \begin{tabular}{cc}
    \parbox[c]{0.3\linewidth}{%
      \input ../Figures/stack-classification.tikz
    } &
    \hspace{-3ex} \parbox[c]{63ex}{\javaInput[minipage]{stack.listing}}⏎
    \textbf{(a)} type hierarchy &
    \hspace{-3ex} \parbox[t]{63ex}{%
    \textbf{(b)} implementation (except
    for classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2}, which is in \cref{Figure:unary-function}).}
  \end{tabular}
\end{figure}

The code in the figure shows that the ‟rest” parameter of~\cc{P} must extend class \cc{Stack},
  and that both types~\cc{P} and~\cc{E} extend \cc{Stack}.
Other points to notice are:
\begin{itemize}
  \item The type at the top of the stack is precisely the return type of \cc{top()};
        it is overridden in~\cc{P} so that its return type is the first argument of~\cc{P}.
        The return type of \cc{top()} in~\cc{B} is the error value {$Γ'$.¤}.
  \item Pushing into the stack is encoded as functions~\cc{$γ$1()} and~\cc{$γ$2()};
        the two are overridden with appropriate covariant change of the return type in~\cc{P} and~\cc{E}.
  \item Since empty stack cannot be popped, function \cc{pop()} is overridden in~\cc{E} to return
    the \emph{error} type \cc{Stack.¤}. This type is indeed a kind of a stack, except that each of the four stack
        functions: \cc{top()}, \cc{push()},~\cc{$γ$1()}, and,~\cc{$γ$2()}, return an appropriate error type.
\end{itemize}
In fact, this recursive generic type technique can used to encode S-expressions: In the spirit of
  \cref{Figure:stack-encoding}, the idea is to make use of a \cc{Cons} generic type
  with co-variant \cc{car()} and \cc{cdr()} methods.

A standard technique of template programming in \CC is to encode conditionals with template specialization.
Since \Java forbids specialization of generics, we used in lieu covraiant overloading of function
  return type (e.g., the return type of \cc{s2()} in \cref{Figure:simple-binary} and the
  return type of of \cc{top()} in \cref{Figure:stack-encoding}).

\begin{wrapfigure}[6]r{36ex}
  \caption{\label{Figure:generic} Covariance of parameters to generics}
  \javaInput[minipage,left=-2ex]{mammal.listing}
\end{wrapfigure}

As can be seen in \cref{Figure:generic}, similar covariant change might happen in extending a generic type:
The type of the parameter (\kk{extends} \cc{Whales}) to a generic (\cc{Heap}) may
be specialized with the inheritance (class \cc{School} extending \cc{Heap}).
Similarly, the idea behind \cref{Figure:generic} will be used
  below as another idiom of conditionals.

Overloading makes a third idiom for partial emulation of conditionals, as can be seen
  in~\cref{Figure:peep}.

\begin{figure}[htb]%
  \caption{Peeping into the stack}%
  \label{Figure:peep}%
  \lstset{style=numbered}
  \javaInput[minipage,left=-2ex]{peep.listing}
\end{figure}

The figure depicts type \cc{Peep} and the overloaded versions of \cc{peep()} which can be used to
  extract the top of the stack.
The first generic parameter to \cc{Peep} is the top of the stack, the second is the stack itself.
Indeed, we see (l.6) that peeping into an empty stack, places a~\cc{?}
  in the first parameter, thanks to the first overloaded version of \cc{peep()} (l.8).

The second overloaded version of \cc{peep()} (ll.9--12) matches
 against all non-empty stacks. The return type
 of this version encodes,
 in its first parameter,
 the top of the stack.
A use case can be seen in line~4.

Let~$τ$ be the type of the top of a given stack.
Then, both \cc{top()} and \cc{peep()} can be used to extract~$τ$.
There is a subtle difference between the two though:
Obtaining~$τ$ from \cc{top()} does
  not make it possible to define variables, function return types, and
  parameters to functions and generics whose type is~$τ$ or depends on it in any way.
However, since \cc{Peep} is a type that receives~$τ$ as parameter,
  the body of \cc{Peep} is free to define e.g., functions signature includes on $\tau$, 
  or pass $\tau$ further to other generics. 
