Let~$\textsf{java}$ be a function that translates a terminal~$σ∈Σ$
into a call to a uniquely named function (with respect to~$σ$).
Let~$\textsf{java}(α)$, be the function
  that translates a string~$α∈Σ^*$ into a fluent API call chain.
  If~$α=σ₁⋯σₙ∈Σ^*$, then \[
  \textsf{java}(α)=\cc{.}\textsf{java}(σ₁)\cc{().}⋯\cc{.}\textsf{java}(σₙ)\cc{()}.
\]
For example, when~$Σ=❴a,b,c❵$ let~$\textsf{java}(a)=\cc{a}$,~$\textsf{java}(b)=\cc{b}$, and,~$\textsf{java}(c)=\cc{c}$.
With these, \[
    \textsf{java}(caba) = \cc{.c().a().b().a()}
  \]

\begin{theorem}\label{Theorem:Gil-Levy}
  Let~$D$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_D$ for types~\cc{L},~\cc{D} and
    other types such that the \Java command
  \begin{equation}
    \label{Equation:result}
    \cc{L~$ℓ$ = M.build~$\textsf{java}(α)$}\cc{.\$();}
  \end{equation}
  type checks against~$J_M$ if an only if~$α∈L$.
  Furthermore, program~$J_M$ can be effectively generated from~$M$.
\end{theorem}

\Cref{Equation:result} reads: starting from the \kk{static} field \cc{build} of \kk{class}~\cc{M},
  apply the sequence of call chain~$\textsf{java}(α)$, terminate with a call to the
  ending character~\cc{\$()} and then assign to newly declared \Java variable~\cc{$ℓ$} of type~\cc{L}.

The proof of the theorem is through a scheme for encoding in \Java types
  the pushdown automaton~$A=A(L)$ that recognizes language~$L$.
Concretely, the scheme assigns a type~$τ(c)$.
  to each possible configuration~$c$ of~$A$.
Also, the type of \cc{M.build} is type encoding of the initial configuration of~$A$,

Further, in each such type the scheme places
  a function~$σ()$ for every~$σ∈Σ$.
Suppose that~$A$ takes a transition from configuration~$c₁$ to configuration~$c₂$
  in response to an input chracter~$σ$.
Then, the return type of function \cc{$σ$()} in type~$τ(c₁)$ is type~$τ(c₂)$.

With this encoding the call chain in \cref{Equation:result} 
  mimics the computation of~$A$, starting at the initial configuration and ending with
  rejection or acceptance.
Finer details of the proof are in \cref{Section:proof}. 

Then, the type that~$a$

There are several, mostly minor, differences between the structure of the \Java code
  in \cref{Equation:result}
  and the examples of fluent API we saw above in \cref{Figure:DSL}:
\begin{description}
  \item[Prefix, i.e., the stating \cc{M.build}.]
    All variables and functions of \Java are defined within a class.
    Therefore, a call chain must start with an object (\cc{M.build} in \cref{Equation:result})
      or, in case of \cc{static} methods, with the name of a class.
    With an appropriate \cc{import} statement, this prefix can be eliminated.
  \item[Suffix, i.e., the terminal \cc{.\$()} call.]
    In order to know whether~$α∈L$ the automaton recognizing~$L$ must
      know when~$α$ is terminated.
    With some engineering work, this suffix can be eliminated, e.g., it is possible to define
      type~\cc{L} as an interface,
  \item[Parametrized methods.]
\end{description}
