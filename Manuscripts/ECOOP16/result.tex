Let~$\textsf{java}$ be a function that translates a terminal~$σ∈Σ$
into a call to a uniquely named function (with respect to~$σ$).
Let~$\textsf{java}(α)$, be the function
  that translates a string~$α∈Σ^*$ into a fluent API call chain.
If~$α=σ₁⋯σₙ∈Σ^*$, then⏎
  \mbox{\qquad\qquad}$\textsf{java}(α)=$~\cc{.}$\textsf{java}(σ₁)$\cc{().}~$⋯$~\cc{.}$\textsf{java}(σₙ)$\cc{()}⏎
For~$Σ=❴a,b,c❵$ we can define~$\textsf{java}(a)=\cc{a}$,~$\textsf{java}(b)=\cc{b}$, and,~$\textsf{java}(c)=\cc{c}$.
With these definitions,~$\textsf{java}(caba) = \cc{.c().a().b().a()}$.

\begin{theorem}\label{Theorem:Gil-Levy}
  Let~$D$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_D$ for types~\cc{L},~\cc{D} and other types with the following
  property: Consider the \Java command
  \[
    \cc{L_= M.build~$\textsf{java}(α)$}\cc{.\$();}
  \]
  (in words: starting from the \kk{static} field of \kk{class}~\cc{M},
  apply the sequence of call chain~$\textsf{java}(α)$, terminate with a call to the
  end symbol~\cc{\$()} and then assign to newly declared variable~‟\cc{\_}” of type~\cc{L}).
  Then, this command type checks against~$J_M$ if an only if~$α∈L$.
  Furthermore, program~$J_M$ can be effectively generated†{in the computability lingo:
    effective~$≈$‟~\emph{there is time
  bounded algorithm for carrying out the task}”.} from~$M$.
\end{theorem}

Several comments are in place
\begin{description}
  \item[The starting point \cc{M.build}]
  \item[The terminal \cc{.\$()} call]
  \item[Parametrized methods]
\end{description}
