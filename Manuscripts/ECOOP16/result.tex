Let~$\textsf{java}$ be a function that translates a terminal~$σ∈Σ$
into a call to a uniquely named function (with respect to~$σ$).
Let~$\textsf{java}(α)$, be the function
  that translates a string~$α∈Σ^*$ into a fluent API call chain.
If~$α=σ₁⋯σₙ∈Σ^*$, then⏎
  \mbox{\qquad\qquad}$\textsf{java}(α)=$~\cc{.}$\textsf{java}(σ₁)$\cc{().}~$⋯$~\cc{.}$\textsf{java}(σₙ)$\cc{()}⏎
For~$Σ=❴a,b,c❵$ we can define~$\textsf{java}(a)=\cc{a}$,~$\textsf{java}(b)=\cc{b}$, and,~$\textsf{java}(c)=\cc{c}$.
With these definitions,~$\textsf{java}(caba) = \cc{.c().a().b().a()}$.

\begin{theorem}\label{Theorem:Gil-Levy}
  Let~$D$ be a DPDA recognizing a language~$L⊆Σ^*$.
  Then, there exists a \Java type definition,~$J_D$ for types~\cc{L},~\cc{D} and other types with the following
  property: Consider the \Java command
  \begin{equation}
    \label{Equation:result}
    \cc{L~$ℓ$ = M.build~$\textsf{java}(α)$}\cc{.\$();}
  \end{equation}
  (in words: starting from the \kk{static} field of \kk{class}~\cc{M},
  apply the sequence of call chain~$\textsf{java}(α)$, terminate with a call to the
  end symbol~\cc{\$()} and then assign to newly declared variable~‟\cc{\_}” of type~\cc{L}).
  Then, this command type checks against~$J_M$ if an only if~$α∈L$.
  Furthermore, program~$J_M$ can be effectively generated†{in the computability lingo:
    effective~$≈$‟~\emph{there is time
  bounded algorithm for carrying out the task}”.} from~$M$.
\end{theorem}

There are several, mostly minor, differences between the structure \Java code in \cref{Equation:result}
  and the examples of fluent API we saw above in \cref{Figure:DSL}:
\begin{description}
  \item[Prefix, i.e., the stating \cc{M.build}.]
    All variables and functions of \Java are defined within a class.
    Therefore, a call chain must start with an object (\cc{M.build} in \cref{Equation:result})
      or, in case of \cc{static} methods, with the name of a class.
    With an appropriate \cc{import} statement, this prefix can be eliminated.
  \item[Suffix, i.e., the terminal \cc{.\$()} call.]
    In order to know whether~$α∈L$ the automaton recognizing~$L$ must
      know when~$α$ is terminated.
  \item[Parametrized methods.]
\end{description}
