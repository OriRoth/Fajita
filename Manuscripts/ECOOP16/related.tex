Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‟concepts” in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s in \CC are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$Cₘ$ such that
    compilation of~$Cₘ$ of terminates if and only if
      Turing-machine~$m$ halts.
  Furthermore, program~$Cₘ$ can be effectively generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‟\emph{template specialization}”).

There has already been a similiar \Java implementation for regular
  languages\urlref{https://github.com/verhas/fluflu}.
  
In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In a sense, this article shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
This objective is more precisely expressed in the following conjecture.

\cite{Mention:all:C++:template:programming}, there are many classics, including the \cite{Abrahams:Gurtovoy:04} I think. 

Mention funny tricks with annotations to Java. There is \cite{Michael:Earnst} from 
  Washington State university. He fought for more support for annotations 
  and built a system for implementing non

Mention work by \cite{Bracha} on non-standard type systems.  

Mention this \cite{German:(?):guy}, who did suggest something like ours.  

Anything else you can find.

\subsection{Type State}
There is large body of research on \emph{type-states} (See e.g., review articles such
  as~\cite{Aldrich:Sunshine:2009,Bierhoff:Aldrich:2005}).
Informally, an object that belongs to a certain type, has
type-states, if not all methods defined in this object's class are applicable
to the object in all states it may be in.

A classical example of type-states is a file object which can be in one of two
states: ‟open” or ‟closed”. Invoking a \cc{read()} method on the object is only
permitted when the file is in an ‟open” state. In addition, method \cc{open()}
(respectively \cc{close()}) can only be applied if the object is in the
‟closed” (respectively, ‟open”) state.

Objects with type states such as files are not rarities.
In fact, a recent study~\cite{Beckman:2011} estimates
  that about 7.2％ of \Java classes define protocols, that can be interpreted as type-state.
Type-state pose two main challenges to software engineering
\begin{enumerate}
  \item \emph{\textbf{Identification.}}
    In the typical case, type-state
        receive little to no mention at all in the documentation.
    The identification problem is to find the implicit
    type state in existing \Java: Given an implementation of a class
    (or more generally of a software framework),
    \emph{determine} which sequences of method calls are valid and which violate the
    type state hidden in the \Java.
  \item \emph{\textbf{Maintenance and Enforcement.}}
    Having identified the type-states, the challenge is in automatically flagging out
      illegal sequence of calls that does not conform
      with the type-state, furthermore, with the
      evolution of an API, the challenge is in updating the type-state information,
      and the type checking of \Java of clients.
\end{enumerate}

\begin{wrapfigure}[9]r{35.05ex}
\caption{\label{Figure:box}Fluent API of a box object, defined by a DFA}
% \begin{tabular}[align=center]{m{7ex} | m{9ex} @{}| m{9ex}}
% & \cc{open()} & \cc{close()}⏎ \hline
% ‟closed”\ & \color{blue}{\emph{become ‟open”}} & \color{red}{\emph{runtime error}}⏎\hline
% ‟open” & \color{red}{\emph{runtime error}} & \color{blue}{\emph{become ‟closed”}}⏎
% \end{tabular}

  \input ../Figures/open-close-example.tikz
  % suggested improved visualisation
\end{wrapfigure}

To make the proof concrete, consider this example of fluent API definition:
An instance of class \cc{Box}
may receive two method invocations: \cc{open()} and \cc{close()},
and can be in either ‟open” or ‟closed” state,
Initially the instance is ‟closed”.
Its behavior henceforth is defined by \cref{Figure:box}.

To realize this definition, we need a type definition by which \cc{\kk{new} Box().open().close()}, more generally
  blue, or accepting states in the figure, type-check.
Conversely, with this type definition, compile time type error should occur in \cc{\kk{new} Box.close()},
  and, more generally, in the red state.

Some skill is required to make this type definition: proper design of class \cc{Box}, perhaps with
  some auxiliary classes extending it, an appropriate method definition here and there, etc.

The proof makes a general recipe for handling examples of this sort:
\begin{itemize}
  \item First, consider the language defined by the fluent API\@.
        In the box example, this language is defined by the regular expression
        \[
          L = \big(\cc{.open().close()}\big)^*\big(\cc{.open()}\:|\:ε\big).
        \]
  \item Second, check whether this language is deterministic context-free.
        If it is, the fluent API can be realized, and,
        there is an algorithm to produce the respective type definition.
        In the box example, since language~$L$ is specified by a regular expression,
        it is trivially deterministic context-free.
        \par
        It follows from the proof that there exists a type definition
        which realizes the box example.
        Moreover, there is a way
        to automatically produce this type definition.
\end{itemize}

The proof is a construction of a \Java type encoding of
  the \emph{deterministic pushdown automaton} that recognizes
  a given \emph{deterministic context free language}.
With the generated types and methods, the compilation process of
  any chain of fluent API calls, actually runs the pushdown automaton against the
  specific input string that the chain represents.
When used appropriately, if this run of the automaton ends with an accepting state†{The acceptance of a PDA can also be defined by an empty stack, we will use the accepting state type of PDAs},
  then the fluent API chain type checks correctly.
If however this run ends with a failure, i.e., non-accepting state,
  compile time error will occur.
