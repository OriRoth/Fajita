Modern programming languages acquire high-level constructs
  at a staggering rate.
The imminent adoption of closures in \Java and \CC,
  the generators of \CSharp, and ‟concepts” in
  \CC are just a few examples.

A theoretical motivation for this work
  is the exploration of the computational
  expressiveness of such features.
For example, it is known (see e.g.,~\cite{Gutterman:2003}) that
  \kk{template}s in \CC are Turing complete in the following precise sense:

\begin{Theorem}
  \label{Theorem:Gutterman}
  For every Turing machine,~$m$, there exists a \CC program,~$Cₘ$ such that
    compilation of~$Cₘ$ of terminates if and only if
      Turing-machine~$m$ halts.
  Furthermore, program~$Cₘ$ can be effectively†{in the computability lingo:
    effective~$≈$‟~\emph{there is time
  bounded algorithm for carrying out the task}”.} generated from~$m$.
\end{Theorem}

Intuitively, the proof relies on the fact that \kk{template}s
  feature recursive invocation and conditionals (in the form of
  ‟\emph{template specialization}”).

In the same fashion, it is mundane to make the judgment that
  \Java's generics are not Turing-complete: all recursive calls
  in these are unconditional.
In a sense, this article shall give a lower bound on the
  expressive power of \Java generics in terms of the Chomsky hierarchy~\cite{Chomsky:1963}.
This objective is more precisely expressed in the following conjecture.

\cite{Mention all \CC template programming}, there are many classics, including the \cite{BOOST library} I think. 

Mention funny tricks with annotations to Java. There is \cite{Michael Earnst} from 
  Washington State university. He fought for more support for annotations 
  and built a system for implementing non

Mention work by \cite{Bracha} on non-standard type systems.  

Mention this German (?) guy, who did suggest something like ours.  

Anything else you can find.

\subsection{Type State}
The toilette seat problem may be amusing to some, but it is not contrived in
any way. In fact, there is huge body of research on the general topics of
\emph{type-states}. (See e.g., review articles such
as~\cite{Aldrich:Sunshine:2009,Bierhoff:Aldrich:2005}) Informally, an object
that belongs to a certain type (\kk{class} in the object oriented lingo), has
type-states, if not all methods defined in this object's class are applicable
to the object in all states it may be in.

A classical example of type-states is a file object: which can be in one of two
states: ‟open” or ‟closed”. Invoking a \cc{read()} method on the object is only
permitted when the file is in an ‟open” state. In addition, method \cc{open()}
(respectively \cc{close()}) can only be applied if the object is in the
‟closed” (respectively, ‟open”) state.

Objects with type states such as toilette seats and files are not rarities.
In fact, a recent study~\cite{Beckman:2011} estimates
  that about 7.2％ of \Java classes define protocols, that can be interpreted as type-state.
Type-state pose two main challenges to software engineering
\begin{enumerate}
  \item \emph{\textbf{Identification.}}
    In the typical case, type-state
        receive little to no mention at all in the documentation.
    The identification problem is to find the implicit
    type state in existing JAVA: Given an implementation of a class
    (or more generally of a software framework),
    \emph{determine} which sequences of method calls are valid and which violate the
    type state hidden in the JAVA.
  \item \emph{\textbf{Maintenance and Enforcement.}}
    Having identified the type-states, the challenge is in automatically flagging out
      illegal sequence of calls that does not conform
      with the type-state, furthermore, with the
      evolution of an API, the challenge is in updating the type-state information,
      and the type checking of JAVA of clients.
\end{enumerate}
