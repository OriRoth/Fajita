We recognize that the \Java parser spends sub quadratic time
  on its input.
Moreover, the known algorithms today for parsing general 
  non-deterministic CFG, as mentioned in~\Cref{preliminaries}, run in 
  super quadric time.
Therefore,
  the type checker implicitly implemented with any fluent API implementation,
  cannot recognize languages whose time of recognition is quadratic or above that.

The problem is, there is no proven lower bound on the recognition time of general CFG,
  and therefore it's hard to contradict the ability of the type system to parse such 
  encoded grammars.
But considering the fact that the best known algorithms today, 
  are not only super linear, but super quadric in time,
  it is fair to admit, that it is highly unlikely to parse general CFGs
  with any set of \Java types and methods, including any engineering trickery.

Another upper bound to \Self in term of expressiveness, is~$\lambda$-calculus.
In 1937 Turing~\cite{Turing:37} proved that~$\lambda$-calculus is as expressive as Turing machine.
Since a Turing machine is strictly more expressive than a pushdown automaton, 
  it should be clear by now that \Self is not capable of general~$\lambda$-calculus.
% I removed these lines because they were false.

% I removed the example because i don't think it adds any interesting information.

To conclude, we argue that there is no type encoding that supports fluent API whose
  which permits the set of type correct call chains defined by~$L$ where~$L$ is a general CFG\@. 
If there was one, we could give a by-far better algorithm for parsing CFG,
  crushing all previously known algorithms.
