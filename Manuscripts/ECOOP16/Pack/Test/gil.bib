@STRING{&	= " and " }
@STRING{acm	= "{ACM} Press" }
@STRING{ahoav	= "Aho, Alfred V." }
@STRING{aldrichje="Aldrich, Jonathan Erik" }
@STRING{annconf	= " Ann. Conf. on " }
@STRING{arnoldk	= "Arnold, Ken" }
@STRING{aw	= "Addison-Wesley" }
@STRING{awad	= "Reading, MA" }
@STRING{brachag	= "Bracha, Gilad" }
@STRING{ecoop	= " Euro. Conf. on {OO} Prog." }
@STRING{eighteenth="18\textsuperscript{\textit{th}}" }
@STRING{esec	= " European Soft. Eng. Conf." }
@STRING{fse	= " {ACM SIGSOFT} Symp. on the Foundations of Soft. Eng." }
@STRING{goldberga="Goldberg, Adele" }
@STRING{gosling	= "Gosling, James" }
@STRING{gpce	= " Conf. on Generative Prog. \& Component Eng." }
@STRING{hopcroft= "Hopcroft, John E." }
@STRING{icmd	= " {ACM} {SIGMOD} Int. Conf. on Management of Data" }
@STRING{inf&ctrl= "Information and Control" }
@STRING{jcommunications="Comm. of the {ACM}" }
@STRING{jcr	= "{C++} Report" }
@STRING{knuthde	= "Knuth, Donald Ervin" }
@STRING{lncs	= "{LNCS}" }
@STRING{mst	= "Math. Sys. Theory" }
@STRING{odersky	= "Odersky, Martin" }
@STRING{oopsla	= " {OO} Prog. Sys., Lang., \& Appl." }
@STRING{procthe	= "Proc. of the " }
@STRING{sigplan	= " {ACM SIGPLAN} Notices" }
@STRING{sixth	= "6\textsuperscript{\textit{th}}" }
@STRING{stroustrup="Stroustrup, Bjarne" }
@STRING{sv	= "Springer" }
@STRING{tenth	= "10\textsuperscript{\textit{th}}" }
@STRING{third	= "3\textsuperscript{\textit{rd}}" }
@STRING{thirteenth="13\textsuperscript{\textit{th}}" }
@STRING{twentyfifth="25\textsuperscript{\textit{th}}" }
@STRING{twentyfirst="21\textsuperscript{\textit{st}}" }
@STRING{twentyfourth="24\textsuperscript{\textit{th}}" }
@STRING{twentysixth="26\textsuperscript{\textit{th}}" }
@STRING{ullman	= "Ullman, Jeffrey D." }
@STRING{usenixcc= " {USENIX} {C++} Conf." }
@STRING{veldhuizentl="Veldhuizen, Todd L." }

@Book{		  aho:sethi:ullman:86,
  ordinal	= "B56",
  author	= ahoav # & # {Ravi Sethi and } # ullman,
  title		= "Compilers: Principles, Techniques, and Tools",
  year		= 1986,
  publisher	= aw,
  address	= awad,
  isbn		= "0-201-10194-7",
  reviewer	= "John Levine, comp.compilers moderator",
  abstract	= "Describes clearly and completely lexing and parsing
		  techniques including the ones in yacc and lex. The authors
		  work or have worked at Bell Labs with Steve Johnson and
		  Mike Lesk, the authors of Yacc and Lex.",
  anote		= "SYSNO 2003115 [Library] TECHNION U.D.C. 681.3.068 -
		  519.685.3"
}

@Book{		  chomsky:1963,
  title		= {Formal properties of grammars},
  author	= {Chomsky, Noam},
  year		= 1963,
  publisher	= aw
}

@Book{		  autebert:97,
  author	= {Autebert, Jean-Michel and Berstel, Jean and Boasson, Luc},
  pages		= {111--174},
  publisher	= sv,
  title		= {Context-Free Languages and Pushdown Automata},
  year		= 1997
}

@Book{		  ibsen:anstey:10,
  title		= {Camel in action},
  author	= {Ibsen, Claus and Anstey, Jonathan},
  year		= 2010,
  publisher	= {Manning Publications Co.},
  address	= {Shelter Island, NY}
}

@Book{		  arnold:gosling:96,
  ordinal	= "B92",
  author	= arnoldk # & # gosling,
  title		= "The \textsc{Java} Programming Language",
  year		= 1996,
  address	= awad,
  publisher	= aw,
  series	= "The {Java} Series",
  isbn		= "0-201-63455-4",
  referencedby	= "\cite{1998:icse:baniassad}, \cite{1998:oois:kristensen},
		  \cite{1998:tr:walker:a}"
}

@Book{		  linz:2001,
  abstract	= {Written to address the fundamentals of formal languages,
		  automata, and computabilty, An Introduction to Formal
		  Languages and Automata provides an accessible,
		  student-friendly presentation of all material essential to
		  an introductory Theory of Computation course. It is
		  designed to familiarize students with the foundations and
		  principles of computer science and to strengthen the
		  students' ability to carry out formal and rigorous
		  mathematical arguments. In the new Fifth Edition, Peter
		  Linz continues to offer a straightforward, uncomplicated
		  treatment of formal languages and automata and avoids
		  excessive mathematical detail so that students may focus on
		  and understand the underlying principles. In an effort to
		  further the accessibility and comprehension of the text,
		  the author has added new illustrative examples and
		  exercises throughout. There is a substantial amount of new
		  material in the form of two new appendices, and a CD-ROM of
		  JFLAP exercises authored by Susan Rodger of Duke
		  University. The first appendix is an entire chapter on
		  finite-state transducers. This optional chapter can be used
		  to prepare students for further related study. The second
		  appendix offers a brief introduction to JFLAP; an
		  interactive software tool that is of great help in both
		  learning the material and in teaching the course. Many of
		  the exercises in the text require creating structures that
		  are complicated and that have to be tested for correctness.
		  JFLAP can greatly reduce students’ time spent on testing
		  as well as help them visualize abstract concepts. The
		  CD-ROM that accompanies this fifth edition expands this and
		  offers exercises specific for JFLAP.},
  author	= {Linz, Peter},
  isbn		= {0763714224},
  publisher	= {Jones {\&} Bartlett Learning},
  title		= {An Introduction to Formal Languages and Automata},
  year		= 2011
}

@Book{		  stroustrup:book:97,
  ordinal	= "B102",
  author	= stroustrup,
  title		= "The {C++} Programming Language",
  year		= 1997,
  edition	= third,
  publisher	= aw,
  address	= awad,
  callnumber	= "QA76.73.C153S77 1997 97-20239",
  isbn		= "0-201-88954-4",
  booksite	= "http://www.research.att.com/~bs/3textsuperscripttextitrd.html",
  authorsite	= "http://www.research.att.com/~bs/homepage.html",
  anote		= "ISBN 0-201-88954-4 and 0-201-70073-5. International
		  Student Edition.1998. Addison Wesley Longman. ISBN
		  0-201-43569-1. German translation 1998; ISBN 3-8273-1296-5.
		  Spanish translation 1998; ISBN 84-7829-019-2. Japanese
		  translation 1998; ISBN 4-7561-1895-X. Russian translation
		  1999; Binom Publshers; ISBN 5-7940-0031-7. French
		  Translation 1999; CampusPress; ISBN 2-7440-0609-2. Chinese
		  translation 1999; Addison-Wesley Longman and Scholars
		  Books, Taiwan; ISBN 957-981524-0. Swedish translation 2000;
		  Bonnier Ekerlid Data, Stockholm; ISBN 0-201-67504-8.
		  Finnish translation 2000; Teknolit; ISBN 951-846-026-4.
		  Polish translation 2000; ISBN 83-204-2375-9. Portugese
		  translation 2000; Bookman, Porto Alegre, Brazil. ISBN
		  85-7307-699-29. Italian translation. Addison Wesley Longman
		  Italia. Milano. 2000. ISBN 88-7192-078-3. Greek
		  translation. Klidarythmos Computer Books. 2001. ISBN
		  960-332-142-7."
}

@Book{		  hopcroft:ullman:01,
  author	= hopcroft # { and Motwani, Rajeev and } # ullman,
  edition	= {\nth{2}},
  publisher	= aw,
  title		= {Introduction to automata theory, languages, and
		  computation},
  year		= 2001
}

@Book{		  goldberg:book:84,
  ordinal	= "B185",
  author	= goldberga,
  title		= "{Smalltalk}-80: The Interactive Programming Environment",
  shorttitle	= "{Smalltalk}-80: The Interactive Prog. Env.",
  publisher	= aw,
  address	= awad,
  year		= 1984
}

@Book{		  austern:98,
  author	= "Matthew H. Austern",
  title		= "Generic programming and the {STL}: using and extending the
		  {C++} Standard Template Library",
  year		= 1998,
  isbn		= "0-201-30956-4",
  publisher	= aw
}

@Book{		  abrahams:gurtovoy:04,
  author	= "David Abrahams and Aleksey Gurtovoy",
  title		= "{C++} Template Metaprogramming: Concepts, Tools, and
		  Techniques from Boost and Beyond",
  series	= "{C++} in Depth Series",
  year		= 2004,
  isbn		= 0321227255,
  publisher	= aw
}

@Book{		  vandevoorde:josuttis:02,
  author	= "David Vandevoorde and Nicolai M. Josuttis",
  title		= "\CC Templates: The Complete Guide",
  publisher	= aw,
  year		= 2002
}

@InProceedings{	  meijer:beckman:bierman:06,
  author	= "Erik Meijer and Brian Beckman and Gavin Bierman",
  title		= "{LINQ}: Reconciling Objects, Relations and {XML} in the
		  {.NET} Framework",
  key		= "ICMD'06",
  booktitle	= procthe # icmd # " (ICMD'2006)",
  address	= "Chicago, Illinois",
  year		= "2006"
}

@Article{	  deursen:2000,
  abstract	= {We survey the literature available on the topic of
		  domain-specific languages as used for the construction and
		  maintenance of software systems. We list a selection of 75
		  key publications in the area, and provide a summary for
		  each of the papers. Moreover, we discuss terminology, risks
		  and benefits, example domain-specific languages, design
		  methodologies, and implementation techniques.},
  author	= {Deursen, Arie Van and Klint, Paul and Visser, Joost},
  doi		= {10.1145/352029.352035},
  isbn		= {0362-1340},
  issn		= {03621340},
  journal	= {ACM Sigplan Notices},
  number	= 6,
  pages		= {26--36},
  title		= {Domain-specific languages: an annotated bibliography},
  url		= {http://portal.acm.org/citation.cfm?doid=352029.352035},
  volume	= 35,
  year		= 2000
}

@Article{	  veldhuizen:95,
  ordinal	= "P677",
  author	= veldhuizentl,
  title		= "Expression Templates",
  journal	= jcr,
  volume	= 7,
  number	= 5,
  pages		= "26--31",
  year		= 1995,
  month		= jun,
  xnote		= "Reprinted in C++ Gems, ed. Stanley Lippman"
}

@InCollection{	  dehnert:stepanov:2000,
  title		= {Fundamentals of generic programming},
  author	= {Dehnert, James C. and Stepanov, Alexander},
  booktitle	= {Generic Programming},
  pages		= {1--11},
  year		= 2000,
  publisher	= sv
}

@InCollection{	  backhouse:jansson:1999,
  title		= {Generic Programming},
  author	= {Backhouse, Roland and Jansson, Patrik and Jeuring, Johan
		  and Meertens, Lambert},
  booktitle	= {Advanced Functional Programming},
  pages		= {28--115},
  year		= 1999,
  publisher	= sv
}

@Article{	  kabanov:2008,
  abstract	= {Projects like jMock and Hibernate Criteria Query
		  introduced embedded DSLs into \Java. We describe two case
		  studies in which we develop embedded typesafe DSLs for
		  building SQL queries and engineering \Java bytecode. We
		  proceed to extract several patterns useful for developing
		  typesafe DSLs for arbitrary domains. Unlike most previous
		  \Java DSLs we find that mixing the Fluent Interface idiom
		  with static functions, metadata and closures provides for a
		  better user experience than pure method chaining. We also
		  make very liberal use of the \Java 5 Generics to improve
		  the type safety properties of the DSLs.},
  author	= {Kabanov, Jevgeni and Raudj{\"{a}}rv, Rein},
  doi		= {10.1145/1411732.1411758},
  publisher	= aw,
  isbn		= 9781605582238,
  journal	= {Proceedings of the \nth{6} international symposium on
		  Principles and practice of programming in \Java - PPPJ '08},
  keywords	= {domain-specific,dsl,java,typesafe},
  title		= {Embedded typesafe domain specific languages for {\Java}},
  year		= 2008
}

@Book{		  cocke:1969,
  author	= {Cocke, John},
  publisher	= {Courant Institute of Mathematical Sciences, New York
		  University},
  title		= {Programming Languages and Their Compilers: Preliminary
		  Notes},
  year		= 1969
}

@Article{	  earley:1970,
  abstract	= {A parsing algorithm which seems to be the most efficient
		  general context-free algorithm known is described. It is
		  similar to both Knuth's LR(k) algorithm and the familiar
		  top-down algorithm. It has a time bound proportional to n3
		  (where n is the length of the string being parsed) in
		  general; it has an n2 bound for unambiguous grammars; and
		  it runs in linear time on a large class of grammars, which
		  seems to include most practical context-free programming
		  language grammars. In an empirical comparison it appears to
		  be superior to the top-down and bottom-up algorithms
		  studied by Griffiths and Petrick.},
  author	= {Earley, Jay},
  doi		= {10.1145/362007.362035},
  isbn		= {0001-0782},
  issn		= {00010782},
  journal	= jcommunications,
  number	= 2,
  pages		= {94--102},
  title		= {An efficient context-free parsing algorithm},
  volume	= 13,
  year		= 1970
}

@Article{	  younger:1967,
  abstract	= {A recognition algorithm is exhibited whereby an arbitrary
		  string over a given vocabulary can be tested for
		  containment in a given context-free language. A special
		  merit of this algorithm is that it is completed in a number
		  of steps proportional to the “cube” of the number of
		  symbols in the tested string. As a byproduct of the
		  grammatical analysis, required by the recognition
		  algorithm, one can obtain, by some additional processing
		  not exceeding the “cube” factor of computational
		  complexity, a parsing matrix—a complete summary of the
		  grammatical structure of the sentence. It is also shown
		  how, by means of a minor modification of the recognition
		  algorithm, one can obtain an integer representing the
		  ambiguity of the sentence, i.e., the number of distinct
		  ways in which that sentence can be generated by the
		  grammar. The recognition algorithm is then simulated on a
		  Turing Machine. It is shown that this simulation likewise
		  requires a number of steps proportional to only the
		  “cube” of the test string length.},
  author	= {Younger, Daniel H.},
  doi		= {10.1016/S0019-9958(67)80007-X},
  issn		= {00199958},
  journal	= inf&ctrl,
  number	= 2,
  pages		= {189--208},
  title		= {Recognition and parsing of context-free languages in time
		  {$n^3$}},
  url		= {http://www.sciencedirect.com/science/article/pii/S001999586780007X},
  volume	= 10,
  year		= 1967
}

@Article{	  courcelle:77,
  author	= {Courcelle, Bruno},
  isbn		= {90-71301-40-0},
  journal	= mst,
  pages		= {87--109},
  title		= {On Jump-Deterministic Pushdown Automata},
  volume	= 11,
  year		= 1977
}

@Article{	  knuth:65,
  abstract	= {There has been much recent interest in languages whose
		  grammar is sufficiently simple that an efficient
		  left-to-right parsing algorithm can be mechanically
		  produced from the grammar. In this paper, we define LR(k)
		  grammars, which are perhaps the most general ones of this
		  type, and they provide the basis for understanding all of
		  the special tricks which have been used in the construction
		  of parsing algorithms for languages with simple structure,
		  e.g., algebraic languages. We give algorithms for deciding
		  if a given grammar satisfies the LR(k) condition, for given
		  k, and also give methods for generating recognizes for
		  LR(k) grammars. It is shown that the problem of whether or
		  not a grammar is LR(k) for some k is undecidable, and the
		  paper concludes by establishing various connections between
		  LR(k) grammars and deterministic languages. In particular,
		  the LR(k) condition is a natural analogue, for grammars, of
		  the deterministic condition, for languages.},
  author	= knuthde,
  doi		= {10.1016/S0019-9958(65)90426-2},
  issn		= {00199958},
  journal	= inf&ctrl,
  number	= 6,
  pages		= {607--639},
  title		= {On the translation of languages from left to right},
  volume	= 8,
  year		= 1965
}

@Misc{		  hibernate:06,
  title		= "{Hibernate} product homepage",
  year		= 2006,
  howpublished	= "http://www.hibernate.org/",
  author	= "{JBoss Group}"
}

@Manual{	  bison:manual,
  author	= {Donnelly, Charles and Stallman, Richard},
  title		= {Bison},
  publisher	= {Free Software Foundation},
  year		= 2015
}

@TechReport{	  odersky:altherr:cremet:emir:maneth:micheloud:mihaylov:schinz:stenman:zenger:04,
  ordinal	= "P887",
  author	= { Martin Odersky} # & # "Altherr, Philippe" # &
		# {Vincent Cremet and Burak Emir and Sebastian Maneth and
		  St\'ephane Micheloud and Nikolay Mihaylov and Michel Schinz
		  and Erik Stenman and Matthias Zenger },
  title		= "An Overview of the {Scala} Programming Language",
  institution	= {EPFL Lausanne, Switzerland},
  year		= 2004,
  number	= {IC/2004/64},
  booksite	= "http://lampwww.epfl.ch/~odersky/papers/ScalaOverview.html;
		  http://scala.epfl.ch/docu/files/- ScalaOverview.pdf;
		  http://zenger.gmxhome.de/papers/tr_scala.pdf",
  authorsite	= "http://zenger.org/research.html",
  xaddress	= "\'{E}cole Polytechnique F\'{e}d\'{e}rale de Lausanne, 1015
		  Lausanne, Switzerland",
  anote		= "previous title is ''Essential Traits of Scala''",
  abstract	= "Scala fuses object-oriented and functional programming in
		  a statically typed programming language. It is aimed at the
		  construction of components and component systems. This
		  paper gives an overview of the Scala language for readers
		  who are familiar with programming methods and programming
		  language design."
}

@MastersThesis{	  gutterman:2003,
  title		= {Turing Templates---On \CC Compile Time Power},
  author	= {Gutterman, Zvi},
  school	= {Technion---Israel Institute of Technology},
  year		= 2003
}

@InCollection{	  musser:stepanov:1989,
  title		= {Generic programming},
  author	= {Musser, David R. and Stepanov, Alexander A.},
  booktitle	= {Symbolic and Algebraic Computation},
  pages		= {13--25},
  year		= 1989,
  publisher	= sv
}

@MastersThesis{	  larsen:2012,
  author	= {Larsen, Robert},
  school	= {University of Oslo},
  title		= {Fluenty: A type safe query {API}},
  year		= 2012
}

@MastersThesis{	  papi:08,
  abstract	= {This paper introduces the Checker Framework, which
		  supports adding pluggable type systems to the \Java
		  language in a backward-compatible way. A type system
		  designer defines type qualifiers and their semantics, and a
		  compiler plug-in enforces the semantics. Programmers can
		  write the type qualifiers in their programs and use the
		  plug-in to detect or prevent errors. The Checker Framework
		  is useful both to programmers who wish to write error-free
		  code, and to type system designers who wish to evaluate and
		  deploy their type systems. The Checker Framework includes
		  new \Java syntax for expressing type qualifiers;
		  declarative and procedural mechanisms for writing
		  type-checking rules; and support for flow-sensitive local
		  type qualifier inference and for polymorphism over types
		  and qualifiers. The Checker Framework is well-integrated
		  with the \Java language and toolset. We have evaluated the
		  Checker Framework by writing 5 checkers and running them on
		  over 600K lines of existing code. The checkers found real
		  errors, then confirmed the absence of further errors in the
		  fixed code. The case studies also shed light on the type
		  systems themselves.},
  author	= {Papi, Matthew M},
  doi		= {10.1145/1390630.1390656},
  isbn		= {9781605580500},
  keywords	= {annotation,bug finding,case
		  study,compiler,flow,igj,immutable,intern,java,javac,javari,nonnull,pluggable
		  type,polymorphism,readonly,sensitivity,type qualifier,type
		  sys},
  pages		= 87,
  school	= {Massachusetts Institute of Technology},
  title		= {Practical pluggable types for {\Java}},
  url		= {http://portal.acm.org/citation.cfm?doid=1390630.1390656},
  year		= 2008
}

@InProceedings{	  bodden:14,
  abstract	= {Typestate analyses determine whether a program's use of a
		  given API obeys this API's usage constraints in the sense
		  that the right methods are called on the right objects in
		  the right order. Previously, we and others have described
		  approaches that generate typestate analyses from textual
		  finite-state property definitions written in specialized
		  domain-specific languages. While such an approach is
		  feasible, it requires a heavyweight compiler, hindering an
		  effective integration into the programmer's development
		  environment and thus often also into her
		  software-development practice. Here we explain the design
		  of a pure-\Java interface facilitating both the definition
		  and evaluation of typestate analyses. The interface is
		  fluent, a term coined by Eric Evans and Martin Fowler.
		  Fluent interfaces provide the user with the possibility to
		  write method-invocation chains that almost read like
		  natural-language text, in our case allowing for a seemingly
		  declarative style of typestate definitions. In all
		  previously described approaches, however, fluent APIs are
		  used to build configuration objects. In this work, for the
		  first time we show how to design a fluent API in such a way
		  that it also encapsulates actual computation, not just
		  configuration. We describe an implementation on top of
		  Soot, Heros and Eclipse, which we are currently evaluating
		  together with pilot customers in an industrial context at
		  Fraunhofer SIT.},
  author	= {Bodden, Eric},
  booktitle	= {Proceedings of the \nth{3} ACM SIGPLAN International
		  Workshop on the State of the Art in \Java Program Analysis
		  - SOAP '14},
  doi		= {10.1145/2614628.2614629},
  file		= {:home/tomerlevi/Downloads/bodden14ts4j.pdf:pdf},
  isbn		= {9781450329194},
  keywords	= {dynamic analysis,fluent interfaces,static analysis},
  pages		= {1--6},
  title		= {{TS4J} : A Fluent Interface for Defining and Computing
		  Typestate Analyses},
  url		= {http://dl.acm.org/citation.cfm?doid=2614628.2614629
		  http://www.bodden.de/pubs/bodden14ts4j.pdf},
  year		= 2014
}

@InProceedings{	  gil:lenz:07,
  author	= {Gil, Joseph (Yossi) and Lenz, Keren},
  title		= {Simple and Safe {SQL} Queries with \CC Templates},
  pages		= {13--24},
  numpages	= 12,
  keywords	= {C++, databases, domain specific languages, embedded
		  languages, relational algebra, structural type equivalence,
		  template programming},
  crossref	= {GPCE:07}
}

@Proceedings{	  gpce:07,
  key		= "{GPCE'07}",
  editor	= {Consel, Charles},
  title		= procthe # sixth # gpce,
  month		= oct,
  booktitle	= procthe # sixth # gpce,
  publisher	= acm,
  series	= lncs,
  year		= 2007,
  address	= {Salzburg, Austria},
  isbn		= {978-1-59593-855-8}
}

@InProceedings{	  aldrich:sunshine:2009,
  author	= {Aldrich, Jonathan and Sunshine, Joshua and Saini, Darpan
		  and Sparks, Zachary},
  title		= {Typestate-oriented Programming},
  crossref	= {OOPSLA:09},
  pages		= {1015--1022},
  numpages	= 8,
  url		= {http://doi.acm.org/10.1145/1639950.1640073},
  doi		= {10.1145/1639950.1640073},
  acmid		= 1640073,
  keywords	= {objects, paradigms, permissions, programming language,
		  states, types, typestate}
}

@InProceedings{	  erdweg:2011,
  author	= {Erdweg, Sebastian and Kats, Lennart C.L. and Rendel,
		  Tillmann and K\"{a}stner, Christian and Ostermann, Klaus
		  and Visser, Eelco},
  title		= {SugarJ: Library-based Language Extensibility},
  pages		= {187--188},
  numpages	= 2,
  keywords	= {dsl embedding, language extensibility, language workbench,
		  library},
  crossref	= {OOPSLA:11}
}

@InProceedings{	  freeman:pryce:06,
  abstract	= {This paper describes the experience of evolving a
		  domain-specific language embedded in \Java over several
		  generations of a test framework. We describe how the
		  framework changed from a library of classes to an embedded
		  language. We describe the lessons we have learned from this
		  experience for framework developers and language
		  designers.},
  author	= {Freeman, Steve and Pryce, Nat},
  keywords	= {embedded domain-specific language,java,mock},
  title		= {Evolving an embedded domain-specific language in {\Java}},
  crossref	= {Companion:OOPSLA:06}
}

@InProceedings{	  garcia:jarvi:lumsdaine:siek:willcock:03,
  ordinal	= "P946",
  author	= "Ronald Garcia and Jaakko J{\"a}rvi and Andrew Lumsdaine
		  and Jeremy Siek and Jeremiah Willcock",
  title		= "A comparative study of language support for generic
		  programming",
  pages		= "115--134",
  crossref	= {OOPSLA:03},
  session	= "Generics"
}

@InProceedings{	  bracha:odersky:stoutamire:wadler:98,
  author	= brachag # & # odersky # & # "David Stoutamire" # &
		# "Philip Wadler",
  title		= "Making the future safe for the past: Adding Genericity to
		  the {Java} Programming Language",
  shorttitle	= "Making the future safe for the past",
  useetal	= 1,
  pages		= "183--200",
  crossref	= "OOPSLA:98"
}

@Proceedings{	  oopsla:11,
  editor	= {Fisher, Kathleen},
  address	= {Portland OR, USA},
  title		= procthe # twentysixth # annconf # oopsla # " (OOPSLA'10)",
  booktitle	= procthe # twentysixth # annconf # oopsla # " (OOPSLA'10)",
  key		= "OOPSLA'11",
  publisher	= acm,
  month		= oct # {22-27},
  year		= 2011
}

@Proceedings{	  oopsla:09,
  editor	= {Gary Leavens},
  title		= procthe # twentyfourth # annconf # oopsla # " (OOPSLA'09)",
  booktitle	= procthe # twentyfourth # annconf # oopsla # " (OOPSLA'09)",
  isbn		= {978-1-60558-768-4},
  address	= {Orlando, FL, USA},
  publisher	= acm,
  month		= oct,
  year		= 2009,
  key		= "OOPSLA'09"
}

@Proceedings{	  companion:oopsla:06,
  editor	= {Peri L. Tarr and William R. Cook},
  title		= {Companion of the } # twentyfirst
		# { Annual {ACM SIGPLAN} Conf. on} # oopsla
		# {, OOPSLA 2006},
  booktitle	= procthe # {OOPSLA'06 Companion},
  publisher	= acm,
  year		= 2006,
  month		= oct # {22-26},
  key		= "OOPSLA'06 Companion"
}

@Proceedings{	  oopsla:03,
  editor	= "Ron Crocker and Guy L. Steele Jr.",
  address	= {Anaheim, CA, USA},
  title		= procthe # eighteenth # annconf # oopsla # " (OOPSLA'03)",
  booktitle	= procthe # eighteenth # annconf # oopsla # " (OOPSLA'03)",
  key		= "OOPSLA'03",
  month		= oct,
  year		= 2003,
  isbn		= {1-58113-712-5},
  publisher	= sigplan # { 38 (11)},
  bibsource	= {DBLP, http://dblp.uni-trier.de},
  url		= "http://www.informatik.uni-trier.de/~ley/db/conf/oopsla/oopsla2003p.html",
  issn		= "0362-1340",
  xeditor	= {Ron Crocker and Guy L. Steele Jr.}
}

@Proceedings{	  oopsla:98,
  editor	= {Freeman, Bj{\o}rn N. {-}Benson and Chambers, Craig },
  address	= {Vancouver, BC, Canada},
  title		= procthe # thirteenth # annconf # oopsla # " (OOPSLA'98)",
  booktitle	= procthe # thirteenth # annconf # oopsla # " (OOPSLA'98)",
  month		= oct # {18-22},
  publisher	= sigplan # " 33(10)",
  key		= "OOPSLA'98",
  year		= 1998
}

@InProceedings{	  gil:gutterman:98,
  author	= "Joseph Gil and Zvi Gutterman",
  title		= "Compile Time Symbolic Derivation with {C++} Templates.",
  pages		= "249--264",
  crossref	= "USENIX:C++:98"
}

@Proceedings{	  usenix:c++:98,
  title		= procthe # usenixcc,
  booktitle	= procthe # usenixcc,
  year		= 1998,
  month		= apr,
  address	= "Santa Fe, NM",
  days		= "27-30",
  publisher	= "USENIX Association",
  key		= "USENIX C++'98"
}

@InProceedings{	  beckman:11,
  title		= {An empirical study of object protocols in the wild},
  author	= {Beckman, Nels E. and Kim, Duri and } # aldrichje,
  pages		= {2--26},
  crossref	= {ECOOP:11}
}

@Proceedings{	  ecoop:11,
  address	= {Lancaster, UK},
  month		= jun # {25-29},
  key		= "ECOOP'11",
  publisher	= sv,
  series	= lncs,
  title		= procthe # twentyfifth # ecoop # " (ECOOP'11)",
  booktitle	= procthe # twentyfifth # ecoop # " (ECOOP'11)",
  year		= 2011,
  editor	= "Mezini, Mira",
  volume	= 6813
}

@InProceedings{	  bierhoff:aldrich:2005,
  author	= {Kevin Bierhoff} # & # aldrichje,
  title		= {Lightweight object specification with typestates},
  pages		= {217--226},
  crossref	= {ESEC:05}
}

@Proceedings{	  esec:05,
  title		= procthe # tenth # esec # & # thirteenth # fse
		# " (ESEC/FSE'05)",
  address	= {Lisbon, Portugal},
  editor	= {Michel Wermelinger and Harald C. Gall},
  publisher	= acm,
  month		= sep,
  year		= 2005,
  booktitle	= procthe # tenth # esec # & # thirteenth # fse
		# " (ESEC/FSE'05)",
  key		= "ESEC'05"
}
