\title{%
  Formal Language Recognition with the Java Type Checker 
  \newline
  \color{red}{%
    \rmfamily\scshape Thou Mortal, Be Warned. \newline
    Thou Shallt Not Remove \newline
    This Commandment \newline
    While There Are Signs of Haste \newline
    in This Document!!!!\newline
  }
}

\documentclass[a4paper,USenglish]{lipics}
\usepackage{\jobname}

%\author{Tome Levy⏎
% Department of Computer Science⏎
% Technion---Israel Institute of Technology⏎
% \texttt{\small \href{mailto:stlevy@campus.technion.ac.il}{stlevy@campus.technion.ac.il}}}

\author{Anonymized for the submission}
\begin{document}
\let\INPUT=\input
\def\input#1{}

\maketitle
\begin{abstract}
  \input{abstract}
\end{abstract}

\section{Introduction}
\input{aa}

\textbf{Outline.}
\Cref{Section:fluent} is a brief reminder of fluent APIs 
  and DSLs, and is followed by a similar reminder of 
  context-free languages, pushdown automata, and the such in \cref{Section:pushdown}.
Based on the vocabulary established in these, 
  the main result is stated in~\cref{Section:result}.
\Cref{Section:related} offers a perspective on related work.

Towards the proof in \cref{Section:proof}, \cref{Section:toolkit} 
  shows idioms and techniques for encoding computation with    
  the \Java type-checker.
\Cref{Section:jump} makes use of these for encoding 
  ``jump-stack'', a non-trivial data-structure.
Finally, issues that might be raised in converting 
  this work into a practical tool are discussed in \cref{Section:zz},
    which sketches also directions for further research.

\section{Background I/II: Method Chaining \emph{vs.} Fluent API}
\label{Section:fluent}
\input{fluent}

\section{Background II/II: Context Free Languages and Pushdown Automata: Reminder and Terminology}
\label{Section:pushdown}
\input{pushdown}

\section{Statement of the Main Result} 
\label{Section:result}
\input{result}

\section{Related Work}
\label{Section:related}
\input{related}

\section{Techniques of Type Encoding}
\label{Section:toolkit}
\input{toolkit}

\section{The Jump-Stack Data-Structure}
\label{Section:jump}
\input{jump}

\section{Proof of \Cref{Theorem:Gil-Levy}}
\label{Section:proof}
\let\input=\INPUT
\INPUT{proof}

\section{Discussion and Future Work}
\label{Section:zz}
\input{zz}
\textbf{Acknowledgment.}
Inspiring correspondence with Gilad Bracha is gratefully acknowledged. 

\bibliographystyle{abbrv}\small
\bibliography{author-names,other-shorthands,%
  publishers-abbreviated,%
  conferences-abbreviated,%
  journals-abbreviated,journals-full,%
  yogi-book,yogi-practice,yogi-journal,%
  GPCE,OOPSLA,PLDI,USENIX,%
  00,yogi-confs}

\appendix
\section{Use Cases of the Automaton $A$}
\begin{quote}
  \javaInput[left=0ex,minipage,width=\textwidth]{proof.cases.listing}
\end{quote}
\vfill
\eject
\section{Full Type Encoding of Automaton $A$}
\begin{quote}
  \javaInput[left=0ex,minipage,width=\textwidth]{proof.full.listing}
\end{quote}


\end{document}

Processing programming languages
\begin{description}
  \item[Lexical analysis] - the first step of the process in which the character strings generated by the
  programmer are aggregated to the abstract tokens defined by the language designer.
  \item[Syntactical analysis (parsing) ] - the second step, in which the processed strings of tokens
  conform to the rules of a formal grammar defined by the language's BNF (or EBNF).
  \item[Semantical analysis] - the next step, usually performed in unison with the previous step,
  in which the legal token sequences are given their semantic meaning.
\end{description}
Specifically, the proposal is that API design of follows the footsteps of
Accordingly, the designer of a fluent API has to follow these three conceptual
steps.
First is the identification of the \emph{vocabulary}, i.e.,
the set of method calls including type arguments that may take part in the
fluent API\@.
In this fluent API example
\begin{JAVA}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{JAVA}
then, there are three method calls, and the vocabulary has three items in it.
\begin{itemize}
  \item~$ℓ₁ = \cc{any(Class<?>)}$
  \item~$ℓ₂ = \cc{allowing($ℓ₁$)}$
  \item~$ℓ₃ = \cc{method(String)}$
  \item~$ℓ₄ = \cc{withNoArguments()}$
\end{itemize}
