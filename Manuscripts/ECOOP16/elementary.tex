\subsection{Type encoding of unary (non-partial) functions}
Let~$g: T \rightarrow T $ be a (non-partial) unary function,
  where the set~$T$ is finite and containable.
Then, it is possible to have a compile-time representation of $g$,
  meaning, to have the mapping of g happen at compile-time.  
\Cref{Figure:unary:function} is a demonstration of a possible encoding
of function $g$, and an use example.  

\begin{figure}
  \begin{Code}{Java}
static abstract class T {¢¢ // Set ¢$T$¢
  abstract T g();
  static final class t1 extends T {¢¢ // Value ¢$t₁∈T$¢
    final t2 g() {¢¢ return null; }
  }
  static final class t2 extends T {¢¢ // Value ¢$t₂∈T$¢
    final t1 g() {¢¢ return null; }
  }
}
\end{Code}
  \caption{Encoding of the unary function~$g: T→T$,
  defined by~$T=\left\{ t_1,t_2 \right\}$,~$f(t₁)=t₂$,~$f(t₂)=t₁$.}
  \label{Figure:unary:function}
\end{figure}

\begin{code}{Java}
  t2 x = new t1().g();
  t1 y = new t2().g();
\end{code}

\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
  where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$ within the framework of \Java's type system.
Before showing how this is done in the general case, consider this example, 
where~$T$ and $g$ are defined as in \cref{Figure:unary:function}:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}.

\begin{figure}
  \begin{Code}{Java}
abstract class R {¢¢ // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R {¢¢ // Value ¢$r₁∈R$¢
    t1 s1() {¢¢ return null; }
    t2 s2() {¢¢ return null; }
  }
  static final class r2 extends R {¢¢ // Value ¢$r₂∈R$¢
    t2 s1() {¢¢ return null; }
    ¢$⊥$¢ s2() {¢¢ return null; }
  }
  static abstract class T extends T¢$⁺$¢ {¢¢ // Set ¢$T⊂T⁺$¢
    abstract T g();
  }
  abstract class T¢$⁺$¢ {¢¢ // Set ¢$T∪❴⊥❵~$¢
    static final class ¢$⊥$¢ extends T¢$⁺$¢ {¢¢ /* empty */ } // Error Value ¢$⊥∈T⁺$¢
    static abstract class T extends T¢$⁺$¢ {¢¢ ¢…¢ } // Set ¢$T⊂T⁺$¢
  }
}
\end{Code}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).
  The body of classes \cc{T} as well the full implementation of classes \cc{t1} and \cc{t2} is not included here, and is
    in \cref{Figure:unary:function}.}
  \label{Figure:simple:binary}
\end{figure}

With the above definitions, we obtain:
\begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type
f.r1().s2().g(); // ¢✓¢
f.r2().s1().g(); // ¢✓¢
f.r2().s2().g(); // ¢✗¢ compile time error, function ¢\cc{g()}¢ is undefined for type ¢$T⁺$¢.
\end{JAVA}
We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function 
  (i.e., former $f$) are ``passed'' by invoking a method on the reciever (i.e., r1(),s1() in the former example).

Here is the general process for general sets $R$,$S$,$T$ and function $f$:
First, generate an abstract class \cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
Similarly, generate an abstract class \cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named \cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
