\subsection{Type encoding of unary (non-partial) functions}
Let~$g: T→T~$ be a (non-partial) unary function,
  where the set~$T$ is finite and containable.
Then, it is possible to have a compile-time representation of~$g$,
  meaning, to have the mapping of g happen at compile-time.
\cref{Figure:unary:function} is a demonstration of a possible encoding
of function~$g$.

\begin{figure}[hbt]
  \begin{Code}{Java}
static abstract class T {¢¢ // Set ¢$T$¢
  abstract T g();
  static final class t1 extends T {¢¢ // Value ¢$t₁∈T$¢
    final t2 g() {¢¢ return null; }
  }
  static final class t2 extends T {¢¢ // Value ¢$t₂∈T$¢
    final t1 g() {¢¢ return null; }
  }
}
\end{Code}
  \caption{Encoding of the unary function~$g: T→T$,
  defined by~$T=\left❴ t₁,t₂ \right❵$,~$f(t₁)=t₂$,~$f(t₂)=t₁$.}
  \label{Figure:unary:function}
\end{figure}
In this example, class \cc{T} represents the set~$T$, and classes
  \cc{$t₁$},\cc{$t₂$} that extends \cc{T}, represents the values~$t₁,t₂∈T~$.
  The implemented inheritance model between sets and set objects will be further used in this article.

Following, is a use example of function~$g$ defined and implemented in \cref{Figure:unary:function}

\begin{code}{Java}
  t2 x = new t1().g();
  t1 y = new t2().g();
\end{code}

Note that we have the return value of~$g$ (represented by an object of type~$t₁$) at compile-time.

\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
  where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$ within the framework of \Java's type system.
Before showing how this is done in the general case, consider this example,
where~$T$ and~$g$ are defined as in \cref{Figure:unary:function}:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}.

\begin{figure}[hbt]
  \begin{Code}{Java}
abstract class R {¢¢ // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R {¢¢ // Value ¢$r₁∈R$¢
    t1 s1() {¢¢ return null; }
    t2 s2() {¢¢ return null; }
  }
  static final class r2 extends R {¢¢ // Value ¢$r₂∈R$¢
    t2 s1() {¢¢ return null; }
    ¢$⊥$¢ s2() {¢¢ return null; }
  }
  static abstract class T extends T¢$⁺$¢ {¢¢ // Set ¢$T⊂T⁺$¢
    abstract T g();
  }
  abstract class T¢$⁺$¢ {¢¢ // Set ¢$T∪❴⊥❵~$¢
    static final class ¢$⊥$¢ extends T¢$⁺$¢ {¢¢ /* empty */ } // Error Value ¢$⊥∈T⁺$¢
    static abstract class T extends T¢$⁺$¢ {¢¢ ¢…¢ } // Set ¢$T⊂T⁺$¢
  }
}
\end{Code}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).
  The body of classes \cc{T} as well the full implementation of classes \cc{t1} and \cc{t2} is not included here, and is
    in \cref{Figure:unary:function}.}
  \label{Figure:simple:binary}
\end{figure}

With the above definitions, we obtain:
\begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type is ¢\cc{t2}¢
f.r1().s2().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s1().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s2().g(); // ¢✗¢ compile time error, function ¢\cc{g()}¢ is undefined for type ¢$T⁺$¢.
\end{JAVA}

\begin{figure}[h]
  \lstinputlisting[style=JAVA]{stack.listing} 
  \caption{Stack encoding}
  \label{Figure:stack:encoding}
\end{figure}


Note, that the implemented inheritance model previously used, is now extended to express the partiality
  of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritence:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class \cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
Similarly, generate an abstract class \cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named \cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
