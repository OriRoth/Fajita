Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary:function} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}%
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{%
      \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \hspace{-18ex}
    \parbox[c]{0.84\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma-example.listing
      }
    }%
⏎
(a) type hierarchy & (b) implementation & \hspace{-62ex} (c) use cases
  \end{tabular}
\end{figure}

The type hierarchy depicted in~\cref{Figure:unary:function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The remaining two classes are private final class~\cc{¤} that stands for an error value,
  and abstract class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.

The full implementation of these classes is provided in~\cref{Figure:unary:function}(b)†{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary:function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in~\cref{Figure:unary:function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}~\cc{;} command.  
      This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must then be moved outside of class~\cc{$Γ'$}

We saw that unary functions can be encoded with inheritance and overriding.
With the absence of multi-methods, encoding higher arity functions is a greater challenge.

Consider a partial binary function~$f: R⨉S↛Γ$; sets~$R$,~$S$ and~$Γ$ being finite.
Specifically, let
\begin{equation}
  \label{Equation:simple:binary}
  \begin{array}{rcl}
    R & = & ❴ r₁, r₂❵⏎
    S & = & ❴ s₁, s₂❵⏎
    f & = & ❴ ⟨r₁, s₁,γ₁⟩, ⟨r₁, s₂,γ₂⟩, ⟨r₂, s₁,γ₂⟩ ❵ ⊂ R⨉S⨉Γ
  \end{array}
\end{equation}

A \Java type encoding for the function~$f$ defined in~\cref{Equation:simple:binary}
  can be found in~\cref{Figure:simple:binary}(a).
As can be seen in the use cases in~\cref{Figure:simple:binary}(b),
  to compute~$f(r₁,s₁)$ we write~\cc{f.r1().s1()}.

\begin{figure}[hbt]
  \caption{\label{Figure:simple:binary}%
  Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
  defined in~\cref{Equation:simple:binary}. The implementation of the classes~\cc{$Γ$},\cc{$Γ'$} 
  as well as~\cc{$\gamma1$} and~\cc{$\gamma2$} is not included here, and is
  in \cref{Figure:unary:function}.}

  \begin{tabular}{cc}
   \hspace{-2.5ex}
   \parbox[c]{0.57\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file = binary-function.listing
    }
   }
   &
   \hspace{-2.5ex}
   \parbox[c]{0.48\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function-example.listing
    }
   }
⏎
   \hspace{-7ex}(a) implementation & \hspace{-5ex}(b) use cases⏎
  \end{tabular}
\end{figure}

The use cases in \cref{Figure:simple:binary}(b), demonstrate
  that to compute~$f(r₁,s₁)$ we write~\cc{f.r1().s1()}
  and that the fluent API call chain~\cc{f.r2().s2()} yields
  a compile time error since~$f(r₂, s₂)=⊥$.

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of~\kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function~\cc{r1()} is~\kk{class}~\cc{R.r1};
  the return type of function~\cc{r2()} is~\kk{class}~\cc{R.r2}.

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in  class~\cc{R}.
These functions are defined as~\kk{abstract} with return type~\cc{$Γ$'}
  in~\cc{R}. 
They are overridden, with the appropriate co-variant change of the return type,
  in classes~\cc{r1} and~\cc{r2}.
We use the notion ‟type-method” for this type of implementation.

It should be clear now that the encoding scheme presented in \Cref{Figure:simple:binary} can be generalized to functions
  with any number of arguments, as long as the domain and range sets are finite. 
%The encoding of sets of unbounded size require means for creating an unbounded 
%  number of types. 
%Genericity is employed to serve this end, as demonstrated in \cref{Figure:stack-use-cases}.

\subsection{Encoding of the Stack Data Structure}
The encoding of partial functions serves us at our attempts to prove~\Cref{Theorem:Gil:Levy},
  as the challenge of encoding a general function with \Java's type system seems conceivable.
While it got us closer, we still miss a major, non-trivial for encoding construct, 
  which is the PDA's stack.
In this section an encoding of such stack will be provided.

First, it is important to understand the non-triviality of encoding the stack with \Java's type system.
  The stack ADT†{\textbf{Abstract Data Structure}} that a PDA employs is an \emph{unbounded} data structure,
  meaning it can have any finite number of stack symbols†{In~\textbf{Theorem of Automata}, the pushdown automaton's stack is filled with stack symbols}.
Since plainly only a finite set of \Java classes can be generated, we must heavily rely on \Java Generics in order to
  implement this stack.

A type hierarchy of such stack can be found in~\cref{Figure:stack:encoding}(a), 
  while we also provide the full \Java type encoding in~\cref{Figure:stack:encoding}(b).

\begin{figure}[htb]
  \caption{\label{Figure:stack:encoding} Type encoding of a stack data structure} 
    \begin{tabular}{cc}
      \hspace{-12ex}
      \parbox[c]{0.3\linewidth}{%
        \input ../Figures/stack-classification.tikz
      }
      &
      \hspace{1ex}
      \parbox[c]{0.86\linewidth}{%
	\tcbinputlisting{%
	  codebox=Java,
	  listing options={style=Java},
	  listing inputencoding=utf8,
	  listing file=stack.listing}
      }
⏎
      \hspace{-12ex} (a) type hierarchy & (b) implementation
    \end{tabular}
\end{figure}

The type hierarchy in~\cref{Figure:stack:encoding}(a) is rooted by the main~\kk{class}~\cc{Stack<Tail>}.
The former represents an abstract stack, that can be in different concrete states: Empty stack(will be denoted by~\cc{bottom}),
  non-empty stack, and an error state(appearing when trying to~\cc{pop()} from~\cc{bottom}).
Each of these states is represented by a class in~\cref{Figure:stack:encoding}.
\kk{class}~\cc{Stack.B} represents the empty stack,~\kk{class}~\cc{Stack.¤} represents the error state,
  while \kk{class}~\cc{Stack.P<Head,Tail>}(short for Push) serves as a non-empty stack.
The latter has two type parameters: the first is the top stack symbol, while the second is the rest of the stack.

~\cref{Figure:stack:encoding}(b) % TODO: FINISH DESCRIPTION OF CODE
This class has a single type parameter, denoting the~\cc{Tail} of the stack, because Tail is a
  of a raw~\cc{Stack} type, the depth of this type stack is bounded, and depends on the argument~\cc{Tail}.
\cc{Stack<Tail>} has the two basic methods~\cc{pop()} and~\cc{top()} that return objects of types~\cc{Tail} and~\cc{\Gamma'}
  correspondingly (meaning~\cc{top()} is allowed to return the error class).
  
% TODO: INTRODUCE CODE EXAMPLES
\begin{figure}[htb]
  \caption{\label{Figure:stack-use-cases}%
    Use cases of a compile-time stack data structures.
  }
  \tcbinputlisting{%
    codebox=Java,
    minipage,
    listing options={style=Java},
    listing inputencoding=utf8,
    listing file=stack-use-cases.listing
  }
\end{figure}

% TODO: ELABORATE ON EXAMPLES