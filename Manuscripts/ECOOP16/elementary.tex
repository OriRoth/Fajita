\newcommand\javaInput[2][]{\tcbinputlisting{codebox=Java,listing options={style=Java},listing file=#2,#1}}

Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary-function} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.

\begin{figure}[hbt]
  \caption{\label{Figure:unary-function}%
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{%
      \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{%
      \javaInput{gamma.listing}
    }%
    &
    \hspace{-18ex}
    \parbox[c]{0.84\linewidth}{%
      \javaInput{gamma-example.listing}
    }%
⏎
(a) type hierarchy & (b) implementation & \hspace{-62ex} (c) use cases
  \end{tabular}
\end{figure}

The type hierarchy depicted in~\cref{Figure:unary-function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The remaining two classes are private final class~\cc{¤} that stands for an error value,
  and abstract class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.†{The use
  short names, e.g.,~\cc{$Γ$} instead of \cc{$Γ'.Γ$},
    is made possible by to an appropriate \kk{import} statement.
    For brevity, all \kk{import} statements are omitted.}

The full implementation of these classes is provided in~\cref{Figure:unary-function}(b)†{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary-function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in~\cref{Figure:unary-function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}\cc{;} command.
      This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must then be moved outside of class~\cc{$Γ'$}

We saw that unary functions can be encoded with inheritance and overriding.
With the absence of multi-methods, encoding higher arity functions is a greater challenge.

Consider the partial binary function~$f: R⨉S↛Γ$, defined by
\begin{equation}
  \label{Equation:simple-binary}
  \begin{array}{ccc}
    R=❴r₁,r₂❵ & f(r₁,s₁)=γ₁ & f(r₂,s₁)=γ₁⏎
    S=❴s₁,s₂❵ & f(r₁,s₂)=γ₂ & f(r₂, s₂)=⊥
  \end{array}
\end{equation}
A \Java type encoding of this definition of function~$f$
  is in~\cref{Figure:simple-binary}(a); use cases
    are in~\cref{Figure:simple-binary}(b).

\begin{figure}[hbt]
  \caption{\label{Figure:simple-binary}%
  Type encoding of partial binary function~$f: R⨉S↛Γ$,
  where~$R=❴r₁,r₂❵$,~$S=❴s₁,s₂❵$, and~$f$
  defined by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$,~$f(r₂,s₁)=γ₁$, and~$f(r₂, s₂)=⊥$.
  The implementation of classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2} is in \cref{Figure:unary-function}.}
  \begin{tabular}{cc}
   \hspace{-2.5ex}
   \parbox[c]{0.57\linewidth}{\javaInput{binary-function.listing}}
   &
   \hspace{-16ex}
   \parbox[c]{53ex}{\javaInput[minipage,width=53ex]{binary-function-example.listing}}
⏎
   \hspace{-7ex}(a) implementation & \hspace{-5ex}(b) use cases⏎
  \end{tabular}
\end{figure}

We see that to compute~$f(r₁,s₁)$ at compile time we write~\cc{f.r1().s1()}
  and that the fluent API call chain~\cc{f.r2().s2()} yields
  a compile time error since~$f(r₂, s₂)=⊥$.

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of~\kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function~\cc{r1()} is class~\cc{R.r1};
  the return type of function~\cc{r2()} is class~\cc{R.r2}.

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in class~\cc{R}.
These functions are defined as~\kk{abstract} with return type~\cc{$Γ$'}
  in~\cc{R}.
Both functions are overridden in classes~\cc{r1} and~\cc{r2},
   with the appropriate co-variant change of their return type,

It should be clear now that the encoding scheme presented
  in \Cref{Figure:simple-binary} can be generalized to functions
  with any number of arguments, as long as the domain and range sets are finite.
The encoding of sets of unbounded size require means for creating an unbounded
 number of types.
Genericity can be employed to serve this end, as we shall see next.

%The encoding of partial functions serves us at our attempts to prove~\Cref{Theorem:Gil:Levy},
% as the challenge of encoding a general function with \Java's type system seems conceivable.
%While it got us closer, we still miss a major, non-trivial for encoding construct,
% which is the PDA's stack.
%In this section an encoding of such stack will be provided.

%First, it is important to understand the non-triviality of encoding the stack with \Java's type system.
% The stack ADT†{\textbf{Abstract Data Structure}} that a PDA employs is an \emph{unbounded} data structure,
% meaning it can have any finite number of stack symbols†{In~\textbf{Theorem of Automata}, the pushdown automaton's stack is filled with stack symbols}.
%Since plainly only a finite set of \Java classes can be generated, we must heavily rely on \Java Generics in order to
% implement this stack.

\Cref{Figure:stack-use-cases} shows some use cases of a type encoding of a stack of unbounded depth
  which is limited to storing members of the set~$Γ$.
With type encoding these are precisely classes~\cc{$γ$1}
  and \cc{$γ$2} defined in \cref{Figure:unary-function}.

\begin{figure}[htb]
  \caption{\label{Figure:stack-use-cases}%
    Use cases of a compile-time stack data structures.
  }
  \javaInput[minipage]{stack-use-cases.listing}
\end{figure}

The figure demonstrates a stack that starts with five items in it.
These are popped in order. Just before popping the last item, its 
  value is examined.
Trying then to pop from an empty stack, or to examine its top, ends with 
  a compile time error.

The expression⏎
\mbox{\qquad\qquad}\cc{Stack.empty.$γ$1().$γ$1().$γ$2().$γ$1().$γ$1();}⏎
represents the sequence of pushing the value~$γ₁$ into an
  empty stack, followed by~$γ₁$,~$γ₂$,~$γ₁$, and, finally,~$γ₁$.
The type of this expression is made explicit in examining the type of variable~\cc{\_1}⏎
\mbox{\qquad\qquad}\cc{P<$γ$1,P<$γ$1,P<$γ$¢2,P<$γ$1,P<$γ$1,E>>>>>}⏎
This compound type makes extensive use of the generic type~\cc{P} which used takes two arguments,
  first of which is the \emph{top} of the stack
    which must be a subtype of~\cc{$Γ$}.
The second argument represents the \emph{rest} of the stack, which is can be yet another instantiation
    of generic type~\cc{P}, or the non-generic type~\cc{E}, that represents the empty stack.
    Incidentally, \kk{static} field \cc{Stack.bottom} is of type~\cc{E}.

The type hierarchy of the stack in~\cref{Figure:stack-encoding}(a);
  while full \Java implementation is in~\cref{Figure:stack-encoding}(b).

\begin{figure}[htb]
  \caption{\label{Figure:stack-encoding} Type encoding of an unbounded
  stack data containing members of~$Γ$ (as defined in \cref{Figure:unary-function}).}
    \begin{tabular}{cc}
      \hspace{-12ex}
      \parbox[c]{0.3\linewidth}{%
        \input ../Figures/stack-classification.tikz
      }
      &
      \hspace{-4ex}
      \parbox[c]{75ex}{\javaInput[minipage,width=75ex]{stack.listing}}
⏎
      \hspace{-12ex} (a) type hierarchy & (b) implementation
    \end{tabular}
\end{figure}

We see that the second parameter of generic type~\cc{P} must extend class \cc{Stack},
  and that both types~\cc{P} and~\cc{E} extend \cc{Stack}.
Other points to noice are:
\begin{itemize}
  \item The type at the top of the stack is precisely the return type of function \cc{top()};
        it is overridden in~\cc{P} so that its return type is the first argument of~\cc{P}.
        The return type of \cc{top()} in~\cc{B} is the error value {$Γ'$.¤}.
  \item Pushing into the stack is encoded with functions~\cc{$γ$1()} and~\cc{$γ$2()};
        the two are overriden with appropriate covariant change of the return type in~\cc{P} and~\cc{E}.
  \item Since empty stack cannot be poposed, function \cc{pop()}, is overriden in~\cc{E} to return
        the type \cc{Stack.¤}. This type is indeed a kind of a stack, except that all four stack  
        functions: \cc{top()}, \cc{push()},~\cc{$γ$1()}, and,~\cc{$γ$2()} return appropriate error types.
\end{itemize}
