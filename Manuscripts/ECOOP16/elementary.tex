\subsection{Type encoding of unary (non-partial) functions}
Let~$g: T→T~$ be a (non-partial) unary function,
  where the set~$T$ is finite and containable.
Then, it is possible to have a compile-time representation of~$g$,
  meaning, to have the mapping of g happen at compile-time.
\cref{Figure:unary:function} is a demonstration of a possible encoding
of function~$g$.

\begin{figure}[hbt]
  \caption{Type encoding of the partial function~$g: \Gamma↛\Gamma$,
    defined by~$\Gamma=❴\gamma₁,\gamma₂❵$,~$g(\gamma₁)=\gamma₂$, while~$g(\gamma₂)=\gamma₁$ is undefined.}
  \label{Figure:unary:function}
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \parbox[c]{0.26\linewidth}{
	\input ../Figures/unary-function-classification.tikz
    }%
    &
    \parbox[c]{0.4\linewidth}{
      \tcbinputlisting{%
	      codebox=Java,
	      listing options={style=Java},
	    % minipage,
	      %width=\hsize,
	      listing inputencoding=utf8,
	      listing file=gamma.listing
      }
    }%
    &
    \parbox[c]{0.43\linewidth}{
      \tcbinputlisting{%
	      codebox=Java,
	      listing options={style=Java},
	    % minipage,
	      %width=\hsize,
	      listing inputencoding=utf8,
	      listing file=gamma-example.listing
      }
    }%
    \\
    (a) type hierarchy & (b) implementation & (c) usage
  \end{tabular}
\end{figure}

The code in the figure, comprises class \cc{T} that represents the set~$T$.
Classes \cc{t1},\cc{t2} defined within and extending class \cc{T} represent the values~$t₁,t₂∈T$.
We shall adhere to the convention demonstrated here, by which a set is defined as
an abstract class, while the members of the set are final classes.
All such members obey two rules:
They are defined within the lexical scope of the class that represents the set,
and, they extend this set.

Yet another convention that we follow, is that all functions include a return \cc{null} command and nothing else.
This is to stress that at runtime, the code does not carry out any useful or interesting computation. 
The class structure is solely for providing compile-time type checks.
Indeed, the right-hand side of \cref{Figure:unary:function} is a little demonstration
  of these checks. 

Following, is a use example of function~$g$ defined and implemented in \cref{Figure:unary:function}


Note that we have the return value of~$g$ (represented by an object of type~$t₁$) at compile-time.

\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
  where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$ within the framework of \Java's type system.
Before showing how this is done in the general case, consider this example,
where~$T$ and~$g$ are defined as in \cref{Figure:unary:function}:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}.

\begin{figure}[hbt]
  \begin{Code}{Java}
abstract class R {¢¢ // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R {¢¢ // Value ¢$r₁∈R$¢
    t1 s1() {¢¢ return null; }
    t2 s2() {¢¢ return null; }
  }
  static final class r2 extends R {¢¢ // Value ¢$r₂∈R$¢
    t2 s1() {¢¢ return null; }
    ¢$⊥$¢ s2() {¢¢ return null; }
  }
  static abstract class T extends T¢$⁺$¢ {¢¢ // Set ¢$T⊂T⁺$¢
    abstract T g();
  }
  abstract class T¢$⁺$¢ {¢¢ // Set ¢$T∪❴⊥❵~$¢
    static final class ¢$⊥$¢ extends T¢$⁺$¢ {¢¢ /* empty */ } // Error Value ¢$⊥∈T⁺$¢
    static abstract class T extends T¢$⁺$¢ {¢¢ ¢…¢ } // Set ¢$T⊂T⁺$¢
  }
}
\end{Code}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).
  The body of classes \cc{T} as well the full implementation of classes \cc{t1} and \cc{t2} is not included here, and is
    in \cref{Figure:unary:function}.}
  \label{Figure:simple:binary}
\end{figure}

With the above definitions, we obtain:
\begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type is ¢\cc{t2}¢
f.r1().s2().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s1().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s2().g(); // ¢✗¢ compile time error, function ¢\cc{g()}¢ is undefined for type ¢$T⁺$¢.
\end{JAVA}

\begin{figure}[h]
    \caption{Encoding a stack data structure with
    \Java type system including full code (left) and type hierarchy (right)}\label{Figure:stack:encoding} 
    \begin{tabular}{cc}
         \parbox[c]{0.74\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=numbered,style=Java},
       % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
        &
         \parbox[c]{\hsize}{
          \input ../Figures/stack-classification.tikz
        }
    \end{tabular}
\end{figure}
      Note, that the implemented inheritance model previously used, is now extended to express the partiality
        of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritence:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class \cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
Similarly, generate an abstract class \cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named \cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
