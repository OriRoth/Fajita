\subsection{Type encoding of unary partial functions}
Let~$g:Γ→Γ$ be a function,
  where the set~$Γ$ is finite, then we argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
\cref{Figure:unary:function} shows a manner of doing so which
  will turn beneficial later.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$, while~$g(γ₂)=γ₁$ is undefined.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \parbox[c]{0.26\linewidth}{
  \input ../Figures/unary-function-classification.tikz
    }%
    &
    \parbox[c]{0.42\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \parbox[c]{0.84\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
      % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file = gamma-example.listing
      }
    }%
⏎
    (a) type hierarchy & (b) implementation & (c) usage\hspace{40ex}
  \end{tabular}
\end{figure}

The type hierarchy depicted in \cref{Figure:unary:function}(a) shows five classes:
Abstract class \cc{Γ} represents the set~$Γ$, final classes \cc{\gamma 1}, \cc{\gamma 2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The last two are private final class \cc{¤} that denotes error value, 
  and class \cc{$Γ'$} that denotes the set~$Γ∪❴\text{¤}❵$.
Accordingly, both \cc{¤} and \cc{$Γ$} extend \cc{$Γ'$}.

\cref{Figure:unary:function}(b) shows the full implementation of these classes.
While \cref{Figure:unary:function}(c) shows an usage example of the latter.

Note the convention we use here and henceforth: 
\begin{itemize}
  \item If class \cc{~$X$} \kk{extends} \kk{class} \cc{~$Y$}, then\cc{~$X$} is also defined
    as a \kk{static} member class of~$Y$.
  \item \kk{abstract} classes denote sets, while \kk{final} classes that extend these sets, 
    denote the members of these sets.
  \item All functions include a \kk{return} \kk{null} command and nothing else. 
    This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
    Indeed, \cref{Figure:unary:function}(c) is a little demonstration
      of these checks.
\end{itemize}

\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
  where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$ within the framework of \Java's type system.
Before showing how this is done in the general case, consider this example,
where~$T$ ($=$the former $\Gamma$ set) and~$g$ are defined as in \cref{Figure:unary:function}:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}.

\begin{figure}[hbt]
  \begin{Code}{Java}
abstract class R {¢¢ // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R {¢¢ // Value ¢$r₁∈R$¢
    t1 s1() {¢¢ return null; }
    t2 s2() {¢¢ return null; }
  }
  static final class r2 extends R {¢¢ // Value ¢$r₂∈R$¢
    t2 s1() {¢¢ return null; }
    ¢$⊥$¢ s2() {¢¢ return null; }
  }
  static abstract class T extends T¢$⁺$¢ {¢¢ // Set ¢$T⊂T⁺$¢
    abstract T g();
  }
  abstract class T¢$⁺$¢ {¢¢ // Set ¢$T∪❴⊥❵~$¢
    static final class ¢$⊥$¢ extends T¢$⁺$¢ {¢¢ /* empty */ } // Error Value ¢$⊥∈T⁺$¢
    static abstract class T extends T¢$⁺$¢ {¢¢ ¢…¢ } // Set ¢$T⊂T⁺$¢
  }
}
\end{Code}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).
  The body of classes \cc{T} as well the full implementation of classes \cc{t1} and \cc{t2} is not included here, and is
    in \cref{Figure:unary:function}.}
  \label{Figure:simple:binary}
\end{figure}

With the above definitions, we obtain:
\begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type is ¢\cc{t2}¢
f.r1().s2().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s1().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s2().g(); // ¢✗¢ compile time error, function ¢\cc{g()}¢ is undefined for type ¢$T⁺$¢.
\end{JAVA}

\begin{figure}[h]
    \caption{Encoding a stack data structure with
    \Java type system including full code (left) and type hierarchy (right)}\label{Figure:stack:encoding}
    \begin{tabular}{cc}
         \parbox[c]{0.74\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=numbered,style=Java},
       % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
        &
         \parbox[c]{\hsize}{
          \input ../Figures/stack-classification.tikz
        }
    \end{tabular}
\end{figure}
      Note, that the implemented inheritance model previously used, is now extended to express the partiality
        of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritence:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class \cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
Similarly, generate an abstract class \cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named \cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
