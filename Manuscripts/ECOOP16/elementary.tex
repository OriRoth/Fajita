\subsection{Type encoding of unary partial functions}
Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
\cref{Figure:unary:function} shows a manner of doing so which
  will turn beneficial later.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$, while~$g(γ₂)$ is undefined.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \parbox[c]{0.26\linewidth}{
  \input ../Figures/unary-function-classification.tikz
    }%
    &
    \parbox[c]{0.42\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \parbox[c]{0.84\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file = gamma-example.listing
      }
    }%
⏎
    (a) type hierarchy & (b) implementation & (c) usage\hspace{40ex}
  \end{tabular}
\end{figure}

The type hierarchy depicted in \cref{Figure:unary:function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The last two are private final class~\cc{¤} that stands for an error value,
  and class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.

The full implementation of these classes is provided in \cref{Figure:unary:function}(b).
(This actual code excerpt should be placed as a nested class of some appropriate host class.)

The use cases in \cref{Figure:unary:function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in \cref{Figure:unary:function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}~\cc{;} command.
    This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must be moved outside of class~\cc{$Γ'$}

\subsection{Higher arity functions and type-methods}
We saw that unary functions can be encoded with inheritance and overriding. 
With the absence of multi-methods, encoding of higher arity is a greater challenge. 

Consider a partial binary function~$f: R⨉S↛Γ$; sets~$R$,~$S$ and~$Γ$ being finite. 
Specifically, let
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁,γ₁⟩, ⟨r₁, s₂,γ₂⟩, ⟨r₂, s₁,γ₂⟩ ❵ ⊂R⨉S⨉Γ
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}(a), while the usage example is in
  \cref{Figure:simple:binary}(b).

\begin{figure}[h]
  \caption{ \label{Figure:simple:binary}
  Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
  defined by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$, and~$f(r₂,s₁)=γ₂$ while~$f(r₂, s₂)$ is undefined.
  The body of classes~\cc{$Γ$},\cc{$Γ'$} as well the full implementation of classes~\cc{$\gamma1$} and~\cc{$\gamma2$} is not included here, and is
    in \cref{Figure:unary:function}.}
  \begin{tabular}{cc}
   \parbox[c]{0.42\linewidth}{
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function.listing
    }
   }
   &
   \parbox[c]{0.58\linewidth}{
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function-example.listing
    }
   }
   \\
   \hspace{-7ex}(a) implementation & \hspace{-7ex}(b) usage
  \end{tabular}
\end{figure}

In the latter implementation, the concept of \emph{type-method}s is introduced.
As one might notice, set~$S$ was not defined by a corresponding class in
  the implementation, instead, these methods~\cc{s1()} and~\cc{s2()} were introduced in
  class~\cc{R}, with return type~\cc{$\Gamma'$}.
This allowes us to~\cc{@Override} the methods with the different return values of~$f$ as
 in class~\cc{r1}, and still result a compile-time error in case of the undefined mapping of~$f$
 as in class~\cc{r2}'s~\cc{s2()} method(corresponding to the undefined mapping for~$⟨r₂, s₂⟩$).
 
We use the notion ``type-method'' for an input variable of type~$T$, when in the
  corresponding implementation of this function, the sending of these arguments is done
  by invoking a corresponding method, as in the discussed example.
The feasibility of \emph{type-methods} emerges from the co-variance of return types in 
  \Java. 

\subsection{Type encoding of unbounded stack}
Returning to~\cref{Theorem:Gil:Levy} 
\begin{figure}[h]
    \caption{Encoding a stack data structure with
    \Java type system including full code (left) and type hierarchy (right)}\label{Figure:stack:encoding}
    \begin{tabular}{cc}
         \parbox[c]{0.74\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=numbered,style=Java},
       % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
        &
         \parbox[c]{\hsize}{
          \input ../Figures/stack-classification.tikz
        }
    \end{tabular}
\end{figure}

Note, that the implemented inheritance model previously used, is now extended to express the partiality
  of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritance:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class~\cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class~\cc{r} that extends~\cc{R}.
Similarly, generate an abstract class~\cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class~\cc{t} that extends~\cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named~\cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
