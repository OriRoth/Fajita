Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary:function} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}%
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{%
      \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \hspace{-18ex}
    \parbox[c]{0.84\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma-example.listing
      }
    }%
⏎
(a) type hierarchy & (b) implementation & \hspace{-62ex} (c) use cases
  \end{tabular}
\end{figure}

The type hierarchy depicted in \cref{Figure:unary:function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The last two are private final class~\cc{¤} that stands for an error value,
  and class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.

The full implementation of these classes is provided in \cref{Figure:unary:function}(b)†{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in \cref{Figure:unary:function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in \cref{Figure:unary:function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}~\cc{;} command.
    This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must be moved outside of class~\cc{$Γ'$}

We saw that unary functions can be encoded with inheritance and overriding.
With the absence of multi-methods, encoding higher arity functions is a greater challenge.

Consider a partial binary function~$f: R⨉S↛Γ$; sets~$R$,~$S$ and~$Γ$ being finite.
Specifically, let
\begin{equation}
  \label{Equation:simple:binary}
  \begin{array}{rcl}
    R & = & ❴ r₁, r₂❵⏎
    S & = & ❴ s₁, s₂❵⏎
    f & = & ❴ ⟨r₁, s₁,γ₁⟩, ⟨r₁, s₂,γ₂⟩, ⟨r₂, s₁,γ₂⟩ ❵ ⊂ R⨉S⨉Γ
  \end{array}
\end{equation}

A \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}(a).

\begin{figure}[hbt]
  \caption{\label{Figure:simple:binary}%
    Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
  defined by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$, and~$f(r₂,s₁)=γ₂$ and~$f(r₂, s₂) =⊥$.
  Classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2} are as in \cref{Figure:unary:function}.}
  \begin{tabular}{cc}
   \parbox[c]{0.57\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file = binary-function.listing
    }
   }
   &
   \hspace{-10ex}
   \parbox[c]{0.58\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function-example.listing
    }
   }
⏎
   \hspace{-7ex}(a) implementation & \hspace{-10ex}(b) use cases⏎
  \end{tabular}
\end{figure}

The use cases in \cref{Figure:simple:binary}(b), demonstrate
  that to compute~$f(r₁,s₁)$ we write \cc{f.r1().s1()}
  and that the fluent API call chain \cc{f.r2().s2()} yields
  a compile time error since~$f(r₂, s₂)=⊥$.

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of \kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function \cc{r1()} is \kk{class} \cc{R.r1} 
  and return type of function \cc{r2()} is \kk{class} \cc{R.r2}. 

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in a class
  named~\cc{f}.
These functions are defined as \kk{abstract} with return type \cc{$Γ$'}
  in class~\cc{R}.
They are overridden, with the appropriate co-variant change of the return type,
  in classes \cc{r1} and \cc{r2}.

The encoding scheme presented in \Cref{Figure:binary-function} is easy to extend to any 
  number of arguments.


In the implementation we see that see that set~$S$ was not defined by a corresponding class in
  the implementation, instead, these methods~\cc{s1()} and~\cc{s2()} were introduced in
  class~\cc{R}, with return type~\cc{$Γ'$}.
This allows us to~\cc{@Override} the methods with the different return values of~$f$ as
 in class~\cc{r1}, and still result a compile-time error in case of the undefined mapping of~$f$
 as in class~\cc{r2}'s~\cc{s2()} method(corresponding to the undefined mapping for~$⟨r₂, s₂⟩$).
We use the notion ‟type-method” for an input variable of type~$T$, when in the
  corresponding implementation of this function, the sending of these arguments is done
  by invoking a corresponding method, as in the discussed example.
The feasibility of \emph{type-methods} emerges from the co-variance of return types in
  \Java.

\begin{figure}[htb]
    \caption{Encoding a stack data structure with
    \Java type system including full code (left) and type hierarchy (right)}\label{Figure:stack:encoding}
    \begin{tabular}{cc}
      \hspace{-12ex}
         \parbox[c]{0.3\linewidth}{%
          \input ../Figures/stack-classification.tikz
        }
          &
         \parbox[c]{0.86\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
      \\
      \hspace{-12ex} (a) type hierarchy & (b) implementation
    \end{tabular}
\end{figure}

Note, that the implemented inheritance model previously used, is now extended to express the partiality
  of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritance:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class~\cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class~\cc{r} that extends~\cc{R}.
Similarly, generate an abstract class~\cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class~\cc{t} that extends~\cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named~\cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
