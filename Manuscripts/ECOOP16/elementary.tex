\subsection{Type encoding of unary partial functions}
Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
\cref{Figure:unary:function} shows a manner of doing so which
  will turn beneficial later.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$, and~$g(γ₂)$ being undefined. 
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{
  \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.46\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \hspace{-8ex}
    \parbox[c]{0.84\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma-example.listing
      }
    }%
⏎
    (a) type hierarchy & (b) implementation & (c) usage\hspace{40ex}
  \end{tabular}
\end{figure}

The type hierarchy depicted in~\cref{Figure:unary:function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The last two are private final class~\cc{¤} that stands for an error value,
  and class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.

The full implementation of these classes is provided in~\cref{Figure:unary:function}(b)\footnote{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary:function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in~\cref{Figure:unary:function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}~\cc{;} command.
    This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must be moved outside of class~\cc{$Γ'$}

\subsection{Higher arity functions and type-methods}\label{Subsection:arity}
We saw that unary functions can be encoded with inheritance and overriding.
With the absence of multi-methods, encoding of higher arity is a greater challenge.

Consider a partial binary function~$f: R⨉S↛Γ$; sets~$R$,~$S$ and~$Γ$ being finite.
Specifically, let
\begin{equation}
  \label{Equation:simple:binary}
  \begin{array}{rlc}
    R & = & ❴ r₁, r₂❵⏎
    S & = & ❴ s₁, s₂❵⏎
    f & = & ❴ ⟨r₁, s₁,γ₁⟩, ⟨r₁, s₂,γ₂⟩, ⟨r₂, s₁,γ₂⟩ ❵ ⊂ R⨉S⨉Γ
  \end{array}
\end{equation}

A \Java type encoding for the function~$f$ defined in~\cref{Equation:simple:binary}
  can be found in~\cref{Figure:simple:binary}(a).
As can be seen in the use cases in~\cref{Figure:simple:binary}(b),
  to compute~$f(r₁,s₁)$ we write \cc{f.r1().s1()}.

\begin{figure}[hbt]
  \caption{\label{Figure:simple:binary}
  Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
  defined in~\cref{Equation:simple:binary}. The implementation of the classes~\cc{$Γ$},\cc{$Γ'$} 
  as well as~\cc{$\gamma1$} and~\cc{$\gamma2$} is not included here, and is
  in \cref{Figure:unary:function}.}

  \begin{tabular}{cc}
   \parbox[c]{0.42\linewidth}{
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file = binary-function.listing
    }
   }
   &
   \parbox[c]{0.58\linewidth}{
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function-example.listing
    }
   }
⏎
   \hspace{-7ex}(a) implementation & \hspace{-7ex}(b) usage
  \end{tabular}
\end{figure}

In the implementation we see that see that set~$S$ was not defined by a corresponding class in
  the implementation, instead, these methods~\cc{s1()} and~\cc{s2()} were introduced in
  class~\cc{R}, with return type~\cc{$Γ'$}.
This allowes us to~\cc{@Override} the methods with the different return values of~$f$ as
 in class~\cc{r1}, and still result a compile-time error in case of the undefined mapping of~$f$
 as in class~\cc{r2}'s~\cc{s2()} method(corresponding to the undefined mapping for~$⟨r₂, s₂⟩$).
We use the notion ‟type-method” for an input variable of type~$T$, when in the
  corresponding implementation of this function, the sending of these arguments is done
  by invoking a corresponding method, as in the discussed example.
The feasibility of \emph{type-methods} emerges from the co-variance of return types in
  \Java.


\subsection{Encoding of the Stack Data Structure}
In~\cref{Subsection:arity} it was shown that encoding a partial binary function is possible, if
  the input and output sets are not too big. 
  These ideas and metholodies could be extended to a general, of a higher arity function.
While it got us closer to the main objective, defined in~\cref{Theorem:Gil:Levy} we still miss a major, 
  non-trivial for encoding construct, which is the PDA's stack.
In this section an encoding of such stack will be provided.

First, it is important to understand the non-triviality of encoding the stack with \Java type system.
  The stack ADT~\footnote{\textbf{Abstract Data Structure}} that a PDA employs is an \emph{unbounded} data structure,
  meaning it can have any finite number of stack symbols~\footnote{In~\textbf{Theorem of Automata}, the pushdown automaton's stack is filled with stack symbols}.
Since plainly only a finite set of \Java classes can be generated, we must heavily rely on \Java Generics.
In~\cref{Figure:stack:encoding} we provide an implementation of a plain stack.
\begin{figure}[htb]
    \caption{\label{Figure:stack:encoding}
    Encoding an unbounded stack using \Java Generics}    
    \begin{tabular}{cc}
      \hspace{-3ex}\parbox[c]{0.295\linewidth}{
	\input ../Figures/stack-classification.tikz
      }
      &
      \parbox[c]{0.74\linewidth}{
	\tcbinputlisting{%
	  codebox=Java,
	  listing options={style=Java},
	  listing inputencoding=utf8,
	  listing file=stack.listing
	}
      }
      \\
      (a) type hierarchy & \hspace{-3ex}(b) implementation
    \end{tabular}
\end{figure}

