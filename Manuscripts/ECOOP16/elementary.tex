Let~$g:Γ→Γ$ be a function,
  where set~$Γ$ is finite.
We argue that~$g$ can
  be represented using the compile-time mechanism of \Java.
  \cref{Figure:unary:function} encodes such a partial function for~$Γ=❴γ₁,γ₂❵$, where~$g(γ₁)=γ₂$
  and~$g(γ₂)=⊥$, i.e.,~$g(γ₂)$ is undefined.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}%
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$ and~$g(γ₂)=⊥$.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \hspace{-7ex}
    \parbox[c]{0.26\linewidth}{%
      \input ../Figures/unary-function-classification.tikz
    }%
    &
    \hspace{-1ex}
    \parbox[c]{0.64\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
% <<<<<<< HEAD
%     \hspace{0ex}
% =======
    \hspace{-18ex}
% >>>>>>> 79b54440f0d7193622113cc7a7bf5dca02282d81
    \parbox[c]{0.84\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma-example.listing
      }
    }%
⏎
% <<<<<<< HEAD
%     \hspace{-8ex}(a) type hierarchy & (b) implementation & \hspace{-28ex}(c) use cases
% =======
(a) type hierarchy & (b) implementation & \hspace{-62ex} (c) use cases
% >>>>>>> 79b54440f0d7193622113cc7a7bf5dca02282d81
  \end{tabular}
\end{figure}

The type hierarchy depicted in~\cref{Figure:unary:function}(a) shows five classes:
Abstract class~\cc{Γ} represents the set~$Γ$, final classes~\cc{γ1},~\cc{γ2}
  that extend~\cc{$Γ$}, represent the actual members of the set~$Γ$.
The remaining two classes are private final class~\cc{¤} that stands for an error value,
  and abstract class~\cc{$Γ'$} that denotes the augmented set~$Γ∪❴\text{¤}❵$.
Accordingly, both classes~\cc{¤} and~\cc{$Γ$} extend~\cc{$Γ'$}.

The full implementation of these classes is provided in~\cref{Figure:unary:function}(b)†{Remember that \Java admits Unicode characters in identifier names}.
This actual code excerpt should be placed as a nested class of some appropriate host class. Import statements are omitted, here and henceforth for brevity.

The use cases in~\cref{Figure:unary:function}(c) explain better
  what we mean in saying that function~$g$ is encoded in the type system:
  An instance of class~\cc{$γ$1} returns a value of type~\cc{$γ$2} upon
  method call~\cc{g()}, while
  an instance of class~\cc{$γ$2} returns a value of our~\kk{private}
  error type~\cc{$Γ'$.¤} upon the same call.

Some of the conventions employed in~\cref{Figure:unary:function}(b) and henceforth:
\begin{itemize}
  \item An~\kk{abstract} class denotes a set. Abstract classes that extend it represent
      subsets, while~\kk{final} classes that encode set members.
  \item The interest of frugal management of name-spaces is served by the agreement that if
    a class~\cc{~$X$}~\kk{extends} another class~\cc{$Y$}, then~\cc{$X$} is also defined
    as a~\kk{static} member class of class~$Y$.
  \item Body of functions is limited to a single~\kk{return}~\kk{null}~\cc{;} command.  
      This is to stress that at runtime, the code does not carry out any useful or interesting computation,
      and the class structure is solely for providing compile-time type checks.
\end{itemize}
(By these conventions the augmented class~\cc{$Γ'$} can be used by clients.
The class can be made~\cc{private} to prevent clients from using it,
  at the small price of breaking the second convention:
  Class~\cc{$Γ$} must then be moved outside of class~\cc{$Γ'$}

We saw that unary functions can be encoded with inheritance and overriding.
With the absence of multi-methods, encoding higher arity functions is a greater challenge.

Consider a partial binary function~$f: R⨉S↛Γ$; sets~$R$,~$S$ and~$Γ$ being finite.
Specifically, let
\begin{equation}
  \label{Equation:simple:binary}
  \begin{array}{rcl}
    R & = & ❴ r₁, r₂❵⏎
    S & = & ❴ s₁, s₂❵⏎
    f & = & ❴ ⟨r₁, s₁,γ₁⟩, ⟨r₁, s₂,γ₂⟩, ⟨r₂, s₁,γ₂⟩ ❵ ⊂ R⨉S⨉Γ
  \end{array}
\end{equation}

A \Java type encoding for the function~$f$ defined in~\cref{Equation:simple:binary}
  can be found in~\cref{Figure:simple:binary}(a).
As can be seen in the use cases in~\cref{Figure:simple:binary}(b),
  to compute~$f(r₁,s₁)$ we write \cc{f.r1().s1()}.

\begin{figure}[hbt]
  \caption{\label{Figure:simple:binary}%
% <<<<<<< HEAD
  Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
  defined in~\cref{Equation:simple:binary}. The implementation of the classes~\cc{$Γ$},\cc{$Γ'$} 
  as well as~\cc{$\gamma1$} and~\cc{$\gamma2$} is not included here, and is
  in \cref{Figure:unary:function}.}

% =======
%     Type-method encoding of partial binary function~$f: R⨉S↛Γ$,
%   defined by~$f(r₁,s₁)=γ₁$,~$f(r₁,s₂)=γ₂$,~$f(r₂,s₁)=γ₂$, and~$f(r₂, s₂) =⊥$.
%   Classes~\cc{$Γ$},~\cc{$Γ'$},~\cc{$γ$1}, and~\cc{$γ$2} are as in \cref{Figure:unary:function}.}
% >>>>>>> 79b54440f0d7193622113cc7a7bf5dca02282d81
  \begin{tabular}{cc}
   \hspace{-2.5ex}
   \parbox[c]{0.57\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file = binary-function.listing
    }
   }
   &
   \hspace{-2.5ex}
   \parbox[c]{0.48\linewidth}{%
    \tcbinputlisting{%
      codebox=Java,
      listing options={style=Java},
      listing inputencoding=utf8,
      listing file=binary-function-example.listing
    }
   }
⏎
   \hspace{-7ex}(a) implementation & \hspace{-5ex}(b) use cases⏎
  \end{tabular}
\end{figure}

The use cases in \cref{Figure:simple:binary}(b), demonstrate
  that to compute~$f(r₁,s₁)$ we write \cc{f.r1().s1()}
  and that the fluent API call chain \cc{f.r2().s2()} yields
  a compile time error since~$f(r₂, s₂)=⊥$.

Class~\cc{f} in the implementation sub-figure serves as
  the starting point of the little fluent API defined here.
The return type of \kk{static} member functions~\cc{r1()} and~\cc{r2()}
  is the respective sub-class of class~\cc{R}:
The return type of function \cc{r1()} is \kk{class} \cc{R.r1};
  the return type of function \cc{r2()} is \kk{class} \cc{R.r2}.

Instead of representing set~$S$ as a class,
  its members are realized as methods~\cc{s1()} and~\cc{s2()} in  class~\cc{R}.
These functions are defined as \kk{abstract} with return type \cc{$Γ$'}
  in~\cc{R}.
They are overridden, with the appropriate co-variant change of the return type,
  in classes \cc{r1} and \cc{r2}.

% <<<<<<< HEAD
% =======
It should be clear now that the encoding scheme presented in \Cref{Figure:simple:binary} can be generalized to functions
  with any number of arguments, as long as the domain and range sets are finite. 
The encoding of sets of unbounded size require means for creating an unbounded 
  number of types. 
Genericity is employed to serve this end, as demonstrated in \cref{Figure:stack-use-cases}.

\begin{figure}[htb]
  \caption{\label{Figure:stack-use-cases}%
    Use cases of a compile-time stack data structures.
  }
  \tcbinputlisting{%
    codebox=Java,
    minipage,
    listing options={style=Java},
    listing inputencoding=utf8,
    listing file=stack-use-cases.listing
  }
\end{figure}

In the implementation we see that see that set~$S$ was not defined by a corresponding class in
  the implementation, instead, these methods~\cc{s1()} and~\cc{s2()} were introduced in
  class~\cc{R}, with return type~\cc{$Γ'$}.
This allows us to~\cc{@Override} the methods with the different return values of~$f$ as
 in class~\cc{r1}, and still result a compile-time error in case of the undefined mapping of~$f$
 as in class~\cc{r2}'s~\cc{s2()} method(corresponding to the undefined mapping for~$⟨r₂, s₂⟩$).
% >>>>>>> 79b54440f0d7193622113cc7a7bf5dca02282d81
We use the notion ‟type-method” for an input variable of type~$T$, when in the
  corresponding implementation of this function, the sending of these arguments is done
  by invoking a corresponding method, as in the discussed example.
The feasibility of \emph{type-methods} emerges from the co-variance of return types in
  \Java.

% <<<<<<< HEAD
% The encoding scheme presented in \Cref{Figure:simple:binary} is easy to extend to any 
%   number of arguments.

\subsection{Encoding of the Stack Data Structure}
In~\cref{Section:elementary} it was shown that encoding a partial binary function is possible, if
  the input and output sets are not too big. 
  These ideas and metholodies could be extended to a general, of a higher arity function.
While it got us closer to the main objective, defined in~\cref{Theorem:Gil:Levy} we still miss a major, 
  non-trivial for encoding construct, which is the PDA's stack.
In this section an encoding of such stack will be provided.

First, it is important to understand the non-triviality of encoding the stack with \Java type system.
  The stack ADT~\footnote{\textbf{Abstract Data Structure}} that a PDA employs is an \emph{unbounded} data structure,
  meaning it can have any finite number of stack symbols~\footnote{In~\textbf{Theorem of Automata}, the pushdown automaton's stack is filled with stack symbols}.
Since plainly only a finite set of \Java classes can be generated, we must heavily rely on \Java Generics.
In~\cref{Figure:stack:encoding} we provide an implementation of a plain stack.
% \begin{figure}[htb]
%     \caption{\label{Figure:stack:encoding}
%     Encoding an unbounded stack using \Java Generics}    
% =======

\begin{figure}[htb]
  \caption{\label{Figure:stack:encoding} Type encoding of a stack data structure} 
% >>>>>>> 79b54440f0d7193622113cc7a7bf5dca02282d81
    \begin{tabular}{cc}
      \hspace{-12ex}
         \parbox[c]{0.3\linewidth}{%
          \input ../Figures/stack-classification.tikz
        }
          &
         \parbox[c]{0.86\linewidth}{%
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
⏎
      \hspace{-12ex} (a) type hierarchy & (b) implementation
    \end{tabular}
\end{figure}
