\subsection{Type encoding of unary (non-partial) functions}
Let~$g:Γ→Γ$ be a function,
  where the set~$Γ$ is finite, then we argue that~$g$ might
  be represented using compile-time mechanisms of \Java.
\cref{Figure:unary:function} shows a manner of doing so which
  will turn beneficial later.

\begin{figure}[hbt]
  \caption{\label{Figure:unary:function}
    Type encoding of the partial function~$g:Γ↛Γ$,
    defined by~$Γ=❴γ₁,γ₂❵$,~$g(γ₁)=γ₂$, while~$g(γ₂)=γ₁$ is undefined.
  }
  \begin{tabular}{@{}c@{}c@{}c@{}}
    \parbox[c]{0.26\linewidth}{
  \input ../Figures/unary-function-classification.tikz
    }%
    &
    \parbox[c]{0.42\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
        listing inputencoding=utf8,
        listing file=gamma.listing
      }
    }%
    &
    \parbox[c]{0.84\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=Java},
      % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file = gamma-example.listing
      }
    }%
⏎
    (a) type hierarchy & (b) implementation & (c) usage
  \end{tabular}
\end{figure}

The type hierarchy depicted in \cref{Figure:usage}(a) shows five classes:
Abstract class \cc{Γ} represent the set~$Γ$.
Final classes \cc{\gamma 1}, \cc{\gamma 2} that extend~\cc{$Γ$}, 
  are the actual members of the set~$Γ$.
(Note the convention we use here and henceforth: if class~$X$ extends class~$Y$, then~$X$ is also defined
  as a \kk{static} member class of~$Y$.
Yet another recurring convention is that abstract classes denote sets, while
  final classes that extend these, denote members of these sets.)

Private final class \cc{¤} is used for denoting error values.
Finally, class \cc{$Γ'$} denotes the set~$Γ∪❴\text{¤}❵$
Accordingly, both \cc{¤} and \cc{$Γ$} extend \cc{$Γ'$}.

\cref{Figure:usage}(b) shows the full implementation of these classes.

Yet another convention that we follow, is that all functions include a return \cc{null} command and nothing else.
This is to stress that at runtime, the code does not carry out any useful or interesting computation.
The class structure is solely for providing compile-time type checks.
Indeed, the right-hand side of \cref{Figure:unary:function} is a little demonstration
  of these checks.

Following, is a use example of function~$g$ defined and implemented in \cref{Figure:unary:function}
Note that we have the return value of~$g$ (represented by an object of type~$t₁$) at compile-time.

\subsection{Type-method encoding of partial binary functions}
Consider a partial function~$f: R⨉S↛T$,
  where the sets~$R$,~$S$ and~$T$ are all finite (and not too large).
Then, it is possible to encode~$f$ within the framework of \Java's type system.
Before showing how this is done in the general case, consider this example,
where~$T$ and~$g$ are defined as in \cref{Figure:unary:function}:
\begin{equation}
  \label{Equation:simple:binary}
\begin{split}
  R & = ❴ r₁, r₂❵⏎
  S & = ❴ s₁, s₂❵⏎
  f & = ❴ ⟨r₁, s₁, t₁⟩, ⟨r₁, s₂, t₂⟩, ⟨r₂, s₁, t₂⟩ ❵ ⊂R⨉S⨉T
\end{split}
\end{equation}
The \Java type encoding for the function~$f$ defined in \cref{Equation:simple:binary}
  can be found in \cref{Figure:simple:binary}.

\begin{figure}[hbt]
  \begin{Code}{Java}
abstract class R {¢¢ // Set ¢$R$¢
  abstract T¢$⁺$¢ s1();
  abstract T¢$⁺$¢ s2();
  static final class r1 extends R {¢¢ // Value ¢$r₁∈R$¢
    t1 s1() {¢¢ return null; }
    t2 s2() {¢¢ return null; }
  }
  static final class r2 extends R {¢¢ // Value ¢$r₂∈R$¢
    t2 s1() {¢¢ return null; }
    ¢$⊥$¢ s2() {¢¢ return null; }
  }
  static abstract class T extends T¢$⁺$¢ {¢¢ // Set ¢$T⊂T⁺$¢
    abstract T g();
  }
  abstract class T¢$⁺$¢ {¢¢ // Set ¢$T∪❴⊥❵~$¢
    static final class ¢$⊥$¢ extends T¢$⁺$¢ {¢¢ /* empty */ } // Error Value ¢$⊥∈T⁺$¢
    static abstract class T extends T¢$⁺$¢ {¢¢ ¢…¢ } // Set ¢$T⊂T⁺$¢
  }
}
\end{Code}
  \caption{Type-method encoding of partial binary function~$f: R⨉S↛T$,
  defined by~$f(r₁,s₁)=t₁$,~$f(r₁,s₂)=t₂$, and~$f(r₂,s₁)=t₂$ (while~$f(r₂, s₂) =⊥$).
  The body of classes \cc{T} as well the full implementation of classes \cc{t1} and \cc{t2} is not included here, and is
    in \cref{Figure:unary:function}.}
  \label{Figure:simple:binary}
\end{figure}

With the above definitions, we obtain:
\begin{JAVA}
f.r1().s1().g(); // ¢✓¢ returned type is ¢\cc{t2}¢
f.r1().s2().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s1().g(); // ¢✓¢ returned type is ¢\cc{t1}¢
f.r2().s2().g(); // ¢✗¢ compile time error, function ¢\cc{g()}¢ is undefined for type ¢$T⁺$¢.
\end{JAVA}

\begin{figure}[h]
    \caption{Encoding a stack data structure with
    \Java type system including full code (left) and type hierarchy (right)}\label{Figure:stack:encoding}
    \begin{tabular}{cc}
         \parbox[c]{0.74\linewidth}{
      \tcbinputlisting{%
        codebox=Java,
        listing options={style=numbered,style=Java},
       % minipage,
        %width=\hsize,
        listing inputencoding=utf8,
        listing file=stack.listing}
      }
        &
         \parbox[c]{\hsize}{
          \input ../Figures/stack-classification.tikz
        }
    \end{tabular}
\end{figure}
      Note, that the implemented inheritance model previously used, is now extended to express the partiality
        of functions such as~$f$. A visualization of the inheritance model is presented in \cref{Figure:partial:inheritance:model}

\begin{figure}[ht]
  \label{Figure:partial:inheritence:model}
  \caption{Inheritance Model for partial binary function~$f$}
  \begin{adjustbox}{max width=0.6\linewidth}
    \input ../Figures/partial-function-classification.tikz
  \end{adjustbox}
\end{figure}

We use the notion \emph{Type-Method} when we want to express that the arguments passed to a function
  (i.e., former~$f$) are ‟passed” by invoking a method on the receiver (i.e., r1(),s1() in the former example).

Here is the general process for general sets~$R$,$S$,$T$ and function~$f$:
First, generate an abstract class \cc{R} that represents set~$R$, and,
  for each~$r∈R$ a concrete class \cc{r} that extends \cc{R}.
Similarly, generate an abstract class \cc{T} that represents set~$T$, and,
  for each~$t∈T$ a concrete class \cc{t} that extends \cc{T}.

Now, for each~$(r,s)∈f$, introduce an abstract method named \cc{s},
  in class~\cc{r}

(the name obtained by
  concatenating the name of~$f$ with the name of~$s$).

It is rather straightforward to encode
