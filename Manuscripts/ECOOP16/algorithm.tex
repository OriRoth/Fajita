An LR($1$) parser (henceforth, LR parser) for a grammar~$G=(Ξ,ξ,R)$ (Nonterminals set, initial start element,production rules set respectively)
  has three components:
\begin{description}
  \item[An automaton] whose states are~$Q=❴q₀,…,qₙ❵$
  \item[A stack] which may contain any member of~$Q$.
  \item[Specification of state transition] with the aid of two tables:
  \begin{description}
    \item[Goto table] which defines a partial function~$δ:Q⨉Ξ↛Q$ of transitions
    between the states of the automaton.
    \item[Action table] which
    defines a partial function\[η:Q⨉Σ↛ ❴ \textsf{Shift}(q) \,|\, q∈Q❵ ∪ ❴\textsf{Reduce}(r) \,| \, r∈G❵.\]
  \end{description}
\end{description}
An \emph{LR item} is a rule~$r∈R$ and a dot index in the right-hand side of the rule,
  i.e.,~$A→α·β$ is an LR item if~$A∈Ξ$,~$A→αβ∈R$,
  the dot index in this example is~$|α|$.
Every state~$q∈Q$ is a set of~\emph{LR items},
  where every such item is in the~$Kernel_{q}$ set,
  or in the~$NonKernel_{q}$ set.
Every state~$q$ is the unification of~$Kernel_{q}$ and~$NonKernel_{q}$.
The parser begins by pushing~$q₀$ (the initial state) into the empty stack,
and then repetitively executes the following:
Examine~$q∈Q$, the state at the top of the stack.
If~$q=qₙ$ (the accepting state) and the input string is wholly consumed, then the parser stops and the input is accepted.

Let~$σ∈Σ$ be the next input symbol.
If~$δ(q,σ)=⊥$ (undefined), the parser stops in rejecting the input.

If~$δ(q,σ) = \textsf{Shift}(q')$, the parser pushes state~$q'$
into the stack and consumes~$σ$.
If however,~$δ(q,σ) = \textsf{Reduce}(r)$,~$r=ξ→β$,
then the parser does not consume~$σ$.
Instead it makes~$|β|$ pop operations.
Let~$q'$ be the state at the top of the stack after these pops, then
the parser pushes a state,~$q”$,
defined by applying the transition function to~$ξ$, the left-hand side of the reduced production and~$q'$,
i.e.,~$q”=η(q',ξ)$.

The specifics of parser generation and specifically
  calculating the sets~$Kernel_{q}$ and~$NonKernel_{q}$, lies beyond our interest here.
We do mention however that the same LR parser can serve parsing table drawn using weaker LR parser generators,
including SLR and LALR\@.

LR parsers are actually DPDAs\@. As we mentioned before in \cref{Section:proof},~$ε$-moves
  fails the emulation of a DPDA, thus, in order to type-encode an LR parser, we first need
  to convert it to the encode-able jDPDA\@.

A \emph{JLR parser}, or \emph{Jump LR Parser} is an LR parser, that
  is based on a variation of the jDPDA\@.
The objective of the JLR parser is refined in~\cref{Theorem:JLR}.

\begin{Theorem}
  \label{Theorem:JLR}
  Let~$P$ be an LR parser, then there exists a jDPDA~$J$,
  such that for every string~$α∈Σ^*$, parser~$P$ accepts~$α$
    if and only if~$J$ accepts~$α$
\end{Theorem}

For an LR parser~$⟨Q,δ_{LR}, η_{LR}⟩$ defined over a grammar~$⟨Ξ,ξ,R⟩$
A JLR is like the jDPDA~$A=⟨Γ,q₀,δ⟩$ defined in~\cref{Definition:JDPDA},
  where~$Γ= Q∪(Σ_💲↛Q)$ are the stack elements,~$q₀∈Q$
  is the initial state, and~$delta:Γ⨉Σ↛Γ^*∪j(Σ_💲)$ is defined as follows:
  \begin{itemize}
   \item~$δ(q,σ)= j(σ)$ if~$η_{LR}(q,σ)=Reduce(A→α)∧α≠ε$

   % Automization based on the second example (Balanced parenthesis)

   % Green rule , only on kernel items
   \item~$δ(q,σ)= q \: p~$ if~$η_{LR}(q,σ)=Shift(p)$ and we advanced only on~$\textsf{Kernel}_q$ items
   \item~$δ(q,σ)= q \: p~$ if~$η_{LR}(q,σ)=Reduce(A→ε)$
     and~$δ_{LR}(q,A)=Goto(q')$ and~$η_{LR}(q',σ)=Shift(p)$
     and we advanced only on~$\textsf{Kernel}_q$ items

  % Red rule , only on non-kernel items

   \item~$δ(q,σ)= q \: f \: p~$ if~$η_{LR}(q,σ)=Shift(p)$ and we advanced only on~$I⊆\textsf{NonKernel}_q$
     items, then
    \[
      f = ❴σ'↦q' \; | \;∃i∈I. lookahead(i)=σ' \,∧\, η_{LR}(q,σ')=Shift(q')❵
    \]

   \item~$δ(q,σ)= q \: f \: p~$ if~$η_{LR}(q,σ)=Reduce(A→ε)$
     and~$δ_{LR}(q,A)=Goto(q')$ and~$η_{LR}(q',σ)=Shift(p)$
     and we advanced only on~$I⊆\textsf{NonKernel}_q$
     items, then
     \[
      f = ❴σ'↦q' \; | \;∃i∈I. lookahead(i)=σ' \,∧\, η_{LR}(q,σ')=Shift(q')❵
     \]

  \end{itemize}
\subsection{Informally}

For an LR parser~$⟨Q,δ_{LR}, η_{LR}⟩$ defined over a grammar~$⟨Ξ,ξ,R⟩$
A JLR is like the jDPDA~$A=⟨Γ,q₀,δ⟩$ defined in~\cref{Definition:JDPDA},

\begin{itemize}
  \item When we \textsf{reduce()} a jump operation is performed.
    The jump will be for the corresponding look-ahead symbol.
  \item On a shift op:
  if we shift on a~$item∈\textsf{Kernel}$
    then everything as usual.
  Else,~$item∈\textsf{Closure(Kernel)}$
      if the look-ahead of this item will be consumed by a kernel item:
        a new Jump symbol will be inserted on the stack.
      Else:
        the look-ahead will cause a reduction of one of the kernel items,
        in that case, the previous Jump symbol is still relevant.
  \item[Even computation Invariant]
    Let~$L$ be an LR parser,~$J$ is the corresponding JLR, and word~$w =σ₁…σₖ 💲∈Σ^*＄~$ (we denote~$wᵢ$ to be~$σᵢ⋯σₖ ＄$).
    if when~$L$ parses~$w$, it reaches a configuration~$(wᵢ,γζ)$,
    then when~$J$ parses~$w$, it reaches the configuration~$(wᵢ,γζ')$ where~$ζ= \textsf{clean}(ζ')$
    and \textsf{clean} is a function that removes all~$c∉Q$ from the input string.
  \item[Jump invariant]
    when jumping on a lookahead symbol~$a∈Σ_💲~$ during the computation of~$J$,
    all consecutive reductions performed on~$L$ from the parallel configuration, are ‟done” by the \textsf{jump} operation.
  \item[Parsing] can always be added to this model, because when we get to an item~$A→α·B,a$, and we shift on
    one of the items~$B→·β,a$, we know that every legal parsing will result in (thats actually not accurate, what happens
    if we shift on another item~$A→·γ,a/b$?)
\end{itemize}
\paragraph{Problem 1} if we shift on more than one items, with different lookaheads,
  and put multiple terminals on the stack, who should we put first? the ones that are
  not first are the problem; if we jump to them, we still got other terminals on the
  top of the stack, out invariant says we always want the top of the stack to be a
  state element.

\paragraph{Solution 1} if save on the stack a single element for the
  ‟multiple shifting items” which will be of type:~$𝓟(Σ)$
  and we transform the jump operation on~$σ∈Σ$to be ‟Remove elements
  from the stack until a~$χ∈𝓟(Σ)$,~$σ∈χ$ is popped”.

\paragraph{Problem 2} When we~$\textsf{Jump}(σ)$ , we consume~$σ$, and remove
  from stack as expected, the problem is, the corresponding lookaheads symbol
  should be ‟consumed” and the shift on~$σ$ need to happen again.

\paragraph{Solution 2} Instead of pushing subsets of~$Σ$ we push partial
  mappings~$Σ_{💲}↛Q$ (where~$Γ=Q∪(Σ_{＄}↛Q)$) jumping is still defined
  on symbols~$σ∈Σ_{💲}$, and when the jump is performed we pop from the stack
  until we popped some~$f∈(Σ↛Q)$ for which~$f(σ)≠⊥$, and then push~$f(σ)$ back onto the stack.

\paragraph{Problem 3} When we have a state \textsf{Base} that has
  two items~$A₁→α₁·β₁,a$ and~$A₂→α₂·β₂,a$ we can't decide which function to put,
  the mapping of~$a$ might be for the consecutive
  transitions~$\textsf{Base}.goto(A₁).shift(a)$ or to~$\textsf{Base}.goto(A₂).shift(a)$.

\paragraph{Failed Solution 3} We cannot solve the problem by changing the function elements from~$Σ_💲↛Q$
  to~$Σ_💲⨉Ξ↛Q$. The reason resides on the identity of the input nonterminal.
  When we build the JLR's transition function, and want to add a function element to the stack, we choose for some~$σ∈Σ$
  a transition to be performed after a goto, to a certain state~$q∈Q$, problem is, there might be more than one such transition
  for that~$σ$, i.e., when for some~$q,q',q”∈Q$, and~$A,B∈Ξ$ ,~$q.goto(A).shift(a)=q'$,~$q.goto(B).shift(a)=q”$.

\paragraph{Problem 4} We add a function element on the stack for lookahead~$a∈Σ$
  when we have an item that will consume~$a$ after some reduction,
  i.e., an item of type~$A→·Baα,c$ for some~$A,B∈Ξ$ and~$c∈σ$,
  and we don't add an item when we have a rule that will reduce
  upon seeing such lookahead~$a$, i.e.,~$A→α·B , a$
  ( not quite sure that these examples are as general as possible. I should verify it).
  What happens if both appear in the same state?

\paragraph{Solution 4} I believe that in \emph{every} such situation,
  we would see a Shift/Reduce conflict, at some state reachable from the discussed state.

\paragraph*{JLR construction}
The JLR is a shift-jump machine.

\subparagraph*{Item definition}
A JLR item is the tuple~$⟨i,addr⟩∈ℝ~$
  where~$i$ is a classic LR(1) item
  and~$addr$ is the stack address of the \emph{last reduction} of the item, i.e.,
  when we reduce on this (instance of the) rule,
  the penultimate pop on the consecutive reduction
  list will reveal~$addr$, and the popping of the last
  will conclude the reductions.
We denote this triplet as~$[A→α·β, b , Addr(addr)]$
  where~$A→α·β, b$ is the LR(1) notation.

\subparagraph*{State definition}
A state, is a set of JLR items, the set is defined as the
  union of two, less frequently used subsets:
  kernel items and non-kernel items, denoted
  as \textsf{K} and \textsf{NK}.

\subparagraph*{States generation algorithm}
The method is basically the same as LR automaton construction,
  with the modified items.

  \begin{algorithm}[p]
  \caption{\label{Algorithm:Closure}
  function~$Closure(K)$ -- Generates the closure of an initial \textsf{Kernel} items set~$K$}
  \begin{algorithmic}
    \REQUIRE~$K$ is a set of kernel items
    \ENSURE~$Clo = K ∪ NK$
    \STATE~$Clo := K$,~$Stack :=∅$
    \STATE push all items in~$K$ to~$Stack$
    \WHILE{$Stack$ is not empty}
      \STATE~$ [ A→α·Bβ \, , \, a \, , \, Addr(i) ]←pop(Stack)$
      \IF{$NULLABLE(β)$}
        \STATE~$Clo := Clo ∪ ❴ [ B→·γ, a , Addr(i) ] ❵$
        \STATE~$Stack.push(❴ [ B→·γ, a , Addr(i) ] ❵)$
      \ENDIF
      \STATE~$newAddr←fresh()$
      \FOR{each production~$B→γ ∈ G'$}
        \FOR{each terminal~$t ∈ FIRST(β)$}
          \STATE~$Clo := Clo ∪ ❴ [ B→·γ, t , Addr(newAddr) ] ❵$
          \STATE~$Stack.push(❴ [ B→·γ, t , Addr(newAddr) ] ❵)$
        \ENDFOR
      \ENDFOR
    \ENDWHILE
    \RETURN~$Clo$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[p]
  \caption{\label{Algorithm:Goto}
  function~$GOTO(I,X)$ -- Generates an item set for an adjacent state}
  \begin{algorithmic}
    \REQUIRE~$I$ is a set of JLR items and~$X$ is a grammar symbol
    \ENSURE~$J$ is the set of items of some adjacent state.
    \STATE~$J \, := \,∅$
    \FOR{each item~$ [ A→α·Xβ\, , \, a \, , \, Addr(i) ] ∈ I$}
      \STATE~$ J := J∪❴ [ A→αX·β\, , \, a \, , \, Addr(i) ] ❵$
    \ENDFOR
    \RETURN~$Closure(J)$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[p]
  \caption{\label{Algorithm:States}
  function~$ITEMS(G')$ -- Generates the states set of the augmented grammar~$G'$}
  \begin{algorithmic}
    \REQUIRE~$G'$ is an augmented grammar
    \ENSURE~$Set$ is the set of JLR states
    \STATE~$Set \, := \, ❴[S'→·S , 💲 , Addr(0)]❵$
    \REPEAT
      \FOR{each set of items~$I ∈ Set$}
  \FOR{each grammar symbol~$ X ∈Σ_💲 ∪Ξ'$}
    \IF{$GOTO(I,X)$ is not empty and not in~$Set$}
      \STATE~$ Set := Set ∪ GOTO(I,X)$
    \ENDIF
  \ENDFOR
      \ENDFOR
    \UNTIL{no more states are added \textsf{Set}}
  \end{algorithmic}
\end{algorithm}

\subparagraph*{JLR parsing tables}
From the previous set of states, we can now
  complete our shift-jump machine by constructing
  the corresponding parsing table.
The parsing table resembles to the LR(1)
  parsing tables, and is defined with
  the following mapping:
\[
  Q \times \Sigma_\$ \times \mathbb{N} \nrightarrow { s( F , Q ) , s ( Q ) , j ( \mathbb{N} ) }
\]
 where in the rows we put the different states in~$Q$,
 and in the columns we put the lookahead and jump information~$ \Sigma_\$ \times \mathbb{N}$.
The resulted action is one of:
\begin{itemize}
  \item[$s(p)$] - A simple shift action, pushing the input state onto the top of the stack
    (In fact, the old top of the stack can be removed, as it will not be used anymore)
  \item[$s(f,p)$] - A double shift operation, where~$f$ is pushed first, and~$p$ is then
    pushed as the new top of the stack (Again, last element doesn't have to be saved)
  \item[$j(n)$] - A jump operation
\end{itemize}
\paragraph{Misc.}

\begin{Definition}[Simple-Jump Single-State Realtime Deterministic Pushdown Automaton]
  \label{Definition:JDPDA}
  \slshape
  A \textit{simple-jump, single-state, realtime deterministic pushdown automaton}
  (jDPDA, for short) is a triplet~$⟨Γ,γ₁,δ⟩$
  where~$Γ$ is a set of stack elements,~$γ₁∈Γ$ is the initial stack element,
  and~$δ$ is the \emph{partial transition function},~$δ:Γ⨉Σ↛Γ^*∪j(Γ)$,
  \[
    j(Γ) = ❴ \textit{instruction \textup{\textsf{jump}}}(γ) \; | \;γ∈Γ❵.
  \]
  A configuration of a jDPDA is some~$c∈Γ^*$ representing the stack contents.
  Initially, the stack holds~$γ₁$ only.
  For technical reasons, assume that the input terminates with~$💲∉Σ$, a special end-of-file character.
  \begin{itemize}
    \item At each step a jDPDA examines~$γ$,
    the element at the top of the stack,
    and~$σ∈Σ$, the next input character,
    and executes the following:
          \begin{quote}
            \begin{enumerate}
              \item consume~$σ$
              \item if~$δ(γ,σ)=ζ$,~$ζ∈Γ^*$, the automaton pops~$γ$, and pushes~$ζ$ into the stack.
              \item if~$δ(γ,σ)=\textsf{jump}(γ')$,~$γ'∈Γ$, then the automaton repetitively
                    pops stack elements up-to and including the first occurrence of~$γ'$.
            \end{enumerate}
          \end{quote}
    \item If the next character is~$💲$, the automaton may reject or accept (but nothing else),
          depending on the value of~$γ$.
  \end{itemize}
  In addition, the automaton rejects if~$δ(γ,σ) =⊥$ (i.e., undefined), or if it encounters
  an empty stack (either at the beginning of a step or on course of a \textsf{jump operation}).
\end{Definition}

\[
S → B
\]
\[
B → A \; b \;\; | \;\; A \; c
\]
\[
A → a \; A \;\; | \;\; a
\]

\begin{equation}
  \begin{array}{*1c}
  δ(q₀,lp) = q₀ \, q₃ \, b \, q₄ \, c \, q₅⏎
  δ(q₅,a) = q₅ \, q₅⏎
  δ(q₅,b) = jump(b)⏎
  δ(q₅,c) = jump(c)⏎
  δ(q₃,💲) = jump(q₀)⏎
  δ(q₄,💲) = jump(q₀)⏎

  δ(q₇,rp) = jump(rp)⏎
  \end{array}
\end{equation}
