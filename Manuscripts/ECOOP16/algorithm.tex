An LR($1$) parser (henceforth, LR parser) for a grammar~$G=(Ξ,ξ,R)$ (Nonterminals set, initial start element,production rules set respectively)
  has three components:
\begin{description}
  \item[An automaton] whose states are~$Q=❴q₀,…,qₙ❵$
  \item[A stack] which may contain any member of~$Q$.
  \item[Specification of state transition] with the aid of two tables:
  \begin{description}
    \item[Goto table] which defines a partial function~$δ:Q⨉Ξ↛Q$ of transitions
    between the states of the automaton.
    \item[Action table] which
    defines a partial function\[η:Q⨉Σ↛ ❴ \textsf{Shift}(q) \,|\, q∈Q❵ ∪ ❴\textsf{Reduce}(r) \,| \, r∈G❵.\]
  \end{description}
\end{description}
An \emph{LR item} is a rule~$r∈R$ and a dot index in the right-hand side of the rule,
  i.e.,~$A→α·β$ is a LR item if~$A∈Ξ$,~$A→αβ∈R$,
  the dot index in this example is~$|α|$.
Every state~$q∈Q$ is a set of~\emph{LR items},
  where every such item is in the~$Kernel_{q}$ set,
  or in the~$NonKernel_{q}$ set.
Every state~$q$ is the unification of~$Kernel_{q}$ and~$NonKernel_{q}$.
The parser begins by pushing~$q₀$ (the initial state) into the empty stack,
and then repetitively executes the following:
Examine~$q∈Q$, the state at the top of the stack.
If~$q=qₙ$ (the accepting state) and the input string is wholly consumed, then the parser stops and the input is accepted.

Let~$σ∈Σ$ be the next input symbol.
If~$δ(q,σ)=⊥$ (undefined), the parser stops in rejecting the input.

If~$δ(q,σ) = \textsf{Shift}(q')$, the parser pushes state~$q'$
into the stack and consumes~$σ$.
If however,~$δ(q,σ) = \textsf{Reduce}(r)$,~$r=ξ→β$,
then the parser does not consume~$σ$.
Instead it makes~$|β|$ pop operations.
Let~$q'$ be the state at the top of the stack after these pops, then
the parser pushes a state,~$q”$,
defined by applying the transition function to~$ξ$, the left-hand side of the reduced production and~$q'$,
i.e.,~$q”=η(q',ξ)$.

The specifics of parser generation and specifically
  calculating the sets~$Kernel_{q}$ and $NonKernel_{q}$, lies beyond our interest here.
We do mention however that the same LR parser can serve parsing table drawn using weaker LR parser generators,
including SLR and LALR\@.

LR parsers are actually DPDAs\@. As we mentioned before in \cref{Section:proof},~$ε$-moves
  fails the emulation of a DPDA, thus, in order to type-encode a LR parser, we first need
  to convert it to the encode-able jump-DPDA\@.

A \emph{JLR parser}, or \emph{Jump LR Parser} is a LR parser, that
  is based on a jump-DPDA except for a DPDA\@.
The objective of the JLR parser is refined in~\cref{Theorem:JLR}.

\begin{Theorem}
  \label{Theorem:JLR}
  Let P be a LR parser, then there exists a jump-DPDA J,
  such that for every string~$α∈Σ^*$
  P accepts~$α$ if and only if J accepts~$α$
\end{Theorem}

For a LR parser~$⟨Q,δ_{LR}, η_{LR}⟩$ defined over a grammar~$⟨Ξ,ξ,R⟩$
A JLR is like the jump-DPDA~$A=⟨Γ,q₀,δ⟩$ defined in~\cref{Definition:JDPDA},
  where~$Γ= Q∪Σ~$ are the stack elements,~$q₀∈Q$ is the initial state, and~$delta:Γ⨉Σ↛Γ^*∪j(Σ)$ is defined as follows:
  \begin{itemize}
   \item~$δ(qᵢ,σ)= j(σ)$ if~$η_{LR}(qᵢ,σ)=Reduce(r)$
   \item~$δ(qᵢ,σ)= \text{some }Γ^*\text{ if }η_{LR}(qᵢ,σ)=Shift(qⱼ)$
  \end{itemize}


\subsection{Informally}

JLR parser performs as a LR parser except for:

\begin{itemize}
  \item When we \textsf{reduce()} a jump operation is performed.
    The jump will be for the corresponding look-ahead symbol.

  \item On a shift op:
  if we shift on a~$item∈\textsf{Kernel}$
    then everything as usual.
  Else,~$item∈\textsf{Closure(Kernel)}$
      if the look-ahead of this item will be consumed by a kernel item:
        a new Jump symbol will be inserted on the stack.
      Else:
        the look-ahead will cause a reduction of one of the kernel items,
        in that case, the previous Jump symbol is still relevant.
  \item[Jump Invariant] For each ID~$(q,w,γζ)$, if the corresponding look-ahead~$ℓ$ will 
    supply~\[
      \textsf{Jump}(ℓ)= \text{the state after all consecutive reductions}.
    \]
  \item[Parsing] can always be added to this model, because when we get to a item~$A\rightarrow\alpha\cdot\B,a$, and we shift on
    one of the items~$B\rightarrow\cdot\beta,a$, we know that every legal parsing will result in (thats actually not accurate, what happens
    if we shift on another item~$A\rightarrow\cdot\gamma,a/b$?)
\end{itemize}
\paragraph{Problem 1} if we shift on more than one items, with different lookaheads, and put multiple terminals on the stack,
  who should we put first? the ones that are not first are the problem; if we jump to them, we still got other terminals on the top of the stack,
  out invariant says we always want the top of the stack to be a state element.
  
\paragraph{Solution 1} if save on the stack a single element for the ``multiple shifting items'' which will be of type:~$\mathcal{P}(\Sigma)$
  and we transform the jump operation on~$\sigma\in\Sigma$to be ``Remove elements from the stack until a~$\chi\in\mathcal{P}(\Sigma)$,~$\sigma\in\chi$
  is popped''.
  
\paragraph{Problem 2} When we~$\mathsf{Jump}(\sigma)$ , we consume~$\sigma$, and remove from stack as expected,
the problem is, the corresponding lookaheads symbol should be ``consumed'' and the shift on $\sigma$ need to happen again.
  
\paragraph{Solution 2} Instead of pushing subsets of~$\Sigma$ we push partial mappings~$Σ↛Q^*$ (where~$\Gamma=Q\cup(Σ↛Q^*)$)
  jumping is still defined on symbols~$\sigma\in\Sigma$, and when the jump is performed we pop from the stack until we popped
  some~$f\in(Σ↛Q^*)$ for which~$f(\sigma)\neq\bot$, and then push~$f(\sigma)$ back onto the stack.