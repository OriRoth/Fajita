\section{JLR parsing}
The JLR parser, is a shift-jump machine,
  based on the previously discussed jDPDA.
It was fabricated with great inspiration from the classical 
  LR(1) parser, with changes regarding the automaton's
  \textit{realtime} nature.

The cornerstone of LR parsing are the LR items,
  which construct the LR automaton's states, and
  characterize the shift and reduce operations.
The following definition, of JLR items, tries to
  enclose the required changes to those items to handle
  jump operations.
A JLR item, is a tuple~$⟨i,addr⟩$ where~$i$ is an
  LR item, and~$addr$ is a special stack element,
  to which the parser will jump, in case this item will
  be reduced.
This jump is designed to emulate the LR's 
  reduce operation, considering the unbounded list of consecutive 
  reductions that might occur. 
We denote such items as~$[A→α·β, b , addr]$
  where~$A→α·β, b$ is the original LR notation, and~$addr$
  is the jump address†{
  Addresses will be denoted by integers for conciseness and brevity}.

A set of JLR items is said to be a JLR state.

\subsection{States generation algorithm}
The method for constructing a shift-jump automaton
  is basically the same as the LR automaton construction,
  with small modification to update the addresses of JLR items.
Like the original algorithms, we divide the work to three
  sub-routines~$Closure(I)$,~$Goto(I,X)$ and~$Items(G')$,
  where the first slightly differs from the original function by handling the addresses 
  of freshly added items, and the other two remain as in the original LR state construction.
For the convenience of the reader, the algorithms are depicted
  in~\cref{Algorithm:Closure},~\cref{Algorithm:Goto} and~\cref{Algorithm:Items} accordingly.
\begin{algorithm}[p]
  \caption{\label{Algorithm:Closure}
  function~$Closure(I)$ -- Generates the closure of an initial items set~$I$}
  \begin{algorithmic}
    \REQUIRE~$I$ is a set of JLR items
    \ENSURE~$J$ is the closure of~$I$
    \STATE~$J := I$,~$Stack :=∅$
    \STATE push all items in~$I$ to~$Stack$
    \WHILE{$Stack$ is not empty}
      \STATE~$ [ A→α·Bβ \, , \, a \, , \, Addr ]←pop(Stack)$
      \IF{$NULLABLE(β)$}
        \STATE~$J := J ∪ ❴ [ B→·γ, a , Addr ] ❵$
        \STATE~$Stack.push(❴ [ B→·γ, a , Addr ] ❵)$
      \ENDIF
      \STATE~$newAddr←fresh()$
      \FOR{each production~$B→γ ∈ G'$}
        \FOR{each terminal~$t ∈ FIRST(β)$}
          \STATE~$J := J ∪ ❴ [ B→·γ, t , newAddr ] ❵$
          \STATE~$Stack.push(❴ [ B→·γ, t , newAddr ] ❵)$
        \ENDFOR
      \ENDFOR
    \ENDWHILE
    \RETURN~$J$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[p]
  \caption{\label{Algorithm:Goto}
  function~$Goto(I,X)$ -- Generates an item set for an adjacent state}
  \begin{algorithmic}
    \REQUIRE~$I$ is a set of JLR items and~$X$ is a grammar symbol
    \ENSURE~$J$ is the set of items of some adjacent state.
    \STATE~$J \, := \,∅$
    \FOR{each item~$ [ A→α·Xβ\, , \, a \, , \, Addr ] ∈ I$}
      \STATE~$ J := J∪❴ [ A→αX·β\, , \, a \, , \, Addr ] ❵$
    \ENDFOR
    \RETURN~$Closure(J)$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[p]
  \caption{\label{Algorithm:Items}
  function~$Items(G')$ -- Generates the states set of the augmented grammar~$G'$}
  \begin{algorithmic}
    \REQUIRE~$G'$ is an augmented grammar
    \ENSURE~$Set$ is the set of JLR states
    \STATE~$Set \, := \, ❴[S'→·S , \$ , Addr0]❵$
    \REPEAT
      \FOR{each set of items~$I ∈ Set$}
  \FOR{each grammar symbol~$ X ∈Σ_\$ ∪Ξ'$}
    \IF{$GOTO(I,X)$ is not empty and not in~$Set$}
      \STATE~$ Set := Set ∪ GOTO(I,X)$
    \ENDIF
  \ENDFOR
      \ENDFOR
    \UNTIL{no more states are added \textsf{Set}}
  \end{algorithmic}
\end{algorithm}

\subsection{Structure of the JLR parsing table and behavior of actions}
The structure of the JLR parsing table
  resembles the LR(1) action table;
  it's defined by a function~$\textsf{ACTION}[q,a]$
  where~$q∈Q$, and~$a∈Σ_\$$, being next state and 
  the lookahead symbol accordingly.
The result of~$\textsf{ACTION}[q,a]$ can have one of
  three forms:
\begin{itemize}

  \item[$s(p)$] - A simple shift action.
    The parser pushes~$p$ onto the top of the stack (In fact,
    unlike the LR parser, the old top of the stack can be removed,
    as it will not be used anymore).

  \item[$s(f,p)$] - A double shift operation.
    The parser pushes~$f∈ℕ↛Q$ first, and~$p$ is
    then pushed as the new top of the stack
    (Again, last element doesn't have to be saved).

  \item[$j(n)$] - A jump operation to the address numbered as~$n$.
    The parser pops elements from the stack until some
    function~$f$ is popped, such that~$f(n)$ is defined,
    and yields some~$q$.~$q$ is then pushed onto the stack.

\end{itemize}




\end{document}



\paragraph{Misc.}

\subsection{The LR($1$) parser}
An LR($1$) parser (henceforth, LR parser) for a grammar~$G=(Ξ,ξ,R)$ (Nonterminals set, initial start element,production rules set respectively)
  has three components:
\begin{description}
  \item[An automaton] whose states are~$Q=❴q₀,…,qₙ❵$
  \item[A stack] which may contain any member of~$Q$.
  \item[Specification of state transition] with the aid of two tables:
  \begin{description}
    \item[Goto table] which defines a partial function~$δ:Q⨉Ξ↛Q$ of transitions
    between the states of the automaton.
    \item[Action table] which
    defines a partial function\[η:Q⨉Σ↛ ❴ \textsf{Shift}(q) \,|\, q∈Q❵ ∪ ❴\textsf{Reduce}(r) \,| \, r∈G❵.\]
  \end{description}
\end{description}
An \emph{LR item} is a rule~$r∈R$ and a dot index in the right-hand side of the rule,
  i.e.,~$A→α·β$ is an LR item if~$A∈Ξ$,~$A→αβ∈R$,
  the dot index in this example is~$|α|$.
Every state~$q∈Q$ is a set of~\emph{LR items},
  where every such item is in the~$Kernel_{q}$ set,
  or in the~$NonKernel_{q}$ set.
Every state~$q$ is the unification of~$Kernel_{q}$ and~$NonKernel_{q}$.
The parser begins by pushing~$q₀$ (the initial state) into the empty stack,
and then repetitively executes the following:
Examine~$q∈Q$, the state at the top of the stack.
If~$q=qₙ$ (the accepting state) and the input string is wholly consumed, then the parser stops and the input is accepted.

Let~$σ∈Σ$ be the next input symbol.
If~$δ(q,σ)=⊥$ (undefined), the parser stops in rejecting the input.

If~$δ(q,σ) = \textsf{Shift}(q')$, the parser pushes state~$q'$
into the stack and consumes~$σ$.
If however,~$δ(q,σ) = \textsf{Reduce}(r)$,~$r=ξ→β$,
then the parser does not consume~$σ$.
Instead it makes~$|β|$ pop operations.
Let~$q'$ be the state at the top of the stack after these pops, then
the parser pushes a state,~$q”$,
defined by applying the transition function to~$ξ$, the left-hand side of the reduced production and~$q'$,
i.e.,~$q”=η(q',ξ)$.

The specifics of parser generation and specifically
  calculating the sets~$Kernel_{q}$ and~$NonKernel_{q}$, lies beyond our interest here.
We do mention however that the same LR parser can serve parsing table drawn using weaker LR parser generators,
including SLR and LALR\@.

\subsection{Between LR and JLR - A direct approach}
LR parsers are actually DPDAs\@. As we mentioned before in \cref{Section:proof},~$ε$-moves
  fails the emulation of a DPDA, thus, in order to type-encode an LR parser, we first need
  to convert it to the encode-able jDPDA\@.

A \emph{JLR parser}, or \emph{Jump LR Parser} is an LR parser, that
  is based on a variation of the jDPDA\@.
The objective of the JLR parser is refined in~\cref{Theorem:JLR}.

\begin{Theorem}
  \label{Theorem:JLR}
  Let~$P$ be an LR parser, then there exists a jDPDA~$J$,
  such that for every string~$α∈Σ^*$, parser~$P$ accepts~$α$
    if and only if~$J$ accepts~$α$
\end{Theorem}

For an LR parser~$⟨Q,δ_{LR}, η_{LR}⟩$ defined over a grammar~$⟨Ξ,ξ,R⟩$
A JLR is like the jDPDA~$A=⟨Γ,q₀,δ⟩$ defined in~\cref{Definition:JDPDA},
  where~$Γ= Q∪(Σ_\$↛Q)$ are the stack elements,~$q₀∈Q$
  is the initial state, and~$delta:Γ⨉Σ↛Γ^*∪j(Σ_\$)$ is defined as follows:
  \begin{itemize}
   \item~$δ(q,σ)= j(σ)$ if~$η_{LR}(q,σ)=Reduce(A→α)∧α≠ε$

   % Automization based on the second example (Balanced parenthesis)

   % Green rule , only on kernel items
   \item~$δ(q,σ)= q \: p~$ if~$η_{LR}(q,σ)=Shift(p)$ and we advanced only on~$\textsf{Kernel}_q$ items
   \item~$δ(q,σ)= q \: p~$ if~$η_{LR}(q,σ)=Reduce(A→ε)$
     and~$δ_{LR}(q,A)=Goto(q')$ and~$η_{LR}(q',σ)=Shift(p)$
     and we advanced only on~$\textsf{Kernel}_q$ items

  % Red rule , only on non-kernel items

   \item~$δ(q,σ)= q \: f \: p~$ if~$η_{LR}(q,σ)=Shift(p)$ and we advanced only on~$I⊆\textsf{NonKernel}_q$
     items, then
    \[
      f = ❴σ'↦q' \; | \;∃i∈I. lookahead(i)=σ' \,∧\, η_{LR}(q,σ')=Shift(q')❵
    \]

   \item~$δ(q,σ)= q \: f \: p~$ if~$η_{LR}(q,σ)=Reduce(A→ε)$
     and~$δ_{LR}(q,A)=Goto(q')$ and~$η_{LR}(q',σ)=Shift(p)$
     and we advanced only on~$I⊆\textsf{NonKernel}_q$
     items, then
     \[
      f = ❴σ'↦q' \; | \;∃i∈I. lookahead(i)=σ' \,∧\, η_{LR}(q,σ')=Shift(q')❵
     \]

  \end{itemize}
\subsection{Informally}

For an LR parser~$⟨Q,δ_{LR}, η_{LR}⟩$ defined over a grammar~$⟨Ξ,ξ,R⟩$
A JLR is like the jDPDA~$A=⟨Γ,q₀,δ⟩$ defined in~\cref{Definition:JDPDA},

\begin{itemize}
  \item When we \textsf{reduce()} a jump operation is performed.
    The jump will be for the corresponding look-ahead symbol.
  \item On a shift op:
  if we shift on a~$item∈\textsf{Kernel}$
    then everything as usual.
  Else,~$item∈\textsf{Closure(Kernel)}$
      if the look-ahead of this item will be consumed by a kernel item:
        a new Jump symbol will be inserted on the stack.
      Else:
        the look-ahead will cause a reduction of one of the kernel items,
        in that case, the previous Jump symbol is still relevant.
  \item[Even computation Invariant]
    Let~$L$ be an LR parser,~$J$ is the corresponding JLR, and word~$w =σ₁…σₖ \$∈Σ^*＄~$ (we denote~$wᵢ$ to be~$σᵢ⋯σₖ ＄$).
    if when~$L$ parses~$w$, it reaches a configuration~$(wᵢ,γζ)$,
    then when~$J$ parses~$w$, it reaches the configuration~$(wᵢ,γζ')$ where~$ζ= \textsf{clean}(ζ')$
    and \textsf{clean} is a function that removes all~$c∉Q$ from the input string.
  \item[Jump invariant]
    when jumping on a lookahead symbol~$a∈Σ_\$~$ during the computation of~$J$,
    all consecutive reductions performed on~$L$ from the parallel configuration, are ‟done” by the \textsf{jump} operation.
  \item[Parsing] can always be added to this model, because when we get to an item~$A→α·B,a$, and we shift on
    one of the items~$B→·β,a$, we know that every legal parsing will result in (thats actually not accurate, what happens
    if we shift on another item~$A→·γ,a/b$?)
\end{itemize}
\paragraph{Problem 1} if we shift on more than one items, with different lookaheads,
  and put multiple terminals on the stack, who should we put first? the ones that are
  not first are the problem; if we jump to them, we still got other terminals on the
  top of the stack, out invariant says we always want the top of the stack to be a
  state element.

\paragraph{Solution 1} if save on the stack a single element for the
  ‟multiple shifting items” which will be of type:~$𝓟(Σ)$
  and we transform the jump operation on~$σ∈Σ$to be ‟Remove elements
  from the stack until a~$χ∈𝓟(Σ)$,~$σ∈χ$ is popped”.

\paragraph{Problem 2} When we~$\textsf{Jump}(σ)$ , we consume~$σ$, and remove
  from stack as expected, the problem is, the corresponding lookaheads symbol
  should be ‟consumed” and the shift on~$σ$ need to happen again.

\paragraph{Solution 2} Instead of pushing subsets of~$Σ$ we push partial
  mappings~$Σ_{\$}↛Q$ (where~$Γ=Q∪(Σ_{＄}↛Q)$) jumping is still defined
  on symbols~$σ∈Σ_{\$}$, and when the jump is performed we pop from the stack
  until we popped some~$f∈(Σ↛Q)$ for which~$f(σ)≠⊥$, and then push~$f(σ)$ back onto the stack.

\paragraph{Problem 3} When we have a state \textsf{Base} that has
  two items~$A₁→α₁·β₁,a$ and~$A₂→α₂·β₂,a$ we can't decide which function to put,
  the mapping of~$a$ might be for the consecutive
  transitions~$\textsf{Base}.goto(A₁).shift(a)$ or to~$\textsf{Base}.goto(A₂).shift(a)$.

\paragraph{Failed Solution 3} We cannot solve the problem by changing the function elements from~$Σ_\$↛Q$
  to~$Σ_\$⨉Ξ↛Q$. The reason resides on the identity of the input nonterminal.
  When we build the JLR's transition function, and want to add a function element to the stack, we choose for some~$σ∈Σ$
  a transition to be performed after a goto, to a certain state~$q∈Q$, problem is, there might be more than one such transition
  for that~$σ$, i.e., when for some~$q,q',q”∈Q$, and~$A,B∈Ξ$ ,~$q.goto(A).shift(a)=q'$,~$q.goto(B).shift(a)=q”$.

\paragraph{Problem 4} We add a function element on the stack for lookahead~$a∈Σ$
  when we have an item that will consume~$a$ after some reduction,
  i.e., an item of type~$A→·Baα,c$ for some~$A,B∈Ξ$ and~$c∈σ$,
  and we don't add an item when we have a rule that will reduce
  upon seeing such lookahead~$a$, i.e.,~$A→α·B , a$
  ( not quite sure that these examples are as general as possible. I should verify it).
  What happens if both appear in the same state?

\paragraph{Solution 4} I believe that in \emph{every} such situation,
  we would see a Shift/Reduce conflict, at some state reachable from the discussed state.

