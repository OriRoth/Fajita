===========================================================================
                          ECOOP 2016 Review #35C
---------------------------------------------------------------------------
     Paper #35: Formal Language Recognition with the Java Type Checker
---------------------------------------------------------------------------

                      Overall merit: A. Good paper, I will champion it
                         Confidence: X. I am an expert in this area
                    Writing Quality: P. Well-written

                         ===== Paper Summary =====

Fluent APIs are those designed to encourage method chaining, which
gives programmers an "illusion" that they use DSLs.  Viewing the set
of method sequences allowed by a type system as a formal language
(where method names are alphabets) naturally gives rise to the
following question: how expressive is the type system of language X in
terms of formal language recognition?  This paper gives an answer to
the question where X is Java: the author(s) show that the Java type
system can express any deterministic context-free language.

                    ===== Points For and Against =====

+ An elegant, theoretically interesting result

+ Useful techniques to express constraints internal DSLs implemented
in Java via fluent APIs.

- The theoretical result by itself may not be much of practical
  interest.

                       ===== Detailed Comments =====

It is a popular technique to use expressive type systems, e.g. those
of Haskell and Scala, to represent syntactic constraints on embedded
DSLs.  Although Java's type system is quite expressive (or
complicated, rather), there's been little work on its potential and
how to exploit the expressiveness in developing embedded DSLs.  The
result of the present work is somewhat surprising because the class of
deterministic context free languages is fairly large.

The presented techniques to encode push-down automata seem practically
useful when someone wants to design their own language.  Types
expressions used are admittedly fairly complicated, programmers (of a
DSL) do not necessarily see them because complicated types are given
to intermediate expressions.  (Resolving typing errors might
be difficult as in C++ template programming, though.)

The paper is well written, fun to read and easy to access (for me).
It develops encoding techniques gradually from basic to advanced ones
and, once one understands them, it is fairly easy to see that the main
theorem holds.  Those who are not very familiar with generics and
especially wildcards, however, may find it difficult to follow the
details, so the author(s) should give a brief overview of the Java
type system in the paper.

As discussed properly by the authors, the theoretical result by itself
doesn't mean this technique practically works for all deterministic
context-free languages.  The way the Java type system typechecks
programs is different from efficient CFL parsing and the time
complexity can be exponential.  It is unfortunate and seems hard to
overcome but, at least, it is a good thing that the authors analyze
the problem.

In summary, the presented work presents contributions that are
interesting both from theoretical and practical point of views.  It
has a practical motivation, presents a nice theoretical result and
practically useful insights.


Minor comments:

The footnote attached to the quote at the beginning of the paper seems
lost.

Abstract:
- idioms o [-> of]
- the may be

Section 1.
- Some more basics of fluent APIs should be provided.

p.3: "a fluent API that realize[s] any ..."

- The word "semantic" is an adjective; use "semantics" (which is an uncountable noun ending with "s").

- Kennedy and Pierce [FOOL/WOOD 2007] have discussed complexity
  (rather, decidability) of nominal type systems with variance.

p.4: "Not surprisingly, ..." doesn't form a sentence.

p.5: "There is [a] large body of research"

p.6: "More general[ly],"

p.6: Theoretically, there is LR(0), too.

p.6: Footnote 11 misses a period.

p.8: "import static these [-> ones]"

p.9: "Body of functions is" -> "Bodies of functions are"

Fig. 6.3: The comma before E on line 13 should be move to the preceding line.

p.20: "sharing of, of expressions"

This Paper Ought to Have an Accompanying Artifact:
                                     1. No, does not need to


