===========================================================================
                          ECOOP 2016 Review #35B
---------------------------------------------------------------------------
     Paper #35: Formal Language Recognition with the Java Type Checker
---------------------------------------------------------------------------

                      Overall merit: B. OK paper, but I will not champion
                                        it
                         Confidence: Y. I am knowledgeable in this area,
                                        but not an expert
                    Writing Quality: P. Well-written

                         ===== Paper Summary =====

The paper presents a study of the expressiveness of the Java type system. Specifically, the paper investigates the extent to which Java supports type-safe fluent APIs. The main result of the paper is a proof that fluent APIs that represent deterministic context-free languages can indeed be encoded in Java. The encoding relies on generics and the fact that deterministic context-free grammars correspond to simple-jump single-state realtime deterministic pushdown automatons, which can be encoded in Java. The paper concludes that a mechanized generation of a fluent API is feasible, but the generated fluent API may impose exponential compilation time at least with javac.

                    ===== Points For and Against =====

+ The generation of fluent APIs is a relevant topic
+ Lower bound on expressiveness of fluent APIs in Java
+ Proof of the encodeability of DPDA-recognized languages as fluent APIs.
+ Innovative encoding using the jump-stack data structure

- No discussion of the tightness of the lower bound.
- No case study for some non-trivial example grammar (generate fluent API systematically but by hand)
- Generator for fluent APIs not implemented
- Practical applicability unclear

                       ===== Detailed Comments =====

This is an interesting paper. An additional perspective on the results of this work is that it connects external domain-specific languages (specified via a grammar) and shallowly embedded domain-specific languages (specified as an API).

The paper addresses two questions: What is the expressiveness of the Java type system? And how to systematically encode languages as fluent APIs in Java? For the former question, the paper provides convincing results, namely it shows that the Java type system can recognize deterministic CFGs. This results by itself is already an achievement and required a sophisticated encoding using jump stacks.

However, I am not convince that an answer to the expressiveness question provides good guidance on how to actually encode languages as fluent APIs. The paper should provide more evidence to this end. For one, it is not clear why the authors did not implement the generator for fluent APIs sketched in Section 8. Why is the conversion from DPDA to jDPDA challenging? Assuming it is, it would still be good to present and discuss a fluent API for a small but non-trivial grammar (like jOOQ) that uses the proposed generation scheme (applied by hand). The question here is whether the theoretical result on language recognition is actually applicable to the implementation of fluent APIs. For example, how would the generated fluent API construct an internal data structure corresponding to the abstract syntax tree?

           ===== Questions for Authors in Response Period =====

How tight is the lower bound of deterministic CFGs? How do advanced features of the Java type system like wildcards and intersection types affect this?

Regular expressions are easy to encode as a fluent API in Java. What is the relation between jDPDA and regular expressions with respect to the configuration space, the transition function, and their encodings?

This Paper Ought to Have an Accompanying Artifact:
                                     1. No, does not need to


