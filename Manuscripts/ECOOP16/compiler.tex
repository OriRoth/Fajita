The \Java compiler is the main computational tool we use
  in this manuscript.
In particular, the \Java generics mechanism is what
  boosted our expressiveness from the trivial \emph{regular languages}
  set, to the practical, reasonable \emph{deterministic context free languages} set.

An interesting question that was raised during this research,
  is what the runtime complexity of the \Java compiler is.
The reason this question is interesting, is its implication
  on the computational expressiveness of type-encoding.

For example, if we recognized that the \Java parser spends
  linear time on its input, we could say that it's not
  likely that we can type-encode nondeterministic CFG.
The reason is the fact that the best known algorithms
  today for parsing general nondeterministic CFG,
  as mentioned in~\Cref{Section:preliminaries}, run in super quadratic time.
And it is highly unlikely that the type-checker of \Java incidentally
  found an algorithm that is practically perfect in big-O notation.

As we explored this venue, we discovered that the type-checker of
  \Java actually runs in exponential time.

Consider an encoding of an S-expession in type~\cc{Cons}
  defined in~\cref{Figure:compiler}.

\begin{wrapfigure}[6]r{27ex}
  \caption{\label{Figure:compiler} Encoding of an binary type tree}
  \javaInput[minipage,width=27ex,left=-2ex]{compiler.listing}
\end{wrapfigure}

Type \cc{Cons} takes two type parameters, \cc{Car} and \cc{Car} (denoting left and right branches).
Denote the return type of \cc{d()} is~$τ= \cc{Cons< Cons<Car, Cdr>, Cons<Car, Cdr> >}$.
Let~$σ$ denote the type of the \kk{this} implicit parameter to~\cc{d}.
Since~$τ= \cc{Const<}σ,σ\cc{>}$, we have~$|τ|≥2|Σ|$,
  where the size of a type is measured, e.g., in number of characters in its textual representation.
In a chain of $n$ calls to \cc{d()} 
\begin{equation}
  \cc{(Cons<?,?>(null)).d().}\cdots{.d();} 
\end{equation}
the size of the resulting type~$O(2ⁿ)$.

\begin{wrapfigure}r{43ex}%
  \caption{\label{Figure:compile-empiric} Compile time (sec) \emph{vs.} sequential method invocation length}%
  \gnuplotloadfile[terminal=pdf,terminaloptions={crop size 2.5in,1.5in color enhanced font ",8" linewidth 1}]{../Figures/kill.gnuplot}
\end{wrapfigure}%

An empirical result of the former example is exhibited in \cref{Figure:compile-empiric}.
The \Java compiler therefore runs at an exponential complexity at worst case,
  not only that, it is not confined to~$O(2ⁿ)$, it is clear that
  writing a similar type-encoding for a ternary type tree would result in
  a lower-bound for the \Java compiler of~$O(3ⁿ)$, and for a k-nary tree
  we would get~$O(kⁿ)$.

Thus, we get that the compile time of a \Java is in the E complexity class :~$O(2^O(n))$.

The theoretical question of type-encoding a stronger machine (i.e., Turing Machine)
  is outside the scope of this paper.
