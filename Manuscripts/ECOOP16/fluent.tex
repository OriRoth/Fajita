The pattern ‟invoke function on variable \cc{sb}”, specifically with
  a function named \cc{append}, occurs six times in the code in \cref{Figure:chaining}(a), designed
  to format a clock reading, given as integers hours, minutes and
  seconds.

\begin{figure}[H]
  \caption{\label{Figure:chaining}%
    Recurring invocations of the pattern ‟invoke function on the same
      receiver”, before, and after method chaining.
  }%
    \begin{tabular}{@{}cc@{}}%
  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
  final StringBuilder sb = new StringBuilder();
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString();
}\end{lcode}
\hfill
&
\hspace{1ex}
  \begin{lcode}[minipage,width=44ex,box align=center]{Java}
String time(int hours, int minutes, int seconds) {¢¢
    return new StringBuilder()
      ¢¢.append(hours).append(':')
      ¢¢.append(minutes).append(':')
      ¢¢.append(seconds)
      ¢¢.toString();
}\end{lcode}
⏎
\textbf{(a)} before & \textbf{(b)} after
\end{tabular}
\end{figure}

Some languages, e.g., \Smalltalk offer syntactic sugar, called \emph{cascading},
  for abbreviating this pattern.
\emph{Method chaining} is a ‟programmer made” syntactic sugar serving the same purpose:
  If a method~$f$ returns its receiver, i.e., \kk{this},
  then, instead of the series of two commands: \mbox{\cc{o.$f$(); o.$g$();}}, clients can write
  only one: \mbox{\cc{o.$f$().$g$();}}.
  \cref{Figure:chaining}(b) is the method chaining
  (also, shorter and arguably clearer) version of
  \cref{Figure:chaining}(a).
It is made possible thanks to the designer of class \cc{StringBuilder} ensuring that 
  all overloaded variants of
  \cc{append} return their receiver.

The distinction between \emph{fluent API} and method chaining is the identity of the receiver:
In method chaining, all methods are invoked on the same object, whereas in fluent API
the receiver of each method in the chain may be arbitrary.
Fluent APIs are more interesting for this reason.
Consider, e.g., the following \Java code fragment (drawn from JMock~\cite{Freeman:Pryce:06})
\[
  \cc{allowing(any(Object.\kk{class})).method("get.*").withNoArguments();}
\]
Let the return type of function \cc{allowing} (respectively \cc{method}) be denoted by~$τ₁$
(respectively~$τ₂$).
Then, the fact that~$τ₁≠τ₂$ means that the set of methods that can be placed after the dot
in the partial call chain~$\cc{allowing(any(Object.\kk{class})).}$
is not necessarily the same set of methods that can be placed after the 
dot in the partial call chain~$\cc{allowing(any(Object.\kk{class})).method("get.*").}$.
This distinction makes it possible to design expressive and rich fluent APIs, in which a
sequence of ‟chained” calls is not only readable, but also robust, in the sense that the
sequence is type correct only when it makes sense semantically.


