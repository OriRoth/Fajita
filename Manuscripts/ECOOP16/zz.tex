The main contribution of this work is the proof that 
  most useful grammars have a fluent API.
This brings good news to library designers laboring
  at making their API slick, accessible, and more
  robust to mistakes of clients: 
If your API can be phrased in terms of a ``decent''
  BNF, do not loose hope; the task may be Herculean, but it is (most likely) possible. 

Other practitioners may appreciate the toolbox of type encodings offered here 
  gaining better understanding of the computational expressiveness of
  \Java generics and type hierarchy, and, a better tool
  for designing, experimenting with and perfecting fluent APIs.

However, once possibility was demonstrated theoretically, the next \emph{research} 
    challenge is in an actual fluent API compiler based on lighter weight
  parsing algorithms.
Precisely, the challenge 
  is in developing a parsing (or at least recognition) 
  algorithm which is not only efficient but also falls within the limited computing power of the \Java types. 

On the theoretical front, one may ask whether 
  this result is the best:
Can the \Java type system be coerced to recognize
  general (that is, nondeterministic) context-free languages?

To the best of our knowledge, 
  the complexity of the \Java type checker has never been analyzed. 
In light of the empirical finding in \cref{Section:applicability},
  research in this direction may be worthwhile. 

Yet another direction is formalizing the proof supplied here. 




