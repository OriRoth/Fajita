The main contribution of this work is the proof that 
  most useful grammars have a fluent API\@.
This brings good news to library designers laboring
  at making their API slick, accessible, and more
  robust to mistakes of clients: 
If your API can be phrased in terms of a ``decent''
  BNF, do not loose hope; the task may be Herculean, but it is (most likely) possible. 

Other practitioners may appreciate the toolbox of type encodings offered here 
  gaining better understanding of the computational expressiveness of
  \Java generics and type hierarchy, and, a better tool
  for designing, experimenting with and perfecting fluent APIs.

However, once possibility was demonstrated theoretically, the next \emph{research} 
    challenge is in an actual fluent API compiler based on lighter weight
  parsing algorithms.
Precisely, the challenge 
  is in developing a parsing (or at least recognition) 
  algorithm which is not only efficient but also falls within the limited computing power of the \Java types. 

On the theoretical front, one may ask whether 
  our result is the best possible:
Can the \Java type system be coerced to recognize
  general (that is, nondeterministic) context-free languages?

As mentioned earlier, to the best of our knowledge, 
  the complexity of the \Java type checker has never been analyzed. 
In light of the empirical finding in \cref{Section:applicability},
  research in this direction may be worthwhile. 

Other directions include 
  formalizing the proof in \cref{Section:proof} here and 
  extensions to other languages.

On a philosophical perspective, several modern programming languages 
  acquire high-level constructs at a staggering rate
  (\CC and Scala being prominent examples). 
The main yardstick for evaluation these 
  is ``programmer's convenience''.
This work suggests an orthogonal perspective, namely 
  computational expressiveness, or, stated differently, 
    ranking of a new construct by its ability to recognize languages 
    in the Chomsky hierarchy~\cite{Chomsky:1963},.
