The thesis propounded by this research is that API design, and especially fluent API design
  can and should be made in terms of language design.
Software missionaries and preachers such as Fowler~\cite{Fowler:xxxx} have long claimed
  that API design is in fact the design of a \textbf Domain \textbf Specific \textbf Language
  (henceforth \emph{DSL}, see, e.g.,~\cite{DSL1,DSL2,DSL3} for review articles).
    (In the words of Fowler~\cite{Fowler:I:think})

The objective of this research is
  to take the unification of the notions of DSL and (fluent) API
  design one step further in automating the creation of fluent API out
  of a DSL specification.
The basic idea is that the programmer issues a fluent API
  specification, and that specification is translated automatically
  to an implementation of fluent API that conforms with this specification.
In the toilette seat example, there are six methods that can be invoked by the client of
  class \cc{Seat}:
  \begin{quote}
\begin{tabular}{lll}
  \cc{male()} & \cc{raise()} & \cc{urinate()}⏎
  \cc{female()} & \cc{lower()} & \cc{defecate()}⏎
\end{tabular}
\end{quote}
a fluent API design specifies the order in which such calls can be made.
The first novelty in this research is that this specification can be made
  using the Bacus-Naur-Form for the specification of context grammar free grammar:
 \def\<#1>{\/⟨\/\textit{#1}\/⟩\/}
\begin{equation}\label{eq:element}
  \begin{aligned}
  \<Usage> ::= & \<Down> \<Up> \hfill⏎
 |\ & \<rule> \hfill⏎
|\ & \<declaration> \hfill
 \end{aligned}
 .
 \end{equation}

processing programming languages
\begin{description}
  \item[Lexical analysis]
  \item[Syntactical analysis]
  \item[Semantical analysis]
\end{description}
Specifically, the proposal is that API design of follows the footsteps of
Accordingly, the designer of a fluent API has to follow this three conceptual
steps.
First is the identification of the \emph{vocabulary}, i.e.,
the set of method calls including type arguments that may take part in the
fluent API.
In this fluent API example
\begin{lcode}{Java}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{lcode}
then, there are three method calls, and the vocabulary has three items in it.
\begin{itemize}
  \item~$ℓ₁ = \cc{any(Class<?>)}$
  \item~$ℓ₂ = \cc{allowing($ℓ₁$)}$
  \item~$ℓ₃ = \cc{method(String)}$
  \item~$ℓ₄ = \cc{withNoArguments()}$
\end{itemize}
