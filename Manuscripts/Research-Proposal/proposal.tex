The thesis propounded by this research is that API design, and especially fluent API design
  can and should be made in terms of language design.
Software missionaries and preachers such as Fowler~\cite{Fowler:2005} have long claimed
  that API design resembles the design of a \textbf Domain \textbf Specific \textbf Language
  (henceforth \emph{DSL}, see, e.g.,~\cite{VanDeursen:Klint:2000,Hudak:1997,Fowler:2010} for review articles).
   In the words of Fowler ``The difference between API design and DSL design is then rather small''~\cite{Fowler:2005})

The objective of this research is
  to take the unification of the notions of DSL and (fluent) API
  design one step further in automating the creation of fluent API out
  of a DSL specification.

The basic idea is that the programmer specifies a fluent API, 
  and, then, this specification is then automatically translated 
  to an implementation of a fluent API that conforms 
  with this specification.
This translation generates the intricate type hierarchy 
  and methods of types in it in such a way 
  that only sequence of calls that conform
  to the specification would 
  compile correctly (concretely, type-check).
 

  To illustrate, consider the toilette seat example. 
In this example, 
  there are a total of six methods that might be invoked. 
\begin{quote}	
  \begin{tabular}{lll}
    \cc{male()}   & \cc{raise()} & \cc{urinate()}⏎
    \cc{female()} & \cc{lower()} & \cc{defecate()}⏎
  \end{tabular}
\end{quote}
A fluent API design specifies the order in which such calls can be made.

The \emph{first} novelty in this research is that the fluent API definition is 
  through a CFG, written as a BNF. 
\cref{Figure:BNF} is such a specification for the toilette seat problem. 
\SELF takes this as input, and in responses generates the corresponding 
  \Java type hierarchy. 

\begin{figure}[htbp]
  \begin{equation*}
    \def\<#1>{\/⟨\/\text{\textit{#1}}\/⟩\/{ }}
    \def\|{~~|~~~}
    \let\oldCc=\cc
    \def\cc#1{{\footnotesize\oldCc{#1}}{\ }}
    \small
    \begin{aligned}
      \<Visitors>         & ::=  \<Down-Visitors>     \hfill⏎
      \<Down-Visitors>    & ::=  \<Down-Visitor>      \<Down-Visitors>  \hfill⏎
      {}                  & \|   \<Raising-Visitor>   \<Up-Visitors>    \hfill⏎
      {}                  & \|   ε                    \hfill⏎
      \<Up-Visitors>      & ::=  \<Up-Visitor>        \<Up-Visitors>    \hfill⏎
      {}                  & \|   \<Lowering-Visitor>  \<Down-Visitors>  \hfill⏎
      {}                  & \|   ε                    \hfill⏎
      \<Up-Visitor>       & ::=  \cc{male()}          \cc{urinate()}    \hfill⏎
      \<Down-Visitor>     & ::=  \cc{female()}        \<Action>         \hfill⏎
                          & \|                  \cc{male()}          \cc{defecate()}  \hfill⏎
      \<Raising-Visitor>  & ::=  \cc{male()}          \cc{raise()}      \cc{urinate()}  \hfill⏎
      \<Lowering-Visitor> & ::=  \cc{female()}        \cc{lower()}      \<Action>       \hfill⏎
                                & \|                  \cc{male()}          \cc{lower()}           \cc{defecate()}  \hfill⏎
      \<Activity>         & ::=  \cc{urinate()}       \hfill⏎
                          & \|                  \cc{defecate()}  \hfill⏎
    \end{aligned}
  \end{equation*}
  \caption{A BNF grammar for the toilette seat problem}
  \label{Figure:BNF}
\end{figure}

A second novelty of \SELF is that the specification of a BNF such as the provided in
  \cref{Figure:BNF} can be made in using a \Java fluent API.
To do so, it is first necessary to  
   define the set of terminals
  \begin{lcode}{Java}
enum ToiletteTerminals implements Terminal {
  male, female, 
  urinate, defecate, 
  lower, raise;
}
\end{lcode}
  and then the set of grammar symbols 
  \begin{lcode}{Java}
enum ToiletterSymbols implements Symbol {
  Visitors, Down_Visitors, Up_Visitors, Up_Visitor, Down_Visitor, 
  Lowering_Visitor, Raising_Visitor,
  Actitivity
};
  \end{lcode}
Once these two are made, the grammar can be defined,
  using a fluent API generated by \SELF itself as shown
  in \cref{Figure:fluent}. 

\begin{figure}[htbp]
  \begin{lcode}{Java}
BNF toiletteBnf = new BNFBuilder()
  .with(ToiletterTerminals.class)
  .with(ToiletterSymbols.class)
  .start(Visitors)
  .derive(Visitors)
    .to(Down_Visitors)
  .derive(Down_Visitors)
    .to(Down_Visitor).and(Down_Visitors)
    .or().to(Raising_Visitor).and(Up_Visitors)
    .or().toEpsilon()
  .derive(Up_Visitors)
    .to(Up_Visitor).and(Up_Visitors)
    .or().to(Lowering_Visitor).and(Down_Visitors)
    .or().toEpsilon()
  .derive(Up_Visitor)
    .to(male).and(urinate)
  .derive(Down_Visitor)
      .to(female).and(Action)
      .or().to(male).and(defecate)
  .derive(Raising_Visitor)
      .to(male).and(raise).and(urinate)
  .derive(Lowering_Visitor)
    .to(female).and(lower).and(Action)
    .or().to(male).and(lower).and(defecate)
  .derive(Activity).to(urinate)
    .or().to(defecate)
  .finish();
  \end{lcode}
  \caption{A BNF grammar for the toilette seat problem}
  \label{Figure:fluent}
\end{figure}


Processing programming languages
\begin{description}
  \item[Lexical analysis] - the first step of the process in which the character strings generated by the 
  programmer are aggregated to the abstract tokens defined by the language designer.
  \item[Syntactical analysis (parsing) ] - the second step, in which the processed strings of tokens 
  conform to the rules of a formal grammar defined by the language's BNF (or EBNF).
  \item[Semantical analysis] - the next step, usually performed in unison with the previous step, 
  in which the legal token sequences are given their semantic meaning.
\end{description}
Specifically, the proposal is that API design of follows the footsteps of
Accordingly, the designer of a fluent API has to follow these three conceptual
steps.
First is the identification of the \emph{vocabulary}, i.e.,
the set of method calls including type arguments that may take part in the
fluent API.
In this fluent API example
\begin{lcode}{Java}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{lcode}
then, there are three method calls, and the vocabulary has three items in it.
\begin{itemize}
  \item~$ℓ₁ = \cc{any(Class<?>)}$
  \item~$ℓ₂ = \cc{allowing($ℓ₁$)}$
  \item~$ℓ₃ = \cc{method(String)}$
  \item~$ℓ₄ = \cc{withNoArguments()}$
\end{itemize}
