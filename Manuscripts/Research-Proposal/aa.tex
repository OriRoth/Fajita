The term \emph{method chaining} is illustrated in neat examples, such  
    as in the third to fifth line of the following \Java function: 
\begin{lCode}{JAVA}{Method chaining}
String time(int hours, int minutes, int seconds) { 
  StringBuilder sb  = new StringBuilder();
  return sb.append(hours).append(':')
          .append(minutes).append(':')
          .append(seconds).toString();
}
\end{lCode}
Method chaining is to say that the same object, \cc{sb} of type \cc{StringBuilder} in the above, 
   is the receiver of a chain of methods. 
This is achieved by making each variant of the method \cc{append} return the receiver, denoted by the 
  implicit argument \kk{this}.
With this convention, the chore of writing the tedious code 
\begin{lcode}{Java}
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString():
\end{lcode}
is a bit ameliorated. 
  
Now, definition found in the web of the term \emph{fluent API\footnote{API =
    \textbf Application \textbf Program \textbf Interface
}} are a bit illusive. 
Invariably, such definitions liken fluent API to method chaining; 
  they also tend to emphasize that fluent API is ``more'' than method
  chaining, and ask the reader to extrapolate from one term to the other.

Indeed, fluent API looks much like method chaining; indeed method chaining is a kind 
  of fluent API. 
However, the main distinction between the two terms is on the identity of the receiver.
In method chaining, all methods are invoked on the same object, whereas in fluent API
  the receiver of each method in the chain may be arbitrary. 
Perhaps surprisingly, this difference makes fluent API significantly more expressive.
Consider, for example, the following code fragment (drawn from JMock~\cite{Freeman:Pryce:06}) 
\begin{lCode}{Java}{Fluent API}
allowing (any(Object.class))
  .method("get.*")
  .withNoArguments();
\end{lCode}




