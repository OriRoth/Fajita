\subsection{Method Chaining}
The term \emph{method chaining} is illustrated in neat examples, such  
    as in the third to fifth line of the following \Java function: 
\begin{lCode}{JAVA}{Method chaining}
String time(int hours, int minutes, int seconds) { 
  StringBuilder sb  = new StringBuilder();
  return sb.append(hours).append(':')
          .append(minutes).append(':')
          .append(seconds).toString();
}
\end{lCode}
Method chaining is to say that the same object, \cc{sb} of type \cc{StringBuilder} in the above, 
   is the receiver of a chain of methods. 
This is achieved by making each variant of the method \cc{append} return the receiver, denoted by the 
  implicit argument \kk{this}.
With this convention, the chore of writing the tedious code 
\begin{lcode}{Java}
  sb.append(hours);
  sb.append(':');
  sb.append(minutes);
  sb.append(':');
  sb.append(seconds);
  return sb.toString():
\end{lcode}
is ameliorated a bit. 
  
\subsection{Fluent API}
Now, definition found in the web of the term \emph{fluent API\footnote{API =
    \textbf Application \textbf Program \textbf Interface
}} are a bit illusive. 
Invariably, such definitions liken fluent API to method chaining; 
  they also tend to emphasize that fluent API is ``more'' than method
  chaining, and ask the reader to extrapolate from one term to the other.

Indeed, fluent API looks much like method chaining; indeed method chaining is a kind 
  of fluent API. 
However, the main distinction between the two terms is the identity of the receiver.
In method chaining, all methods are invoked on the same object, whereas in fluent API
  the receiver of each method in the chain may be arbitrary. 
Perhaps surprisingly, this difference makes fluent API significantly more expressive.
Consider, for example, the following code fragment (drawn from JMock~\cite{Freeman:Pryce:06}) 
\begin{lCode}{Java}{Fluent API}
allowing (any(Object.class))
  .method("get.*")
  .withNoArguments();
\end{lCode}
Let the return type of function \cc{allowing} be denoted by $\tau_1$ and let the return type of function \cc{method} be denoted by $\tau_2$. 
Then, the fact that $\tau_1 \ne \tau_2$ means the set of methods that can be placed after the dot 
in the partial call chain
\begin{lcode}
   allowing(any(Object.class)). 
\end{lcode}
is distinct from the the set of methods that can be placed after the dot in the partial call chain
\begin{lcode}
  allowing(any(Object.class)).method("get.*").
\end{lcode}
This distinction make it possible to design expressive and rich fluent APIs, in which a sequence ``chained'' calls is not only readable, but also
robust, in the sense that the sequence is type correct, only when it the sequence makes sense semantically. 

\subsection{The Type Safe Toilette Seat}

An object of type toilette seat is created in the \cc{down} state, but it can then be \cc{raise}d to the \cc{up} state, and 
	then be \cc{lower}ed to the \cc{down} state. \footnote{
This example is inspired by earlier work of Donald E. Knuth on the topic~\cite{Knuth:92}}
Such an object be used by two kinds of users, \cc{male}s and \cc{female}s, for two distinct purposes: \cc{urinate} and \cc{defecate}.
Now a good fluent API design is one by which the following sequences of calls is type correct
\begin{lcode}
  new Seat().male().raise().urinate();
  new Seat().female().urinate();
 \end{lcode}
whereas the following sequence of method calls are illegal:
\begin{lcode}
   new Seat().female().raise();
   new Seat().male().raise().defecate();
   new Seat().male().male();
   new Seat().male().raise().urinate().male().raise();
 \end{lcode}
It should be clear that the type checking engine of the compiler can 
be employed to distinguish between legal and illegal sequences.
It should also be clear that fabricating the \kk{class}es, \kk{interface}s 
and the \kk{extends} and \kk{implements} relationship between these, is
far from being trivial. 

\subsection{Type State}
The toilette seat problem may be amusing to some, but it is not contrived in any way.
In fact, there is huge body of research on the general topics of 
	\emph{type-states}. (See e.g., review articles such as~\cite{Tom:Jerry:2001,Ben:Jerry:1934})
Informally, an object that belongs to a certain type (\kk{class} in the 
object oriented lingo), has type-states, if not all methods defined in this object's class are applicable to the object in all states it may be in.

A classical example of type-states is a file object: which can be in one of two states:
``open'' or ``closed''. Invoking a \cc{read()} method on the object is only permitted when the file is an ``open'' state.
In addition, method \cc{open()} (respectively \cc{close()}) can only be applied if the object is in the ``closed'' (respectively, ``open'') state.

Objects with type states such as toilette seats and files are not rarities.
In fact, a recent study estimates that about 70\% of \Java classes feature type states.
The challenge these pose is related to the problem of de


