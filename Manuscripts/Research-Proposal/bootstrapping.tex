As should be obvious from \cref{Figure:fluent}, \Self will be implemented
  in a bootstrapping fashion.
The specification of a BNF, is made itself using a fluent API.


This section describes how this is achieved.

\subsection{Reflective BNF}
\cref{Figure:BNF:BNF} is a \emph{reflective BNF}:
It uses the notation introduced in \cref{Figure:BNF}
  to specify this same notation.


\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<BNF> & ::= \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header> & ::= \<Variables> \~\<Terminals> \hfill⏎
      {} & \| \<Terminals> \~\<Variables> \hfill⏎
      \<Variables> & ::= \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Terminals> & ::= \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Body> & ::= \<Start> \~\<Conjunctions> \hfill⏎
      \<Start> & ::= \cc{start($\<Variable>$)} \hfill⏎
      \<Conjunctions> & ::= \<Conjunction>\~\<Additional-Conjunctions>\hfill⏎
      \<Additional-Conjunctions> & ::= \<Conjunction>\~ \<Additional-Conjunctions>\hfill⏎
      {} & \| ε \hfill⏎
      \<Conjunction> & ::= \<LHS>\~\<First-RHS>\~\<Additional-RHSs>\hfill⏎
      \<LHS> & ::= \cc{derive($\<Variable>$)}\hfill⏎
      \<First-RHS> & ::=	 \cc{to($\<Symbol>$)}\~\<Symbol-Sequence>\hfill⏎
      {} & \| \cc{toNone()}\hfill⏎
      \<Additional-RHSs> & ::= \<Additional-RHS>\~\<Additional-RHSs>\hfill⏎
      {} & \| ε\hfill⏎
      \<Additional-RHS> & ::= \cc{or($\<Symbol>$)}\~\<Symbol-Sequence>\hfill⏎
      {} & \| \cc{orNone()}      \hfill⏎
      \<Symbol-Sequence> & ::= ε \hfill⏎
      {} & \| \cc{and($\<Symbol>$)}\~\<Symbol-Sequence>      \hfill⏎
      \<Symbol> & ::= \cc{Terminal} \hfill⏎
      {\~} & \| \cc{Variable}\hfill⏎
      \<Variable> & ::= \cc{Variable} \hfill⏎
      \<Footer> & ::= \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for defining BNF grammars}
  \label{Figure:BNF:BNF}
\end{figure}
	% this is not a formal BNF because <Symbol> and <Variable> are not defined in the Symbols set.
\begin{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
Note that this specification can only be approximate;
  the figure uses verbs as replacement to indentation,
  and special symbols such as~$|$,~$::-$ and~$ε$.
  %%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{comment}

From \cref{Figure:BNF:BNF} we learn 
  that a BNF has three components: header, body and footer.
  \begin{enumerate}
    \item The sets of terminals and variables are defined in the header part.
    \item The body starts with a definition of the start symbol, followed by a list of derivation
  rules. 
\item The footer is simply the verb \cc{go()} which instructs \Self
  to generate the code that realizes the fluent API specified by the grammar.
  \end{enumerate}

A derivation rule starts with a variable, and is then followed by disjunctive alternatives.

The choice of verbs that may occur in, and between, these alternatives not incidental; 
  fluency was in mind:
\begin{description}
  \item[\cc{to}] to introduce the first symbol in the first conjunction.
  \item[\cc{or}] to introduce the first symbol in each subsequent conjunction.
  \item[\cc{and}] to introduce all but the first symbol in each such conjunction.
  \item[\cc{toNone}] to declare that the first conjunction is empty.
  \item[\cc{orNone}] to declare any subsequent conjunction is empty.
\end{description}

\subsection{Reflective BNF of fluent API}

To translate \cref{Figure:BNF:BNF} into a fluent
API chain, the verbs and nouns must be defined.

Verb definitions are made in the code excerpt in
\cref{Figure:Verbs}.

\begin{figure}[H]
  \begin{JAVA}[style=code]
enum BNFTerminals implements Terminal {¢¢
  toNone, orNone,go, // No parameters
  start,derive            // One parameter 
  with,             // One parameter, overloaded 
  or,and,to        // One parameter (or more), overloaded, variadic 
  ;
} 
  \end{JAVA}
  \caption{The verbs of \Self}
  \label{Figure:Verbs}
\end{figure}
Each of the enumerands in the figure is destined to be a 
  name of a method in a class to be generated by \Self.

Noun definitions are made in the code excerpt in \cref{Figure:Nouns}.

\begin{figure}[H]
  \begin{JAVA}[style=code]
enum BNFVariables implements Variable {¢¢
  BNF, Header, Body, Footer,
  Terminals, Variables, Start,
  Conjunctions, Additional_Conjunctions,
  Conjunction, LHS, First_RHS,Additional_RHSs,
  Additional_RHS, Symbol_Sequence,
  Symbol, Variable;
}\end{JAVA}
  \caption{The nouns of \Self}
  \label{Figure:Nouns}
\end{figure}
  \Self will eventually generate a code with
  a class named after each the enumerands in the figure.

The
enumerations \cc{BNFTerminals} and
  \cc{BNFVariables}
  are now employed in \cref{Figure:BNF:fluent}.

\begin{figure}[H]
  \begin{JAVA}[style=numbered]
new BNF()
  ¢¢.with(BNFTerminals.class)
  ¢¢.with(BNFSymbols.class)
  ¢¢.start(BNF)
  ¢¢.derive(BNF)
    ¢¢.to(Header).and(Body).and(Footer)
  ¢¢.derive(Header)
    ¢¢.to(Variables).and(Terminals)
    ¢¢.or(Terminals).and(Variables)
  ¢¢.derive(Variables)
    ¢¢.to(with, BNFVariables.class)
  ¢¢.derive(Terminals)
    ¢¢.to(with, BNFTerminals.class)
  ¢¢.derive(Body)
    ¢¢.to(Start).and(Conjunctions)
  ¢¢.derive(Start)
    ¢¢.to(start, Variable)
  ¢¢.derive(Conjunctions)
    ¢¢.to(Conjunction).and(Additional_Conjunctions)
  ¢¢.derive(Additional_Conjunctions)
    ¢¢.to(Conjunction).and(Additional_Conjunctions)
    ¢¢.orNone()
  ¢¢.derive(Conjunction)
    ¢¢.to(LHS).and(First_RHS).and(Additional_RHSs)
  ¢¢.derive(LHS)
    ¢¢.to(derive,Variable)
  ¢¢.derive(First_RHS)
    ¢¢.to(to,Symbol).and(Symbol_Sequence)
    ¢¢.or(toNone)
  ¢¢.derive(Additional_RHSs)
    ¢¢.to(Additional_RHS).and(Additional_RHSs)
    ¢¢.orNone()
  ¢¢.derive(Additional_RHS)
    ¢¢.to(or, Symbol).and(Symbol_Sequence)
    ¢¢.or(orNone)
  ¢¢.derive(Symbol_Sequence)
    ¢¢.toNone()
    ¢¢.or(and, Symbol).and(Symbol_Sequence)
  ¢¢.derive(Symbol)
    ¢¢.to(Terminal)
    ¢¢.or(Variable)
  ¢¢.derive(Footer)
    ¢¢.to(go)
¢¢.go();
\end{JAVA}
  \caption{A BNF grammar for \Self API}
  \label{Figure:BNF:fluent}
\end{figure}

The code excerpt in the figure is a rather long
  sequence of method calls.
This fluent API sequence is a reflective BNF 
  of the \Self API;
  indeed, we may check that \cref{Figure:BNF:BNF} reiterates \cref{Figure:BNF:BNF}
  (with notational changes as appropriate). 

\subsection{Parametrized Verbs}
Generally speaking, tokens come in two flavors:
\begin{itemize}
  \item \emph{Monomorphic tokens} are tokens such as punctuation marks and
    certain keywords such as ``\kk{if}'', ``\cc{static}'' and ``\cc{class}''.
    Such tokens carry no information other than their mere presence.
  \item \emph{Polymorphic tokens} are tokens which carry content beyond
    presence (or absence).  The prime example of these are identifiers.
\end{itemize}

This distinction applies also to fluent APIs:
Methods, or verbs, are the tokens, and a fluent APIs sequence consists of 
method calls that come in two kinds: those that do not take parameters (such as \cc{toNone()} in \cref{Figure:BNF:fluent}), 
and those that do (such as the call \cc{derives($\cdot$)} in the figure).

\Self supports verbs with, and without, noun parameters. 
The following examples,`drawn from \cref{Figure:fluent} and \cref{Figure:BNF:fluent},
  demonstrate, 
\begin{JAVA}
    ¢¢.to(male)
    ¢¢.to(with, Terminal.class)
    ¢¢.to(with, Variable.class)
    ¢¢.to(start, Variable)\end{JAVA}
(The above is made possible with minor \Java language trickery,
  involving overloading and use of variadic signatures,
  with respect to function name \cc{to}.
Same trickery was applied to verbs \cc{or}, and \cc{and}.)



  
