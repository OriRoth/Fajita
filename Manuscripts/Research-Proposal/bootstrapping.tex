As should be obvious from \cref{Figure:fluent}, \SELF will be implemented
  in a bootstrapping fashion.
The specification of a BNF, is made itself using a fluent API.


This section desribes how this is achieved.

\subsection{Reflective BNF}
\cref{Figure:BNF:BNF} is a \emph{reflectie BNF}:
It uses the notation introduced in \cref{Figure:BNF}
  to specify this same notation.


\begin{figure}[H]
  \begin{Grammar}
    \begin{aligned}
      \<BNF> & ::= \<Header>\~\<Body>\~\<Footer> \hfill⏎
      \<Header> & ::= \<Symbols> \~\<Terminals> \hfill⏎
      {} & \| \<Terminals> \~\<Symbols> \hfill⏎
      \<Terminals> & ::= \cc{with(Class<? \kk{extends} Terminal>)}\hfill⏎
      \<Symbols> & ::= \cc{with(Class<? \kk{extends} Variable>)}\hfill⏎
      \<Body> & ::= \<Start> \~\<Rules> \hfill⏎
      \<Start> & ::= \cc{start($\<Variable>$)} \hfill⏎
      \<Rules> & ::= \<First-Rule> \~\<Additional-Rules> \hfill⏎
      \<Additional-Rules> & ::= \<Additional-Rules>\~\<Additional-Rule> \hfill⏎
      {} & \| ε \hfill⏎
      \<First-Rule> & ::= \cc{to($\<Symbol>$)}\~\<Sequence> \hfill⏎
      {} & \| \cc{toNone()} \hfill⏎
      \<Additional-Rule> & ::= \cc{or($\<Symbol>$)}\~\<Sequence> \hfill⏎
      {} & \| \cc{orNone()} \hfill⏎
      \<Sequence> & ::= ε \hfill⏎
      {\~} & \| \cc{and($\<Symbol>)$} \hfill⏎
      \<Variable> & ::= \cc{Terminal} \hfill⏎
      {\~} & \| \cc{Variable}\hfill⏎
      \<Footer> & ::= \cc{go()}\hfill⏎
    \end{aligned}
  \end{Grammar}
  \caption{A BNF grammar for BNF grammars}
  \label{Figure:BNF:BNF}
\end{figure}

Note that this specification can only be approximate;
  the figure uses verbs as replacement to indentation,
  and special symbols such as~$|$,~$::-$ and~$ε$

From \cref{Figure:BNF:BNF} we learn 
  that a BNF has three components: header, body and footer.
  \begin{enumerate}
    \item The sets of terminals and variables are defined in the header part, 
    \item The body starts with a definition of the start symbol, followed by a list of derivation
  rules. 
\item The footer is simply the verb \cc{go()} which instructs \SELF
  to generate the code that realizes the fluent API specified by the grammar.
  \end{enumerate}

A derivation rule starts with a variable, and is then followed by disjunctive alternatives.
The choice of verbs was not incidental; fluency was in mind:
\begin{description}
  \item[\cc{to}] to introduce the first symbol in the first conjunction.
  \item[\cc{or}] to introduce the first symbol in each subsequent conjunction.
  \item[\cc{and}] to introduce all but the first symbol in each such conjunction.
  \item[\cc{toNone}] to declare that the first conjunction is empty.
  \item[\cc{orNone}] to declare any subsequent conjunction is empty.
\end{description}

\subsection{Reflective BNF of fluent API}

To translate \cref{Figure:BNF:BNF} into a fluent
API chain, the verbs and nouns must be defined.

Verb definitions are made in the code excerpt in
\cref{Figure:Verbs}.

\begin{figure}[H]
  \begin{JAVA}[style=code]
enum BNFTerminals implements Terminal {
  toNone, orNone,// No parameters
  start,         // One parameter 
  with,          // One parameter, overloaded 
  or,and,to,     // One parameter (or more), overloaded, variadic 
  ;
} \end{JAVA}
  \caption{The nouns of \SELF}
  \label{Figure:Verbs}
\end{figure}

Noun definitions are made in the code excerpt in \cref{Figure:Nouns}.

\begin{figure}[H]
  \begin{JAVA}[style=code]
enum BNFVariables implements Variable {
  BNF, Header, Body, Footer,
  Start, Terminals, Symbols,
  Start, Rules, Additional_Rules,
  First_Rule, Additional_Rule,
  Sequence, Symbol;
}\end{JAVA}
  \caption{The nouns of \SELF}
  \label{Figure:Nouns}
\end{figure}

The
\kk{enum}erations \cc{BNFTerminals} and
  \cc{BNFVariables}
  are now employed in \cref{Figure:BNF:fluent}.


\begin{figure}[H]
  \begin{JAVA}[style=numbered]
new BNF()
  .with(BNFTerminals.class)
  .with(BNFSymbols.class)
  .start(BNF)
  .derive(BNF)
    .to(Header).and(Body).and(Footer)
  .derive(Header)
    .to(Variables).and(Terminals)
    .or(Terminals).and(Variables)
  .derive(Terminals)
    .to(with, Terminal.class)
  .derive(Variables)
    .to(with, Variable.class)
  .derive(Body)
    .to(Start).and(Rules)
  .derive(Start)
    .to(start, Variable)
  .derive(Rules)
    .to(First_Rule).and(Additional_Rules)
  .derive(Additional_Rules)
    .to(Additional_Rules).and(Additional_Rule)
    .orNone()
  .derive(First_Rule)
    .to(to,Symbol).and(Sequence)
    .or(toNone)
  .derive(Additional_Rule)
    .to(or, Symbol).and(Sequence)
    .or(orNone)
  .derive(Sequence)
    .toNone()
    .or(and, Symbol).and(Sequence)
  .derive(Variable)
    .to(Terminal)
    .or(Variable)
  .derive(Footer).
     .to(go)
.go();\end{JAVA}
  \caption{A BNF grammar for the toilette seat problem}
  \label{Figure:BNF:fluent}
\end{figure}

The code excerpt in the figure is a rather long
  sequence of method calls.
This fluent API sequence is a reflective BNF 
  of the \SELF API;
  indeed, we may check that \cref{Figure:BNF:BNF} reiterates \cref{Figure:BNF:BNF}
  (with notational changes as appropriate). 

\subsection{Parameterized Verbs}
Generally speaking, tokens come in two flavors: 
  \emph{Monomorphic tokens} are tokens such as punctuation marks and certain keywords  
    such as ``\kk{if}'', ``\cc{static}'' and ``\cc{class}''. 
Such tokens carry no information other than their mere presence.
\emph{Polymorphic tokens} are tokens which carry content beyond presence (or absence). 
The prime example of these are identifiers. 

This distinction applies also to fluent APIs:
Methods, or nouns, are the tokens, and a fluent APIs sequence consists of 
  method calls that come in two kinds: those take do not take parameters, and those that do.

\SELF supports verbs with, and without, noun parameters. 
The following examples,`drawn from \cref{Figure:fluent} and \cref{Figure:BNF:fluent},
  demonstrate, 
\begin{JAVA}
    .to(male)
    .to(with, Terminal.class)
    .to(with, Variable.class)
    .to(start, Variable)\end{JAVA}
(The above is made possible with minor \Java language trickery,
  involving overloading and use of variadic signatures,
  with respect to function name \cc{to}.
Same trickery was applied to verbs \cc{or}, and \cc{and}.)



  
