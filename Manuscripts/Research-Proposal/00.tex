\title{%
  \Huge \SELF \\ 
  \huge \itshape \textbf Fluent \textbf API for \textsc{\textbf Java} \\
  \huge (\textbf Inspired by the \textbf Theory of \textbf Automata)
} 
\documentclass[10pt,twocolumn]{article}

\usepackage{\jobname}

\author{Tome Levy\\
	Department of Computer Science\\
	Technion---Israel Institute of Technology\\
	\texttt{\small \href{mailto:stlevy@campus.technion.ac.il}{stlevy@campus.technion.ac.il}}}
\date{
  Research Proposal\\
\small Advised by Prof.\ Yossi Gil
}

\begin{document}
\maketitle
  
\begin{abstract}
	\input{abstract} 
\end{abstract}

\section{Introduction}
\input{aa}

\paragraph{Outline.} 
The remainder of this document is organized as follows.
\Cref{Section:terminology}, intended mostly to the general, non software engineering, 
  computer science audience is a brief reminder of pertinent terminology.
This terminology is then used in \cref{Section:proposal} for 
  an introductory exposition of \SELF.
The main ideas behind the bootstrapping definition of \SELF 
  are revealed in \Cref{Section:bootstrapping}. 
\Cref{Section:zz} concludes. 

\section{Terminology}
\label{Section:terminology}
\input{terminology}

\section{This Proposal}
\label{Section:proposal}
\input{proposal}

\section{Bootstrapping Definition}
\label{Section:boostrapping}
\input{bootstrapping}

\section{Conclusion}
\label{Section:zz}
\input{zz}

\bibliographystyle{abbrv}
%\bibliography{publishers,other_shorthands,institutions,author_names,journals_full,yogi-journal,yogi-book,00}
\bibliography{author-names,other-shorthands,publishers-abbreviated,yogi-book,00}
\end{document}

Processing programming languages
\begin{description}
  \item[Lexical analysis] - the first step of the process in which the character strings generated by the 
  programmer are aggregated to the abstract tokens defined by the language designer.
  \item[Syntactical analysis (parsing) ] - the second step, in which the processed strings of tokens 
  conform to the rules of a formal grammar defined by the language's BNF (or EBNF).
  \item[Semantical analysis] - the next step, usually performed in unison with the previous step, 
  in which the legal token sequences are given their semantic meaning.
\end{description}
Specifically, the proposal is that API design of follows the footsteps of
Accordingly, the designer of a fluent API has to follow these three conceptual
steps.
First is the identification of the \emph{vocabulary}, i.e.,
the set of method calls including type arguments that may take part in the
fluent API.
In this fluent API example
\begin{lcode}{Java}
allowing (any(Object.class))
  ¢¢.method("get.*")
  ¢¢.withNoArguments();
\end{lcode}
then, there are three method calls, and the vocabulary has three items in it.
\begin{itemize}
  \item~$ℓ₁ = \cc{any(Class<?>)}$
  \item~$ℓ₂ = \cc{allowing($ℓ₁$)}$
  \item~$ℓ₃ = \cc{method(String)}$
  \item~$ℓ₄ = \cc{withNoArguments()}$
\end{itemize}
